{"meta":{"title":"DEVLOG of andyyou","subtitle":"Conquer & Divide","description":"The journals and articles are written by andyyou. Most of all just recording of how to slove problem, fix bugs in programming area. Apart from those I also write a bit tutorials. Here just a backup. Some content just draft or notes for me.","author":"andyyou(You,ZongYan)","url":"//andyyou.github.io"},"pages":[{"title":"Tags","date":"2016-10-10T13:04:09.000Z","updated":"2016-10-10T07:01:03.000Z","comments":true,"path":"tags/index.html","permalink":"//andyyou.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-10-10T13:04:09.000Z","updated":"2016-10-10T07:01:03.000Z","comments":true,"path":"categories/index.html","permalink":"//andyyou.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue.js 由 1 到 2 的旅程 - (1)","slug":"vue-hook","date":"2016-12-05T07:29:00.000Z","updated":"2016-12-05T07:41:23.000Z","comments":true,"path":"2016/12/05/vue-hook/","link":"","permalink":"//andyyou.github.io/2016/12/05/vue-hook/","excerpt":"這系列文章會是記錄從 Vue 版一轉移到版二過程中差異點的筆記，希望以輕鬆短篇的方式撰寫。小弟認為如果您不是那種會乖乖的把文件完整娓娓讀一遍的人，有許多差異點可能就被您忽略了，當然就把它們忘了或從來沒理解過（從 Vue 2 入手的朋友們）也不會是什麼大問題，反正等到您遇到問題的時候肯定又會找到它。不過這系列跟希望紀錄的是思路的演進，像是為什麼不支援內建 filter 這類的議題，每一次改變總有它的道理我們不一定能參透但試著想想看並記錄下來希望下一次能成為更好的開發者。 廢話不多說就讓我們開始來說今天的故事：","text":"這系列文章會是記錄從 Vue 版一轉移到版二過程中差異點的筆記，希望以輕鬆短篇的方式撰寫。小弟認為如果您不是那種會乖乖的把文件完整娓娓讀一遍的人，有許多差異點可能就被您忽略了，當然就把它們忘了或從來沒理解過（從 Vue 2 入手的朋友們）也不會是什麼大問題，反正等到您遇到問題的時候肯定又會找到它。不過這系列跟希望紀錄的是思路的演進，像是為什麼不支援內建 filter 這類的議題，每一次改變總有它的道理我們不一定能參透但試著想想看並記錄下來希望下一次能成為更好的開發者。 廢話不多說就讓我們開始來說今天的故事： is 與 &lt; component &gt;事實上很多直上 vue-loader 的觀眾們可能會忽略 Vue 有一個 &lt; component &gt; 樣板標籤。怎麼使用呢？看看下面的範例程式碼，假如我們定義了一個元件： 12345678910111213141516Vue.component('engine', &#123; template: ` &lt;div&gt; Engine: TSI &lt;/div&gt; `,&#125;)new Vue(&#123; el: '#root', template: ` &lt;div&gt; &lt;component is=\"engine\"&gt;&lt;/component&gt; &lt;/div&gt; `&#125;) 什麼用途呢？腦袋轉得快的朋友們馬上就意識到可以用來 binding 變數切換元件，官方文件當然也有說明。 12345678910111213141516171819202122232425Vue.component('iphone', &#123; template: `&lt;div&gt;iphone&lt;/div&gt;`&#125;)Vue.component('s7', &#123; template: `&lt;div&gt;Samsung S7&lt;/div&gt;`&#125;)new Vue(&#123; el: '#app', template: ` &lt;div&gt; &lt;button type=\"button\" @click=\"change\"&gt;Change Phone&lt;/button&gt; &lt;component :is=\"mobile\"&gt;&lt;/component&gt; &lt;/div&gt; `, data: &#123; mobile: 'iphone' &#125;, methods: &#123; change: function () &#123; this.mobile = this.mobile === 'iphone' ? 's7' : 'iphone' &#125; &#125;&#125;) keep-alive不管您是順著文件閱讀或是直覺地想問 切換過程中我可以保留該元件的狀態嗎？ 萬一我的元件很大可以快取嗎？，下一個解救我們的主角 - keep-alive 就會接續登場。 沒錯！它的用途就是將我們的物件實例暫存在記憶體，避免反覆重新渲染同時也保留了狀態。只不過他在版本ㄧ、二之間有點差異： 1234567&lt;!-- v 1.x --&gt;&lt;component :is=\"currentView\" keep-alive&gt;&lt;/component&gt;&lt;!-- v 2.x --&gt;&lt;keep-alive&gt; &lt;component :is=\"currentView\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 上面這兩小節純粹是為了鋪陳，沒什麼特別驚人之處，keep-alive 也只是順便帶上。接下來就是本日容易忽略的地方： 今日特餐 - activate（v1.x） v.s activated/deactivated（v2.x）先來聊聊在版本一時，官方文件 - Components 一章曾經探討到關於 activate 這個特殊的 hook。白話文來說這個事件在我們手動插入 Vue 物件實例時，例如：使用 new Vue() 的情況下是不會被觸發的。只有在使用 這樣的方式才會發動，第一次認識這傢伙是因為 vue-router v1。 另外這傢伙有一個特殊之處就是它具備一個 done 參數，須被執行元件才會正確地被掛載。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Vue 1.x */Vue.component('transmission', &#123; template: ` &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; `, data: function () &#123; return &#123; name: 'DQ200' &#125; &#125;, activate: function (done) &#123; console.log('transmission activate') done() &#125;&#125;)Vue.component('engine', &#123; template: ` &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; `, data: function () &#123; return &#123; name: 'TSI' &#125; &#125;, activate: function (done) &#123; console.log('engine activate') done() &#125;&#125;)new Vue(&#123; el: '#car', activate: function (done) &#123; console.log('car activate') // missing: no trigger done() &#125;&#125;) jsfiddle 這也讓我們有機會在切換元件的過程中確定是不是該輸出該元件。可想而知這用在 router 上是多麽合適。 那麼在版本二之後呢？ 在 Vue 2.x 裡我們已經沒有這個 Hook 可以使用了，沒有取而代之。但是有相似的傢伙 - 是 activated 與 deactivated。且需要注意的是這兩個掛鉤只會在套用 keep-alive 時被觸發。注意過去式，這兩者和版本一的 activate 觸發的時間點是不同的。 123456789101112131415161718192021222324252627282930313233343536373839Vue.component('iphone', &#123; template: `&lt;div&gt;iphone&lt;/div&gt;`, activated: function () &#123; console.log('iphone activated') &#125;, deactivated: function () &#123; console.log('iphone deactivated') &#125;&#125;)Vue.component('s7', &#123; template: `&lt;div&gt;Samsung S7&lt;/div&gt;`, activated: function () &#123; console.log('s7 activate') &#125;, deactivated: function () &#123; console.log('s7 deactivated') &#125;&#125;)new Vue(&#123; el: '#app', template: ` &lt;div&gt; &lt;button type=\"button\" @click=\"change\"&gt;Change Phone&lt;/button&gt; &lt;keep-alive&gt; &lt;component :is=\"mobile\"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;/div&gt; `, data: &#123; mobile: 'iphone' &#125;, methods: &#123; change: function () &#123; this.mobile = this.mobile === 'iphone' ? 's7' : 'iphone' &#125; &#125;&#125;) jsfiddle","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"vuejs","slug":"vuejs","permalink":"//andyyou.github.io/tags/vuejs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"穠纖合度的整合 Rails、Webpack、Vuejs","slug":"integrate-rails-webpack-vue","date":"2016-11-07T10:41:37.000Z","updated":"2016-11-08T01:16:45.000Z","comments":true,"path":"2016/11/07/integrate-rails-webpack-vue/","link":"","permalink":"//andyyou.github.io/2016/11/07/integrate-rails-webpack-vue/","excerpt":"前言如果您曾經閱讀過小弟的vue + webpack 起手式一文，裡面我曾提到關於容易與傳統 MVC 框架(Rails, ASP.NET MVC)等結合。這篇文章主要就是用來介紹其作法與為什麼我會這麼說。 我先承認吧！我不總是需要使用 SPA 的架構 雖然它很好，但對於很多小型專案，或者我們應該說 UI/UX 設計本身非常單純的專案 - 殺雞焉用牛刀。所以這邊文章的作法針對的是那些專案不是使用 SPA 搭配 API 的架構的人，而是您覺得既有的 MVC 框架對於您的需求開發已經非常足夠且想保留大多數這些框架提供的功能（本文僅針對 Rails 介紹）。 網路上有非常多關於 Rails 與 Webpack 整合的方式，其實都非常不錯。而關於本文只是介紹其中一種小弟認為剛剛好的整合方式，其中許多觀念都不是新創的，都只是整理過去學習經驗而成。","text":"前言如果您曾經閱讀過小弟的vue + webpack 起手式一文，裡面我曾提到關於容易與傳統 MVC 框架(Rails, ASP.NET MVC)等結合。這篇文章主要就是用來介紹其作法與為什麼我會這麼說。 我先承認吧！我不總是需要使用 SPA 的架構 雖然它很好，但對於很多小型專案，或者我們應該說 UI/UX 設計本身非常單純的專案 - 殺雞焉用牛刀。所以這邊文章的作法針對的是那些專案不是使用 SPA 搭配 API 的架構的人，而是您覺得既有的 MVC 框架對於您的需求開發已經非常足夠且想保留大多數這些框架提供的功能（本文僅針對 Rails 介紹）。 網路上有非常多關於 Rails 與 Webpack 整合的方式，其實都非常不錯。而關於本文只是介紹其中一種小弟認為剛剛好的整合方式，其中許多觀念都不是新創的，都只是整理過去學習經驗而成。 需求先談談我們的需求與為什麼不使用 asset pipeline，其實簡單來說就是下面列表這些： 我們想使用 ES2015 等新支援的語法，需要 Babel。 許多套件在 bower 上面編譯後的版本並不完整、不支援、或者有其他問題導致我們需要使用 npm。 我們想透過模組來管理相依性的問題。 assets-org 和 gem 對於管理前端資源包來說並不是那麼優秀。 部署希望能夠盡可能單純一點。 準備大體來說這種整合的架構使用 npm (yarn 也可) 來管理前端的資源，gem 則只負責後端部分。 安裝 nodejs 與 npm 安裝 ruby 與 Rails 安裝 Postgre SQL(由於會示範部署至 Heroku 所以使用 Postgre SQL) 第一步 - 建立專案12345678910# 由於示範部署至 Heroku# 因此無法使用 sqlite3$ rails _5.0.0.1_ new [project_name] --database postgresql$ cd [project_name]$ bundle install$ rails db:create$ rails g controller pages index # 建立測試頁面$ rails server # 完成建立一個 Rails 專案# 開啟 http://localhost:3000/pages/index 導入 npm 123456789101112131415161718192021222324252627282930313233$ npm init --yes# 過程中，如果需要測試一下 webpack 指令則需要安裝全域$ npm i -g webpack webpack-dev-server# 安裝所需的前端函式庫$ npm i jquery@^2.1.4 -S$ npm i jquery-ujs@~1.1.0-1 -S$ npm i lodash@~3.0.0 -S$ npm i vue -S# 安裝開發環境所需的套件與函式庫$ npm i webpack \\ webpack-dev-server \\ webpack-manifest-plugin \\ extract-text-webpack-plugin -D$ npm i babel-core \\ babel-loader babel-runtime \\ babel-plugin-transform-runtime \\ babel-preset-es2015 -D # Babel 相關$ npm i coffee-loader coffee-script -D$ npm i css-loader \\ style-loader \\ node-sass \\ sass-loader -D$ npm i exports-loader -D # 匯出檔案$ npm i expose-loader -D # 將物件加到全域(Javascript)$ npm i file-loader url-loader -D$ npm i imports-loader -D # 使用的模組可相依於全域 為了方便您快速安裝下面提供 package.json 123456789101112131415161718192021222324252627282930313233343536373839404142\"dependencies\": &#123; \"jquery\": \"^2.2.4\", \"jquery-ujs\": \"^1.1.0-1\", \"lodash\": \"^3.0.1\", \"vue\": \"^2.0.5\"&#125;,\"devDependencies\": &#123; \"babel-core\": \"^6.18.2\", \"babel-loader\": \"^6.2.7\", \"babel-plugin-transform-runtime\": \"^6.15.0\", \"babel-preset-es2015\": \"^6.18.0\", \"babel-runtime\": \"^6.18.0\", \"coffee-loader\": \"^0.7.2\", \"coffee-script\": \"^1.11.1\", \"css-loader\": \"^0.25.0\", \"exports-loader\": \"^0.6.3\", \"expose-loader\": \"^0.7.1\", \"extract-text-webpack-plugin\": \"^1.0.1\", \"file-loader\": \"^0.9.0\", \"imports-loader\": \"^0.6.5\", \"node-sass\": \"^3.11.2\", \"sass-loader\": \"^4.0.2\", \"style-loader\": \"^0.13.1\", \"url-loader\": \"^0.5.7\", \"webpack\": \"^1.13.3\", \"webpack-dev-server\": \"^1.16.2\", \"webpack-manifest-plugin\": \"^1.1.0\"&#125;,\"babel\": &#123; \"presets\": [ \"es2015\" ], \"plugins\": [ [ \"transform-runtime\", &#123; \"polyfill\": false, \"regenerator\": true &#125; ] ]&#125; 第二步 - 組織架構為了讓部署與後續設定單純一點，我們選擇將 javascript 和 css 的資源檔抽出原本的目錄，並同時也保留 Rails 預設的相關功能。大略的架構會如下，我們會將所有的前端資源放在 client 目錄底下，當然您要取名叫 webpack 或 frontend 也都是OK的。 12345678910111213141516171819.├── /app│ ├── /assets│ ├── /controllers│ ├── /views│ └── ...├── /bin├── /config├── /db├── /public├── ...├── /client│ ├── /fonts│ ├── /images│ ├── /javascripts│ ├── /stylesheets│ ├── development.config.js│ ├── production.config.js└── ... 除非您是指令控，不然您可以就使用編輯器建立相關檔案與目錄 12345678910111213$ mkdir -p client/javascripts$ mkdir client/fonts$ mkdir client/images$ mkdir client/stylesheets# 新增 Entry Point 檔案$ touch client/javascripts/application.js$ touch client/javascripts/home.coffee # 測試 coffee 使用$ touch client/fonts/.keep$ touch client/images/.keep$ touch client/stylesheets/home.scss$ touch client/development.config.js$ touch client/production.config.js 注意因為這個專案會有 Nodejs 混入，所以您應該要在 .gitignore 中增加相關的設定。 1234567891011121314# Nodenode_modulesjspm_packages.npm.eslintcachenpm-debug.log*pids*.pid*.seed*.pid.lock.nyc_output.grunt.lock-wscriptbuild/Release 簡易的驗證範例 javascripts/home.coffee 1console.log \"Hello, CoffeeScript!\" stylesheets/home.scss 1234/* 記得放一張圖片 */.home-banner &#123; background-image: url('../images/banner.png');&#125; javascripts/application.js 12import styles from '../stylesheets/home.scss'import Home from './home' 第三步 - 配置 webpackdevelopment.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var path = require('path')var _ = require('lodash')var webpack = require('webpack')var assetsPath = path.join(__dirname, '..', 'public', 'assets')var ExtractTextPlugin = require('extract-text-webpack-plugin')var config = &#123; context: path.join(__dirname, '..'), entry: &#123; /* 定義進入點與其檔案名稱 */ application: [ path.join(__dirname, '/javascripts/application.js') ] &#125;, output: &#123; path: assetsPath, filename: '[name]-bundle.js', publicPath: '/assets/' &#125;, resolve: &#123; extensions: ['', '.js', '.coffee', '.json'] &#125;, debug: true, displayErrorDetails: true, outputPathinfo: true, devtool: 'cheap-module-eval-source-map', module: &#123; loaders: [ &#123; test: require.resolve('jquery'), loader: 'expose?jQuery' &#125;, &#123; test: require.resolve('jquery'), loader: 'expose?$' &#125;, &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, &#123; test: /\\.coffee$/, loader: 'coffee' &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)\\??.*$/, loader: 'url?limit=8192&amp;name=[name].[ext]' &#125;, &#123; test: /\\.(jpe?g|png|gif|svg)\\??.*$/, loader: 'url?limit=8192&amp;name=[name].[ext]' &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css') &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass') &#125; ] &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;), new ExtractTextPlugin('[name]-bundle.css', &#123; allChunks: true &#125;) ]&#125;module.exports = config production.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var path = require('path')var _ = require('lodash')var webpack = require('webpack')var assetsPath = path.join(__dirname, '..', 'public', 'assets')var ExtractTextPlugin = require('extract-text-webpack-plugin')var ManifestPlugin = require('webpack-manifest-plugin')var config = &#123; context: path.join(__dirname, '..'), entry: &#123; application: path.join(__dirname, '/javascripts/application.js') &#125;, output: &#123; path: assetsPath, filename: '[name]-bundle-[chunkhash].js', publicPath: '/assets/' &#125;, resolve: &#123; extensions: ['', '.js', '.coffee', '.json'] &#125;, debug: true, displayErrorDetails: true, outputPathinfo: true, devtool: 'cheap-module-eval-source-map', module: &#123; loaders: [ &#123; test: require.resolve('jquery'), loader: 'expose?jQuery' &#125;, &#123; test: require.resolve('jquery'), loader: 'expose?$' &#125;, &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, &#123; test: /\\.coffee$/, loader: 'coffee' &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)\\??.*$/, loader: 'url?limit=8192&amp;name=[name]-[hash].[ext]' &#125;, &#123; test: /\\.(jpe?g|png|gif|svg)\\??.*$/, loader: 'url?limit=8192&amp;name=[name]-[hash].[ext]' &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css') &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass') &#125; ] &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;), new ExtractTextPlugin('[name]-bundle-[chunkhash].css', &#123; allChunks: true &#125;), new ManifestPlugin(&#123; fileName: 'client_manifest.json' &#125;) ]&#125;module.exports = config 完成之後執行，測試看看是否有地方錯誤。如果您對於 webpack 並不陌生可以閱讀設定檔理解一下。 12$ webpack --config client/development.config.js$ webpack --config client/production.config.js 查看 public/assets 目錄底下看看編譯的結果。 第四步 - 整合 Rails到此您應該已經理解，我們就是將前端的部份交給 webpack 處理，然後遵循 Rails 的架構將最終的資源檔編譯輸出到 public/assets 。 現在的問題是，我們該如何讀取編譯好的資源呢？ 由於我們希望能夠盡可能的遵循 Rails 的慣例，因此下一步我們在 app/views/layouts/application.html.erb 放入 12&lt;%= client_stylesheet_link_tag 'application' %&gt;&lt;%= client_javascript_include_tag 'application' %&gt; 上面是我們希望的作法（看起來就像是預設支援），所以接著下來我們需要做一些修改好讓 Rails 支援上面兩個 helpers。 首先因為 webpack 加上 hash 的編譯結果，Rails 並無法得知對應的檔案。於是我們需要在 production.config.js 使用 ManifestPlugin 匯出 manifest 讓 Rails 得知如何對應檔案。 config/application.rb 12345678910111213require_relative 'boot'require 'rails/all'Bundler.require(*Rails.groups)module RailsWepback class Application &lt; Rails::Application config.webpack = &#123; asset_manifest: &#123;&#125; &#125; endend 新增 config/initializers/webpack.rb 1234567asset_manifest = Rails.root.join('public', 'assets', 'client_manifest.json')if File.exist?(asset_manifest) Rails.configuration.webpack[:manifest] = JSON.parse( File.read(asset_manifest) ).with_indifferent_accessend 完成這些前置作業之後我們可以讀取到 manifest 了，但您知道的；原生的 Rails 並沒有剛剛那兩個 helpers ，我們需要在 app/helplers/application_helper.rb 加上 1234567891011121314151617181920212223242526272829def client_javascript_include_tag(name) filename = \"#&#123;name&#125;-bundle.js\" asset_url = Rails.application.config.asset_host src = \"#&#123;asset_url&#125;/assets/#&#123;filename&#125;\" if Rails.env.development? elsif Rails.configuration.webpack[:manifest] asset_name = Rails.configuration.webpack[:manifest][\"#&#123;name&#125;.js\"] if asset_name src = \"#&#123;asset_url&#125;/assets/#&#123;asset_name&#125;\" end end \"&lt;script src=\\\"#&#123;src&#125;\\\"&gt;&lt;/script&gt;\".html_safeenddef client_stylesheet_link_tag(name) filename = \"#&#123;name&#125;-bundle.css\" asset_url = Rails.application.config.asset_host src = \"#&#123;asset_url&#125;/assets/#&#123;filename&#125;\" if Rails.env.development? elsif Rails.configuration.webpack[:manifest] asset_name = Rails.configuration.webpack[:manifest][\"#&#123;name&#125;.css\"] if asset_name src = \"#&#123;asset_url&#125;/assets/#&#123;asset_name&#125;\" end end \"&lt;link rel=\\\"stylesheet\\\" href=\\\"#&#123;src&#125;\\\"&gt;\".html_safeend 這上面的 asset_host 是為了讓事情單純一點，我們選擇在 config/environments/development.rb 和 production.rb 加上 12# 路徑請依據實際的狀況調整config.action_controller.asset_host = '127.0.0.1:3000' 您可以採取任何您覺得更好的方式取得路徑。 完成第一階段到這一步，其實我們已經完成最上面我們列出的需求了。 先在 terminal 中執行 1$ webpack --config client/development.config.js --watch 開啟另一個 session 執行 1$ rails server 最後在 views/pages/index.html.erb 中的任一 tag 補上 class=&quot;home-banner&quot; 您就可以觀察到變化。webpack 在背後一直觀察 client 底下檔案的變化，Rails 的開發伺服器則負責原來的工作，載入那些編譯後的檔案。 只是這樣每一次要測試都要打兩條指令很麻煩。 優化開發指令 新增 npm scripts 再往下走之前，我們可以先把 webpack 的指令與其單配的參數先整理到 npm script 1234\"scripts\": &#123; \"build:dev\": \"webpack --config=client/development.config.js --display-reasons --display-chunks --progress --color --watch\", \"build\": \"webpack --config=client/production.config.js -p\"&#125; 接著為了讓我們往後只使用一道指令就能夠輕鬆寫意的開發。最簡單的方式就是使用 foreman 1$ gem install foreman 安裝完 foreman 之後我們需要設定 Procfile 讓其為我們同時啟動兩道指令。 新增 Procfile.dev Procfile support 類型程式預設使用 Procfile 為設定檔，如果直接使用該檔案可能會遇到問題，例如：當我們要使用 Heroku 的話，後續可能在部署的時候產生問題，主要是目前的設定僅限於開發階段使用，於是我們改使用其他的檔名 Procfile.dev。 在專案跟目錄下新增 Procfile.dev 12web: bundle exec rails server -p 3000webpack: npm run build:dev 使用 foreman 1$ foreman s -f Procfile.dev 啟動後您應該看到類似的訊息： 123456789101118:30:56 web.1 | started with pid 1669318:30:56 webpack.1 | started with pid 1669418:30:57 webpack.1 |18:30:57 webpack.1 | &gt; example@1.0.0 build:dev /Users/andyyou/Workspace/sandbox/rails_vuejs_integrate_1/example18:30:57 webpack.1 | &gt; webpack --config=client/development.config.js --display-reasons --display-chunks --progress --color --watch18:30:57 webpack.1 |Hash: 2fdcbe01c557b347442e18:31:00 web.1 | =&gt; Booting Puma18:31:00 webpack.1 | Version: webpack 1.13.318:31:00 web.1 | =&gt; Rails 5.0.0.1 application starting in development on http://localhost:300018:31:00 webpack.1 | Time: 2893ms 支援 Hot Reload基本上到了上一步就已經可以滿足大多數的開發情境，不過您可能也聽多了關於 Hot Replacement Mode (HRM) 的優點，如果我們也想支援呢？ 原理上很單純，我們只需要讓前端資源檔換成是由 webpack-dev-server 所提供即可。 新增 devserver.config.js 注意到基本上這邊只有加入 webpack/hot/dev-server 和 publicPath 不同的差異，可以有更精簡的方式，不過這邊為了讓之後維護比較明顯直覺一點所以將其獨立一個檔案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var path = require('path')var _ = require('lodash')var webpack = require('webpack')var assetsPath = path.join(__dirname, '..', 'public', 'assets')var ExtractTextPlugin = require('extract-text-webpack-plugin')var config = &#123; context: path.join(__dirname, '..'), entry: &#123; application: [ 'webpack/hot/dev-server', path.join(__dirname, '/javascripts/application.js') ] &#125;, output: &#123; path: assetsPath, filename: '[name]-bundle.js', publicPath: 'http://localhost:8080/assets/' /* publicPath: '/assets/' */ &#125;, resolve: &#123; extensions: ['', '.js', '.coffee', '.json'] &#125;, debug: true, displayErrorDetails: true, outputPathinfo: true, devtool: 'cheap-module-eval-source-map', module: &#123; loaders: [ &#123; test: require.resolve('jquery'), loader: 'expose?jQuery' &#125;, &#123; test: require.resolve('jquery'), loader: 'expose?$' &#125;, &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, &#123; test: /\\.coffee$/, loader: 'coffee' &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)\\??.*$/, loader: 'url?limit=8192&amp;name=[name].[ext]' &#125;, &#123; test: /\\.(jpe?g|png|gif|svg)\\??.*$/, loader: 'url?limit=8192&amp;name=[name].[ext]' &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract('style', 'css') &#125;, &#123; test: /\\.scss$/, loader: ExtractTextPlugin.extract('style', 'css!sass') &#125; ] &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;), new ExtractTextPlugin('[name]-bundle.css', &#123; allChunks: true &#125;) ]&#125;module.exports = config 增加 npm scripts 1\"dev\": \"webpack-dev-server --config=client/devserver.config.js --inline --hot --no-info\" 更新 app/helpers/application.rb 因為目前有兩種開發模式，所以我們透過環境變數 HRM=true 來區分支不支援 HRM 模式。這邊遭遇的問題就單純是路徑不一樣，您絕對可自行調整優化，而這篇文章旨在記錄這個流程與概念。 123456789101112131415161718192021222324252627282930313233343536373839def client_javascript_include_tag(name) filename = \"#&#123;name&#125;-bundle.js\" asset_url = Rails.application.config.asset_host src = \"#&#123;asset_url&#125;/assets/#&#123;filename&#125;\" if Rails.env.development? if ENV[\"HRM\"] src = \"http://localhost:8080/assets/#&#123;filename&#125;\" else src = src end elsif Rails.configuration.webpack[:manifest] asset_name = Rails.configuration.webpack[:manifest][\"#&#123;name&#125;.js\"] if asset_name src = \"#&#123;asset_url&#125;/assets/#&#123;asset_name&#125;\" end end \"&lt;script src=\\\"#&#123;src&#125;\\\"&gt;&lt;/script&gt;\".html_safeenddef client_stylesheet_link_tag(name) filename = \"#&#123;name&#125;-bundle.css\" asset_url = Rails.application.config.asset_host src = \"#&#123;asset_url&#125;/assets/#&#123;filename&#125;\" if Rails.env.development? if ENV[\"HRM\"] src = \"http://localhost:8080/assets/#&#123;filename&#125;\" else src = src end elsif Rails.configuration.webpack[:manifest] asset_name = Rails.configuration.webpack[:manifest][\"#&#123;name&#125;.css\"] if asset_name src = \"#&#123;asset_url&#125;/assets/#&#123;asset_name&#125;\" end end \"&lt;link rel=\\\"stylesheet\\\" href=\\\"#&#123;src&#125;\\\"&gt;\".html_safeend Procfile.devserver 12web: bundle exec rails server -p 3000webpack: npm run dev 使用指令1234567# 平常開發模式$ foreman s -f Procfile.dev# 支援 Hot Reload$ HRM=true foreman start -f Procfile.devserver# Ctrl + C 中止 漸進式的 Vue.js 是 MVC 框架的好朋友在 Javascript 當道的今天我想您很容易找到很多關於 SPA 的主流作法。但這篇文章要說明的是把 JS 當作配角的作法。 首先我們需要更新設定檔，使其支援主角 Vue.js v2 1$ npm i vue-loader vue-hot-reload-api -D webpack 所有的 config loader 的部分補上： 1234&#123; test: /\\.vue$/, loader: 'vue'&#125; 另外 resolve 的部分，因為我們需要 standalone 版本的功能所以需要下面設定： 123456789resolve: &#123; extensions: ['', '.js', '.coffee', '.json'], /** * Vue v2.x 之後 NPM Package 預設只會匯出 runtime-only 版本，若要使用 standalone 功能則需下列設定 */ alias: &#123; vue: 'vue/dist/vue.js' &#125;&#125; 首先新增元件 12$ mkdir client/javascripts/components$ touch client/javascripts/components/Car.vue Car.vue 範例程式如下 1234567891011121314151617181920212223242526272829&lt;script&gt;export default &#123; data () &#123; return &#123; brand: 'BMW 3 Series', mileage: 0 &#125; &#125;, mounted () &#123; this.handle = setInterval(() =&gt; &#123; this.mileage++ &#125;, 1000) &#125;, destroyed () &#123; clearInterval(this.handle) &#125;&#125;&lt;/script&gt;&lt;style lang=\"sass\" scoped&gt;$pink: pink;.brand &#123; color: $pink; font-size: 1.4em;&#125;&lt;/style&gt; 更新 application.js 12345678910111213141516import styles from '../stylesheets/home.scss'import Home from './home'import Vue from 'vue'import Car from './components/Car.vue'document.addEventListener('DOMContentLoaded', function () &#123; new Vue(&#123; el: '#app', data: &#123; message: 'Hello, Rails with Vue.js' &#125;, components: &#123; car: Car &#125; &#125;)&#125;) app/views/pages/index.html.erb 123456789&lt;div id=\"app\" v-cloak&gt; &lt;h1 class=\"home-banner\"&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;car inline-template&gt; &lt;div&gt; I am &lt;span class=\"brand\"&gt;&#123;&#123; brand &#125;&#125;&lt;/span&gt;! I runned &#123;&#123; mileage &#125;&#125;. The important thing is the variable from controller#action wheel is &lt;%= @wheel %&gt; &lt;/div&gt; &lt;/car&gt;&lt;/div&gt; 如果您曾使用過 Vue.js 可能會覺得這樣好奇怪，為什麼 component 裡面沒有 &lt;template&gt; 。 主要因為 Vue 有支援 inline-template 這種作法，這讓我們還可以延續使用從 controller action 來的資料，像是您想繼續使用 Rails 的 i18n 機制。 當然有人可能會說 template 抽到 views 那怎麼重複使用元件，使用 Rails 的 partial 就好了。 重點是這裡不是試圖提出一種萬靈丹，而是提供另一種思路，該怎麼樣使用取決於您的需求。 另外您也可以繼續使用 slim 12345div id=&quot;app&quot; v-cloak=&quot;&quot; car inline-template=&quot;&quot; div | &#123;&#123; message &#125;&#125; = @wheel 部署至 Heroku很高興您能看到這一步，這個過程其實挺累人的。最後當我們完成這一系列的修改，我們還是希望能夠部署到一些方便的服務上，這邊就舉 Heroku 來示範。 第一步我們需要先在 package.json 補上一些設定，好讓 Heroku 在安裝完 Node 環境之後可以幫我們執行 webpack 1234\"scripts\": &#123; ..., \"heroku-postbuild\": \"npm run build\"&#125; 部署 123456789$ heroku login$ heroku create --app [your_app_name]$ heroku buildpacks:clear$ heroku buildpacks:set heroku/nodejs$ heroku buildpacks:add heroku/ruby --index 2# 安裝 package.json devDependencies 的部分$ heroku config:set NPM_CONFIG_PRODUCTION=false$ git push heroku master 整體來說如果您有這些前端複雜的需求，使用 webpack 可能暫時是不錯的方式。當然如果您有更優秀的作法也歡迎您給小弟一些建議。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"//andyyou.github.io/tags/nodejs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Heroku 運行類別、 Procfile、常用指令筆記","slug":"process-types-and-profile","date":"2016-10-31T10:23:18.000Z","updated":"2016-10-31T10:31:11.000Z","comments":true,"path":"2016/10/31/process-types-and-profile/","link":"","permalink":"//andyyou.github.io/2016/10/31/process-types-and-profile/","excerpt":"Procfile 是一種定義指令是否可以在 Heroku dynos（一種輕量化的容器，可以執行特定用戶設定的指令）上執行的機制。它遵循著 Unix 的程序模型（process model）。這裡為了簡化概念，我們可以說 dyno 就是執行指令的一個個體。舉例來說一個 web dyno 就意味著執行一個 web server 的程式。希望這樣的說明可以理解這些特殊的名詞概念。","text":"Procfile 是一種定義指令是否可以在 Heroku dynos（一種輕量化的容器，可以執行特定用戶設定的指令）上執行的機制。它遵循著 Unix 的程序模型（process model）。這裡為了簡化概念，我們可以說 dyno 就是執行指令的一個個體。舉例來說一個 web dyno 就意味著執行一個 web server 的程式。希望這樣的說明可以理解這些特殊的名詞概念。 您可以使用 Procfile 來宣告多種程序的類型（執行的程式種類），更簡單的來說一個執行中的程式就稱為一個程序（process）。例如一個標準的 Rails 程式至少需要兩種程序類型一個是 rack 相容的網站服務程序（Webrick, Unicorn）和 worker 程序（Delayed Job, Resque）。套用上面白話的說法就是一個執行中的伺服器服務程式，和一個排程的執行程式。 Profile 命名與配置一個 Procfile 檔案名稱就是 Procfile，不應該是其他名稱也不需要副檔名。舉例來說 Procfile.txt 就是錯誤的，如果是 txt 檔案就應該只是一個文字檔。 再者這個檔案應該被存放在專案的根目錄底下，如果放到其他目錄則不產生任何作用。 程序類型（process types）一個 Procfile 可包含多個程序（process）的宣告，且每一行可以定義一個 process type 和指令。我們稱為程序類型（process type）其實就是一指定某一種 dyno 個體，隨後當這個 dyno 啟動後就會執行後面的指令。 好難懂！沒關係，舉例來說假設我們宣告了一個 web process type，意思就是靠設定後面的指令啟動該 dyno。這表示我們透過指令啟動一個 web server。直接看一下程式碼您比較清楚： 一個 Rails 的 process type 在 Procfile 中會如下設定 1web: bundle exec rails server -p $PORT 而一個 Clojure 程式的 web process type 大概會長得像下面這個： 1web: lein run -m demo.web $PORT 使用 Maven 產生的批次檔執行 Tomcat Java 的應用程式伺服器： 1web: sh target/bin/webapp 對於許多應用程式來說，這些預設的設定就足夠了。不過某些複雜並且帶有的特定執行環境需求的程式，您也許會需要自己設定相關的 process type。舉例來說，Rails 應用程式也提供額外的 process type 1worker: bundle exec rake jobs:work 定義程序類型（process type）程序類型是透過 Procfile 這個檔案來定義的，並且此檔需要放在專案的跟目錄下，而其中每一行定義一個 process type。其格式如下： 1&lt;process type&gt;: &lt;command&gt; process type - 英數字串，定義該程序類型例如：web, worker, urgentworker, clock 等。 command - 用來啟動該程序的指令，例如：rake jobs:work 其中 web process type 較為特殊，只有這種類型可以接收 Heroku 路由送來的 HTTP 傳輸資訊，其他類型可以隨意命名。 另外最一開始提到 dyno 與 process type 其實這兩者之間的關係： process type 是原型類似於 class 的概念，而 dyno 則是實際初始化後的執行個體。 本地端開發（Heroku Local）當我們在本地端開發和除錯的時候讓開發環境盡可能的與遠端環境相同是很重要的，這可以協助我們在部署之前找到問題。這時我們可以使用 Heroku Local 指令，在本地端模擬支援 Procfile 的機制。 這個時候只要先配置 Procfile 和 .env 環境並數的檔案並執行 heroku local 並可在開啟本地端模式。 Heroku Local 是一系列指令工具協助我們執行支援 Procfile 的應用程式。預設就會跟著 Heroku CLI 一起被安裝。同時它會從 .env 檔案讀取環境變數，該指令集使用 node-foreman 來完成這個任務。 啟動1234567$ heroku local$ heroku local:start # 上面是縮寫$ heroku local web # 啟動指定特定 process type，Ctrl + C 關閉$ heroku local -f Procfile.test # 指定其他 Procfile$ heroku local -e .env.test # 指定其他環境變數檔案$ heroku local -p 7000 # 指定 port，預設使用 5000 port$ heroku local -r # 當程序死掉時自動重啟 .env 的設定格式 12S3_KEY=mykeyS3_SECRET=mysecret 注意 .env 應該要加到 .gitignore 複製 Heroku config 環境變數到 .env1$ heroku config:get CONFIG-VAR-NAME -s &gt;&gt; .env 部署到 HerokuProcfile 並不是部署應用程式必須的東西，Heroku 會自動偵測使用的程式語言然後替它們建立對應的 web 程序類型。當然這邊推薦替您的程式建立一個明確的 Procfile。 另外，使用 heroku ps 可以提供我們明確正在執行的 dyno 數量與其狀態資訊。 123heroku ps=== web (Free): bin/rails server -p $PORT -e $RAILS_ENV (1)web.1: idle 2016/10/31 12:32:49 +0800 (~ 4h ago) heroku logs 可以彙整顯示關於所有 dyno 的 log。 操作（擴展） process typeHeroku 正常情況下會自動執行一個 web dyno ，並且其他的 process type 預設並不會自動執行。例如我們要啟動一個 worker 我們就需要自己執行（注意：Procfile 沒有註明的情況下） 1$ heroku ps:scale worker=1 當然在隨著服務成長我們可能會需要增加 dyno 的規格 1234567$ heroku ps:resize worker=standard-2x# web=2 意味著水平擴展增加為 2 個叢集節點，standard-2x 為垂直擴展增加單節點的效能$ heroku ps:scale web=2:standard-2x# 單純水平擴展$ heroku ps:scale web=4 worker=2 使用 ps 可以確認看看 process type 是否運行。 123456heroku ps=== web: `bundle exec rails server -p $PORT`web.1: up for 2m=== worker: `env QUEUE=* bundle exec rake resque:work`worker.1: up for 5s 由於預設 heroku logs 會把所有 process type 的日誌訊息都混在一起，有時候我們僅需要針對某一類型查看資訊 1$ heroku logs --ps worker Heroku 指令彙整1234567891011121314151617181920$ heroku login # 登入$ heroku version # 查看版本$ heroku keys:add # 上傳金鑰$ heroku create --app [app_name] # 建立 app$ heroku open # 開啟網址$ heroku rename # 重新命名 app 與對應網址$ heroku ps:scale worker=2 # 啟動 worker dyno$ heroku ps:stop worker # 停止所有 worker dynos$ heroku ps:stop worker.2 # 停止指定的 worker dyno$ heroku ps:restart # 重啟所有 dynos$ heroku dyno:type web=3 # 設定指定 dyno 規格$ heroku dyno:type standard-1x # 全部服務都設定為 standard-1x$ heroku ps # 查看運行狀態$ heroku logs --ps worker # 針對特定 dyno 列出 log$ heroku pg:reset DATABASE # 清空資料庫# Rails v5.x$ heroku run rails console # 運行在遠端主機的 rails console$ heroku run rails db:migrate$ heroku run rails assets:precompile 資源 官方 dynos 管理教學文件","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"heroku","slug":"heroku","permalink":"//andyyou.github.io/tags/heroku/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"[譯] Yarn - Javascript 新一代套件管理","slug":"new-package-manager-javascript-yarn","date":"2016-10-12T01:08:12.000Z","updated":"2016-10-13T05:26:48.000Z","comments":true,"path":"2016/10/12/new-package-manager-javascript-yarn/","link":"","permalink":"//andyyou.github.io/2016/10/12/new-package-manager-javascript-yarn/","excerpt":"本文轉譯並補充自 - Yarn: A new package manager for JavaScript。 在 Javascript 社群中，開發者們分享成千上萬的原始碼讓我們可以省去重造輪子的時間，不用重新打造函式庫，框架，元件等。而每段原始碼都有可能相依於其他原始碼片段，這些相依的程式碼通常會透過套件管理（package manager）來管理。其中在 Javascript 裡，最熱門的就屬 npm ，在上面有 5 百萬個開發者，套件庫提供了超過 300,000 模組，更驚人的是每個月有超過 5 億次的下載量。","text":"本文轉譯並補充自 - Yarn: A new package manager for JavaScript。 在 Javascript 社群中，開發者們分享成千上萬的原始碼讓我們可以省去重造輪子的時間，不用重新打造函式庫，框架，元件等。而每段原始碼都有可能相依於其他原始碼片段，這些相依的程式碼通常會透過套件管理（package manager）來管理。其中在 Javascript 裡，最熱門的就屬 npm ，在上面有 5 百萬個開發者，套件庫提供了超過 300,000 模組，更驚人的是每個月有超過 5 億次的下載量。 Facebook 的團隊使用 npm 客戶端工具已經好幾年了，隨著原始碼大幅的成長，我們開始遭遇到一些問題包含了一致性，安全性，效能方面。在嘗試解決遇到的每一個問題之後，我們開始創造一套新的、更可靠的解決方案來協助我們管理相依性的問題。 這東西叫做 Yarn - 一個快速，可靠，更安全取代 npm 客戶端的工具。 我們很開心的發佈釋出 Yarn 為開放原始碼專案，並和 Exponent, Google, Tilde 協作。使用 Yarn ，開發者仍然存取 npm 套件庫 （npm registry），但可以更快速的安裝和管理套件，保持套件的一致性，可靠的離線環境的安全性。Yarn 讓開發者在使用這些分享的開源碼時可以自信的更新，替換，因此開發者們可以專注在他們的任務 - 開發產品和功能。 npm registry 收錄開發者提供模組的檔案庫與其對應資訊列表，翻譯為註冊表，但譯者認為套件庫較能表達其意義。 Facebook 管理 Javascript 模組的演化在使用套件管理之前，常見的狀況就是 Javascript 開發者直接透過 CDN 存取相依的片段原始碼。第一版的 npm 在 Nodejs 出現之後很快的就被開發出來，很快的它就成為世界上最熱門的套件管理工具。創造了數以千計的新開源專案以及比以往更多的開發者分享他們的成果。 Facebook 的許多專案像是 React，也相依於 npm 上面的程式碼。然而當我們內部成員增加的時候，當不同的成員與機器要安裝這些相依模組就開始面臨到一致性的問題，大量的時間花在處理安裝相依模組。同時由於 npm 會自動執行一些相依的程式碼而伴隨著安全性的議題。於是我們嘗試開發一個解決方案去處理這些問題。 嘗試擴展 npm 客戶端工具（npm client）起初，跟著官方的最佳實踐，我們只檢查 package.json 然後要求開發者手動執行 npm install。這對開發者來說運作還算良好，不過卻在我們持續整合環境（continuous integration environments）中出現問題，因為該環境處於沙箱模式，並且基於安全性的因素不與外部網路連接。 接著我們的解決方案則是檢查所有的 node_modules 然後存到檔案庫裡套件庫（registry）。雖然它能運作，但同時讓一些簡單的操作變得非常困難。舉例來說更新次版號的 babel 會產生高達 800,000 行的 commit 導致完整下載，執行 lint 規則檢查像是不符合規範的 utf8 字節序列，windows 行結尾，非 png 壓縮圖片，等等等這些任務變得很難完成。合併 node_modules 的修改很可能就耗掉開發者一整天。 我們的版本控制團隊也指出那些我們 check-in 的 node_modules 目錄包含了太大量的 metadata。例如：React Native 的 package.json 現在就有 68 個相依的模組，然後在執行 npm install 之後 node_modules 目錄包含了 121,358 個檔案。 我們做了最後的嘗試 - 補強 npm client，使其適用於 Facebook 的工程師。協助處理那些我們需要安裝的大量程式碼。我們決定 zip 打包整個 node_modules 目錄，然後上傳到內部的 CDN，之後開發者和持續整合環境都可以下載一樣的檔案。這讓我們可以從版本控制中移除數以千計的檔案，不過為了達到這個功能開發者提取和建置時需要內部的存取權限。 另外，我們在處理問題的時候也會需要使用 shrinkwrap 的功能，這讓我們可以鎖定特定相依套件的版本。預設 shrinkwrap 並不會產出，因此如果工程師忘記下指令的話那麼版本又會不一致，所以我們寫了一個工具用來驗證 shrinkwrap 的檔案內容是否符合 node_modules。 這些檔案是超大的 JSON blob 並且 keys 沒有排序，因此要修改它們勢必會產生大量的輸出，然後難以審核 commit。為了解決這個問題我們需要加入額外的 script 來排序它們。 最後，使用某些版本的 npm 更新單一的相依套件可能會連帶更新一些不相關的檔案。這將導致每一次更新比預期的更大，而且必須將其納入整個提交 node_modules 或更新到 CDN 的流程，這不是開發者樂於見到的狀況。 開發新的客戶端工具（client）比起持續補強 npm 客戶端工具，我們選擇嘗試更全面的看待這些問題。假如我們開發一個全新的客戶端工具能夠完全解決我們曾遭遇過的這些問題呢？倫敦辦公室的 Sebastian McKenzie 開始嘗試挑戰這個點子，這點子的潛力讓我們很興奮。 一開始，我們開始詢問業界的開發者們，發現他們都面臨一系列類似的問題，嘗試使用類似的解決方案，一次解決一個遭遇的問題。很明顯的社群正面臨通過合作來解決這一系列的問題，而我們可以開發出一個方案適用於任何人。得到 Exponent, Google, Tilde 工程師的協助，我們開發出了 Yarn 並在各個主流的 JS 框架中測試與驗證其效能，還包括了 Facebook 以外開發團隊的使用情境。今天(2016-10-11)我們很開心與社群分享這個成果。 Yarn 介紹Yarn 是一個新的套件管理工具，主要用來取代既有的工作流程中 npm client 或其他套件管理工具的部分（安裝、更新、移除套件等的指令集），同時兼容於現有的 npm registry。大部分的功能與操作與既有的流程相同並且更快速，安全，可靠。 任何套件管理工具的主要功能是安裝模組套件 - 一個特定用途的片段程式碼 – 從全球通用的套件庫（registry）中安裝到開發者本地的環境中。每一個套件可能會相依於其他套件。一個典型的專案可能具備數十，數百甚至上千個相依的模組。 這些相依的模組都有版號並且基於語意化版本規範（semver）安裝或更新。語意化版本規範了版號的意義與相關符號的規則，這些規則可以讓我們知道該版本是否相容於上個版本，是屬於加入新功能，或者只是修復 Bug，然後基於這些規則來確認是否能更新或該更新到什麼版號。 然而語意化版本規範（semver）需要仰賴套件開發者不犯任何錯誤 - 如果沒有鎖定相依套件的版本，新的 Bug 或錯誤的修改極有可能就被安裝了。 架構在 Node 的生態圈裡，相依的模組會被放在專案下的 node_modules 目錄。然而隨著合併重複模組的狀況，這個檔案結構可能不同於真實的目錄結構 譯者補充：npm 顯示的相依階層跟實際目錄結構不同。 npm 客戶端工具安裝相依模組到 node_modules 目錄並不會依據模組結構（不確定性）。意味著它只會依序安裝模組，而 node_modules 目錄中的結構每一個人可能是不一樣的。這些差異可能最造成『我可以跑啊』的狀況，通常需要很長的時間去找問題點。 Yarn 透過 lockfiles（yarn.lock） 鎖定機制和一套安裝邏輯解決了這些關於版本和不確定性的問題使其具備可靠性與確定性。這些 lockfiles 會鎖定安裝的相依模組為特定版本，確保安裝在每台機器上的 node_modules 結果是一致的。lockfile 使用精準的格式撰寫與排序的鍵 （keys）來確保修改動作最小化，同時在審核的時候比較單純。 整個安裝流程拆解為下面三個步驟： 辨識：Yarn 透過發送請求到套件庫（registry）開始解析相依的套件模組，然後層層遞迴的檢查每一個模組相依的東西。 擷取：下一步，Yarn 檢查全域快取的目錄（global cache directory）看看是否有需要的套件已經被下載了。如果沒有，Yarn 開始下載模組的壓縮包（tarball）並將其存放到全域快取的目錄下，所以這表示我們是可以離線工作的，同樣的模組不需要下載兩次。您也可以將相依的模組使用壓縮檔的形式加入版控來達到完全離線安裝。 連結：最後，Yarn 從全域快取（global cache）複製所需的檔案到本地的 node_modules 完成整個流程。 因為清楚的分拆這些步驟並確保一致的結果，Yarn 便有能力平行處理每個操作，讓整個安裝流程更快速。在某些 Facebook 專案 ，Yarn 簡化了整個安裝流程，從幾分鐘到只剩幾秒鐘。Yarn 也提供互斥的機制確保多個執行的指令不會互相干擾。 Yarn 會嚴格把關整個安裝流程，協助您掌控安裝流程。套件的檢核資訊會存放在 lockfiles（yarn.lock ）確保每一次安裝的都是一樣的套件模組。 功能除了確保安裝流程更迅速和可靠，Yarn 也支援其他功能讓我們更方便的管理相依套件，簡化工作流程。 與 npm 和 bower 相容，同時也支援不同的套件庫（registry） 嚴格限制安裝套件的 Licenses 和輸出相關訊息 提供 API 協助建置工具取得輸出一些工具的資訊（譯者註：此部分尚未完成，更多資訊參考此 Issue） 精簡有意義且美觀的指令輸出資訊 使用 Yarn 於正式環境在 Facebook 我們已經在正式產品中使用 Yarn，同時其運作非常良好。使得許多專案在管理相依套件上更加方便。我們讓工程師即便在每次的移動中都能夠快速的離線建置，加速整個工作流程。 您可以看到 Yarn 和 npm 安裝 React Native 的時間差距，具體資料您可以查閱這裡。 入門最快速的入手方式就是執行 1234$ npm install -g yarn$ yarn# 又或者參考官方文件：https://yarnpkg.com/en/docs/install yarn 就可以在工作流程中透過相同或相似的指令取代 npm 。 npm install -&gt; yarn 此指令不需任何參數，yarn 會讀取 package.json 然後從 npm registry 擷取套件並安裝到 node_modules。等同時使用 npm install。 npm install --save &lt;name&gt; -&gt; yarn add &lt;name&gt; 我們移除 npm 預設不紀錄模組並把 --save 拆開為參數的行為。執行 yarn add &lt;name&gt; 等於 npm install --save &lt;name&gt; 發展許多人和我們一起建造了 Yarn 來解決常見的問題，我們意識到 Yarn 需要成為一個社群專案讓更多人使用。Yarn 現在已經釋出可以在Github上找到，我們為 Node 社群貢獻最棒的東西就是：使用 Yarn，分享一些點子，撰寫文件，互相支援。我們相信 Yarn 有了一個好的開始，但有了您的幫助它會變得更好。 相關閱讀 取代 npm 的新利器 Yarn 利用 Yarn 安裝 Vue-cli","categories":[],"tags":[],"keywords":[]},{"title":"npm 最佳實作的小技巧","slug":"node-best-practice","date":"2016-10-04T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/10/04/node-best-practice/","link":"","permalink":"//andyyou.github.io/2016/10/04/node-best-practice/","excerpt":"npm 最佳實作npm install 是我們最常在 npm 中用到的指令，但其實它還提供了更多的功能。在這篇文章中我們將會學到 npm 如何在開發過程中協助我們 - 從建立專案到部署應用程式。","text":"npm 最佳實作npm install 是我們最常在 npm 中用到的指令，但其實它還提供了更多的功能。在這篇文章中我們將會學到 npm 如何在開發過程中協助我們 - 從建立專案到部署應用程式。 0 了解您的 npm在進入更深的主題之前，讓我們先來看看一些可以協助我查閱 npm 版本的指令 npm versions要取得 npm 指令的版本我們可以執行下面的指令 1$ npm --version 要取得更詳細的訊息 12345678910111213141516171819$ npm version&#123; npm: '3.10.3', ares: '1.10.1-DEV', http_parser: '2.7.0', icu: '57.1', modules: '48', node: '6.6.0', openssl: '1.0.2h', uv: '1.9.1', v8: '5.1.281.83', zlib: '1.2.8'&#125;$ npm show [library name] version # 顯示某 npm 線上最新版本$ nvm ls # 顯示本地端套件資訊$ nvm ls-remote # 顯示 node 可用版本$ npm ls -g # Locally global npm help跟大多數指令一樣，npm 也具備 help 功能。它會顯示相關指令的使用方式資訊，類似於 Linux 中的 man pages 1234567891011$ npm help testNAME npm-test - Test a packageSYNOPSIS npm test [-- &lt;args&gt;] aliases: t, tstDESCRIPTION This runs a package&apos;s &quot;test&quot; script, if one was provided. To run tests as a condition of installation, set the npat config to true. 1 使用 npm init 建立新專案當我們要開始一個新專案時，npm init 可以透過問答式的方式協助我們建立 package.json 當然如果我們想要全部使用預設值時可以使用 12$ npm init --yes$ npm init -y 有些預設值我們可以事先設定，像是專案作者這類資訊： 12$ npm config set init.author.name [YOUR NAME]$ npm config set init.author.email [YOUR EMAIL] 2 查詢 npm 套件找到正確的套件有時候也是一個挑戰 - 在 npm 上有成千上萬的套件模組供我們挑選。通常我們依據一些經驗又或者根據網路上文章或社群的推薦。另外我們也可以參考 npms.io 這個網站，上面提供了關於品質，解決 Issue 平均時間，是否通過測試，甚至還有該模組是否相依了一些過期的套件等等。 3 查閱 npm 套件相關資訊一旦我們選好了模組，舉例來說我們選了 request 這個套件。接著我們就需要查看相關文件，看看 Issue 是否會太多或有嚴重瑕疵。注意，當您使用了越多的套件就表示越高的風險。對於產品來說我們應該要很清楚相依套件的狀況。 這個時候就可以透過指令直接造訪官網 1$ npm home request 要檢查相關 Issues 或後續的發展計畫可以使用 12$ npm bugs request$ npm repo request # 套件 Git Repo 4 安裝與儲存設定當我們確認好要使用的套件之後，就需要將其安裝到我們的專案 12$ npm install request --save$ npm install request -S 預設 npm 會在版好的部分使用 ^ 意味著下次你使用 npm install 時會安裝該主版號下最新版的版本，也就是主版號不變。當然我們也可以改變設定 12$ npm config set save-prefix='~'$ npm config set save-exact true # 精準版號 詳細版號規則可以參考看懂 npm 語意化版本 5 鎖定相依套件上面提到我們可以指定精準版號，但即使我們採用這種方式，您應該意識到大部分 npm 模組的作者並不會這麼做，因為他們會希望自動更新相依的套件。 這種情形在上線的產品很容易變成問題，可能會造成本地的專案和線上產品使用了不同的版本。為了解決這個問題我們可以使用 npm shrinkwrap，它會產生一個 npm-shrinkwrap.json 檔案，這隻檔案不只會記錄我們專案相依模組的版本，還會連模組相依的版本都準確的記錄下來。如此一來下次使用 npm install 就能確保模組的部分完全一致。 6 檢查過期的相依模組為了找出那些需要更新的模組，npm 內建 npm outdated 指令 12$ npm outdated$ npm up [PACKAGE_NAME] -S # 更新 如果您想自動完成這個任務，您可以使用 Greenkeeper，一旦相依的模組有更新，它就會自動發送 pr 給您。 7 不要在產品中安裝 devDependencies1$ npm i --production 另外一個方式是指定環境變數 1$ NODE_ENV=production npm install 8 保護您的專案與 Tokens在 npm 登入帳號的狀況下，您的 npm token 會被放到 .npmrc。如果您發佈到 Github 的專案允許一些 . 開頭的隱藏擋格式那麼請注意關於 .npmrc 中的敏感的資訊不要一起發佈出去。 除了上述這一點，也要注意其他原始碼的部分是否包含一些敏感資訊。預設來說 npm 會遵循 .gitignore 的規則過濾掉一些檔案不發佈。然而當我們加入 .npmignore 時，就會以 .npmignore 為主，注意到兩隻檔案並不會彙整在一起。 9 開發模組當我們在本地端開發模組的時候，我們通常在發布之前會需要測試安裝它們，這時就會使用到 npm link。那麼這個 npm link 會做些什麼呢？它會建立一個軟連結，接著我們就可以在測試專案中使用 npm link package-name 12345# 建立測試模組連結/projects/request $ npm link# 安裝測試模組/projects/test-project $ npm link request 資源參考 nodejs at scale - npm best practices","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"//andyyou.github.io/tags/nodejs/"},{"name":"package manager","slug":"package-manager","permalink":"//andyyou.github.io/tags/package-manager/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Vue + webpack 起手式","slug":"webpack-notes","date":"2016-10-04T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/10/04/webpack-notes/","link":"","permalink":"//andyyou.github.io/2016/10/04/webpack-notes/","excerpt":"介紹前端的世界變化之快速，從 2010 開始小弟經歷了 jQuery, Backbone, Angular, 到 React。這一路走來雖然學習到了許多高明開發者融合於框架或函式庫中的智慧，卻也因為不斷快速變化感到疲憊。時至 2016 小弟認為在實務與理想之間取得一個完美平衡的前端框架大概就屬 vue.js 了。 當然這前端世界裡並沒有萬能藥可以完美的處理所有問題，不過 vue.js 的精美，不只容易與傳統 MVC 框架(Rails, ASP.NET MVC)等結合，當要使用最新的設計模式如 Flux, redux 等也都是沒問題的，再加上易學與一些你肯定能感受到作者從實戰淬煉出來的特性。因此在 2016 我也決定轉戰 vue.js。","text":"介紹前端的世界變化之快速，從 2010 開始小弟經歷了 jQuery, Backbone, Angular, 到 React。這一路走來雖然學習到了許多高明開發者融合於框架或函式庫中的智慧，卻也因為不斷快速變化感到疲憊。時至 2016 小弟認為在實務與理想之間取得一個完美平衡的前端框架大概就屬 vue.js 了。 當然這前端世界裡並沒有萬能藥可以完美的處理所有問題，不過 vue.js 的精美，不只容易與傳統 MVC 框架(Rails, ASP.NET MVC)等結合，當要使用最新的設計模式如 Flux, redux 等也都是沒問題的，再加上易學與一些你肯定能感受到作者從實戰淬煉出來的特性。因此在 2016 我也決定轉戰 vue.js。 隨著 Javascript 社群快速的演進，很可怕一個問題是 - 專案的環境設定，關於那些 tooling 這不只是 React 的問題，當你想使用 ES2015 的新語法，方便的持續整合與測試，匯入匯出模組時，我們就需要設定這些專案工具。 雖然 vue 本身有提供指令介面 vue-cli 讓我們快速建立專案，但對這些相關技術和設定有些瞭解肯定能幫助你執行更多客製的行為。 從頭自己一點一點設定有一些好處: 每個專案都有不同的需求，您可以根據自身的需求來設定 我們也提到 Javascript(nodejs) 的世界變得很快，如果有局部的套件壞了那我們也比較清楚該怎麼處理 直接使用別人的 start-kit 也許會多裝了一堆你不需要的東西 這篇文章將會透過實作介紹最基本的概念，使用 webpack 設定一個基本的 vue 專案 Part 1 基本目錄架構1. 建立專案與 package.json1234$ mkdir [project_name]$ cd [project_name]$ npm init -y$ npm install vue -S 我們先把需要的程式與目錄結構準備好，需求是使用 Vue + ES2015 來開發。第一步在根目錄建立一個 index.html 下面是一個簡單的 vue 範例 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Vue.js v2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;script src=\"dist/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意到兩件事 我們使用 dist/build.js 這個檔案在編譯之前是不存在的 這個語法是 vue.js 處理的 建立 src 目錄與 src/main.js 檔案，這邊您可以隨您自己的偏好組織專案架構 12345678import Vue from &apos;vue&apos;new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &quot;Hello Vue&quot; &#125;&#125;) 在這一步我們已經完成一個簡單的 Vue 專案，但是關於建置編譯的設定我們還未完成。 123Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.關於 v2 之後值得注意的地方，便是我們不能直接將元件掛載到 html 或 body 上。 Part 2 webapck 建置設定1. 安裝 webpack, webpack-dev-server 與相關 loaders 為了專注在基本的說明，本次更新已將一些不屬於基本功能的模組移除。 12# 2016-10-04 更新$ npm i webpack webpack-dev-server webpack-merge css-loader style-loader file-loader url-loader babel-loader babel-core babel-plugin-transform-runtime babel-preset-es2015 vue-loader vue-hot-reload-api -D 123456789101112131415161718\"dependencies\": &#123; \"vue\": \"^2.0.1\"&#125;,\"devDependencies\": &#123; \"babel-core\": \"^6.17.0\", // babel 核心程式 \"babel-loader\": \"^6.2.5\", // webpack 使用的 babel 編譯器 \"babel-plugin-transform-runtime\": \"^6.15.0\", // 預設 babel 會在每一隻編譯檔案注入 polyfill 的程式碼，為了避免重複而將這部分抽出去。詳細說明：http://babeljs.io/docs/plugins/transform-runtime/ \"babel-preset-es2015\": \"^6.16.0\", // 支援 ES2015 語法 \"css-loader\": \"^0.25.0\", // webpack 使用於處理 css \"file-loader\": \"^0.9.0\", // webpack 使用於處理檔案 \"style-loader\": \"^0.13.1\", // webpack 將 css 整合進元件中 \"url-loader\": \"^0.5.7\", // 編譯匯入檔案類型的資源，把檔案轉成 base64 \"vue-hot-reload-api\": \"^2.0.6\", // 支援 Hot Reload \"vue-loader\": \"^9.5.1\", // 使用 Vue Component Spec \"webpack\": \"^1.13.2\", \"webpack-dev-server\": \"^1.16.1\", // webpack 開發伺服器 \"webpack-merge\": \"^0.14.1\" // 合併 webpack 設定參數&#125; 2. 裝完 loaders 後，撰寫設定 webpack.config.js根目錄下建立與撰寫 webpack.config.js 1234567891011121314151617181920212223242526272829var path = require('path')var config = &#123; entry: path.join(__dirname, 'src', 'main'), output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js', publicPath: '/dist/' &#125;, module: &#123; loaders: [ &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125; ] &#125;, resolve: &#123; extensions: ['', '.js', '.vue'], /** * Vue v2.x 之後 NPM Package 預設只會匯出 runtime-only 版本，若要使用 standalone 功能則需下列設定 */ alias: &#123; vue: 'vue/dist/vue.js' &#125; &#125;&#125;module.exports = config Failed to mount component: template or render function not defined. (found in root instance) 123若您看到上面錯誤訊息，這是由於 Vue 2 之後分成 standalone 完整版與 runtime-only 版。差異在於完整版包含了編譯器，支援 template 以及使用了瀏覽器的 API。而 NPM 模組預設只會匯出 runtime-only ，若要加入 compiler 和 template 支援則需增加 webpack 的設定。 3. 設定 babel 的部分根目錄建立 .babelrc 簡化 webpack.config.js，這是因為 babel 6 之後把功能拆散了，要用就要裝。同時也可以用 .babelrc 來設定，如果不使用這個檔案我們就需要在 webapck.config.js 設定。 .babelrc 1234&#123; \"presets\": [\"es2015\"], \"plugins\": [\"transform-runtime\"]&#125; 另外 package.json 和環境變數也能夠設定，不過為了單純起見我們選擇建立 .babelrc 。當然您也可以選擇設定在 package.json 中。 package.json 123456789101112&#123; \"name\": \"YOUR PROJECT NAME\", ..., \"babel\": &#123; \"presets\": [ \"es2015\" ], \"plugins\": [ \"transform-runtime\" ] &#125;&#125; 上面我們已經完成基本的設定，雖然我們一口氣安裝了很多 loaders 但相關設定我們只先設定了 babel 的部份。到了這一步我們的專案架構已經可以被編譯執行了。 1234# 如果在這一步您想先執行編譯看看可以安裝全域的 webpack$ npm i webpack -g$ webpack$ open index.html # 編譯後檢視內容 編譯之後點擊 index.html 即可以運行。眼尖的讀者可能會好奇，那我們剛剛有裝 vue-loader 那是在幹嘛的？ Part 3 使用 vue-loader 與 .vuevue-loader 的用途是提供一種更方便的組織方式讓我們把元件即一個 component 中需要的 js 行為, css 樣式, template 樣板放在一個 .vue 的檔案中。 1. 修改 view首先讓我們先修改 index.html ，加入 &lt;app&gt; 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Vue.js v2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;app&gt;&lt;/app&gt; &lt;/div&gt; &lt;script src=\"dist/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 匯入元件接著我們在 main.js 把元件 app.vue 加入 components，在這邊我們是反向的推導回去，從想怎麼使用接著反著建立程式檔案。 1234567import Vue from 'vue'import App from './app.vue'new Vue(&#123; el: '#app', components: &#123; App &#125;&#125;) 3. 新增元件最後我們新增一個 app.vue 檔案 123456789101112131415161718192021222324&lt;template lang=\"html\"&gt; &lt;div&gt; &lt;div class=\"message\"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; message: 'Helo, Vue.js 2.0' &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"css\"&gt;.message &#123; color: pink; font-size: 1.4em;&#125;&lt;/style&gt; 4. 更新 webpack.config.js這個時候如果直接執行 webpack 編譯會產生錯誤，因為我們還沒設定 webpack.config.js 處理 .vue 檔案的部分 12345678910111213141516171819202122232425262728293031323334353637var path = require('path')var config = &#123; entry: [ 'webpack/hot/dev-server', path.join(__dirname, 'src', 'main') ], output: &#123; publicPath: '/dist/', path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, &#123; test: /\\.vue$/, loader: 'vue' &#125; ] &#125;, resolve: &#123; /** * Vue v2.x 之後 NPM Package 預設只會匯出 runtime-only 版本 */ alias: &#123; vue: 'vue/dist/vue.js' &#125;, extensions: ['', '.js', '.vue'] &#125;&#125;module.exports = config 再次執行 webpack 編譯，我們的 app.vue 可以正常運作了。 Part 4 HMR / Hot Reload 如果您有發現修改之後卻沒有改變的問題，請注意關於路徑部分，取得的是編譯後的實體檔案還是 webpack-dev-server 使用記憶體中的內容 Hot Module Replacement 或稱 Hot Reload 是 Javascript 世界中近期很熱門的新技術，簡單的說就是當你在開發時，你一存檔，改寫的部份就即時更新元件到執行環境。大致上流程就是 處於開發 app 階段，撰寫程式碼 打開瀏覽器觀察 app 行為 app 在瀏覽器畫面上運作 當你發現一些 bug 或行為不如您所預期您通常會編輯程式碼，然後重新載入 使用 HRM 時，當你一存檔 webpack 就會偵測那些改變的部分並更新瀏覽器 重點是一些關於狀態的資料並不會被洗掉 要完成這功能，我們會需要 webpack-dev-server 以及套件 vue-hot-reload-api。然後執行。 在這之前，我們需要修改一下 webpack.config.js 加入 webpack/hot/dev-server 123456789101112var webpack = require('webpack')var config = &#123; entry: [ 'webpack/hot/dev-server', path.join(__dirname, 'src', 'main') ], ... plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; 接著，您可以選擇在全域安裝 webpack-dev-server 12$ npm i webpack-dev-server -g$ webpack-dev-server --inline --hot 又或者使用我們早先已安裝在專案中的 webpack-dev-server，一般來說會建議使用專案相依的這個。 需要在 package.json 加上 scripts 123\"scripts\": &#123; \"dev\": \"webpack-dev-server\"&#125; 然後執行： 1$ npm run dev 為了觀察出我們是否有正確的啟用 hot reload 我們修改 app.vue 1234567891011121314151617181920212223242526272829303132333435363738&lt;template lang=\"html\"&gt; &lt;div&gt; &lt;div class=\"message\"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123; count &#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; message: 'Helo, Vue.js 2.0', count: 0 &#125; &#125;, mounted () &#123; this.handle = setInterval(() =&gt; &#123; this.count++ &#125;, 1000) &#125;, destroyed () &#123; clearInterval(this.handle) &#125;&#125;&lt;/script&gt;&lt;style lang=\"css\"&gt;.message &#123; color: pink; font-size: 1.4em;&#125;&lt;/style&gt; 打開 http://localhost:8080 然後異動 app.vue css 與 template 的部分觀察看看變化。至此我們已經跑完一次基本的用法。 文章剩下的部份則是整理一些 webpack 的指令與設定。 webpack 編譯指令1234$ webpack [source] [destination]$ webpack src/v1.js dist/v1.bundle.js$ webpack bar=./src/v2.js \"dist/[name].bundle.js\"# &gt;&gt; output dist/bar.bundle.js 12# 指定設定檔$ webpack --config [webpack.config.js] 注意 require 的 path 分成 函式庫 相對路徑 絕對路徑 函式庫：什麼都不加，單純 library name 相對路徑：./ 開頭 絕對路徑：/ 開頭 資源 webpack 令人困惑的地方 - 英 webpack 令人困惑的地方 - 中 補充關於 Babel 一步一步設定 webpack Demo 快速指令流程 &amp; 程式碼片段123456789101112131415161718192021222324252627282930313233$ npm init -y$ npm i webpack -D# Add webpack.config.js# Add scripts to package.json# Setup webpack-dev-server$ npm i webpack-dev-server -D# 由於 prod &amp; dev 會需要不同的設定因此我們需要至少兩份設定檔# 有許多實作方式如下：# 1. 維護多份設定檔，透過 `--config` 指定不同的檔案# 2. 把設定組織成一份 Library# 3. 在一份檔案中依據 `環境` 或 `指令` 套用不同設定# 使用 webpack-merge，合併設定更方便$ npm i webpack-merge -D$ npm i css-loader style-loader -D$ npm i file-loader url-loader -D# 強大のplugin# npm i npm-install-webpack-plugin -D# 安裝處理 ES2015$ npm i babel-core babel-loader babel-plugin-transform-runtime babel-preset-es2015 -D# 加入 .babelrc# 加入 loader 設定# (Optional)安裝 vue-loader$ npm i vue-loader vue-hot-reload-api -D# 安裝 vue 與所需的模組 1234&#123; &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var path = require('path')var webpack = require('webpack')var merge = require('webpack-merge')var precss = require('precss');var autoprefixer = require('autoprefixer');var T = process.env.npm_lifecycle_eventvar common = &#123; entry: &#123; main: path.join(__dirname, 'src', 'main'), venders: path.join(__dirname, 'src', 'venders') &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, &#123; test: /\\.vue$/, loader: 'vue' &#125;, &#123; test: /\\.css$/, loaders: ['style', 'css', 'postcss'] /* include: path.join(__dirname, 'src') */ &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url', query: &#123; limit: 10000, name: path.posix.join(__dirname, 'public', '[name].[hash:7].[ext]') &#125; &#125; ] &#125;, resolve: &#123; extensions: ['', '.js', '.vue', '.json', '.css'] &#125;, postcss: function () &#123; return [precss, autoprefixer]; &#125;&#125;if (T === 'dev' || !T) &#123; var config = merge(common, &#123; devServer: &#123; historyApiFallback: true, hot: true, inline: true, progress: true, stats: 'errors-only', host: process.env.HOST || '0.0.0.0', port: process.env.PORT &#125;, devtool: 'eval-source-map', plugins: [ new webpack.HotModuleReplacementPlugin() ] &#125;) config.entry.main = ['webpack/hot/dev-server', config.entry.main] module.exports = config&#125;if (T === 'build') &#123; module.exports = merge(common, &#123;&#125;)&#125; 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"//andyyou.github.io/tags/webpack/"},{"name":"vuejs","slug":"vuejs","permalink":"//andyyou.github.io/tags/vuejs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"筆記 Javascript 的 constructors, prototypes, new 關鍵字","slug":"js-contrstructors-prototypes-new","date":"2016-09-22T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/09/22/js-contrstructors-prototypes-new/","link":"","permalink":"//andyyou.github.io/2016/09/22/js-contrstructors-prototypes-new/","excerpt":"您是否曾困惑關於 Javascript 中的 new 關鍵字呢？是否曾想理解關於 function 和 constructor 的不同是什麼？還有 prototype 到底是用來幹嘛的？ 這篇文章會試著讓您釐清這些東西。 網路上已經有許多討論關於 Javascript 非典型物件導向(pseudo-classical)的說明 - MDN。您可以閱讀一下釐清這些術語。","text":"您是否曾困惑關於 Javascript 中的 new 關鍵字呢？是否曾想理解關於 function 和 constructor 的不同是什麼？還有 prototype 到底是用來幹嘛的？ 這篇文章會試著讓您釐清這些東西。 網路上已經有許多討論關於 Javascript 非典型物件導向(pseudo-classical)的說明 - MDN。您可以閱讀一下釐清這些術語。 大多數 Javascript 的新進開發者不太想要使用 new 關鍵字，因為這會讓程式碼寫起來像是 Java 並且在使用上造成一點混亂。在這邊我並不想討戰也不會偏袒任何一種方式，我們只是要解釋它是如何運作的。我要說的只是這是個工作，如果在實務上能幫上忙就用吧！ constructor 是什麼？constructor 翻為建構子但為了讓您之後更好理解，這邊會直接使用 constructor。簡單說這和您之前學過的大部分物件導向語言不同，在 Javascript 中任何一個函式(function)都可以被當作 constructor。Javascript 並沒有明顯的區別兩者，也就是說 function 可以被當作 constructor 或者當作一般函式調用。 而 constructor 的用法就是 function 搭配 new 關鍵字： 12345var Vehicle = function Vehicle () &#123;&#125;var vehicle = new Vehicle() 這可能會讓許多慣於使用 C++ 或 Java 的人感到困惑。但其實，在某種程度上你可以把 function 看做是 class。 當 constructor 被調用時發生了什麼事？當 new Vehicle() 的時候，Javascript 做了 4 件事情 產生一個新的物件 將這個新物件的 constructor 屬性設為 Vehicle 這個 Function 物件 讓這個物件繼承 Vehicle.prototype (Function 物件) 在這個物件的 context 執行 Vehicle() 用個簡短的範例說明當我們在 Javascript 執行一個 foo() 時，一般來說它等於 window.foo()。這個 window 就是 context。上面的例子可以看成：Vehicle.call(新物件) 再看一次： 1. 產生一個新的物件這一步沒有任何特別的，就只是建立一個新物件 {} 2. 將這個新物件的 constructor 屬性設為 Vehicle 這個 Function 物件這步意味了 2 件事 12vehicle.constructor == Vehicle // truevehicle instanceof Vehicle // true 這個 constructor 並不是一般的屬性，當我們列舉所有屬性時並不會出現。另外，我們可以試著對它設值，不過只是在這個特殊屬性之上再加上一個普通的屬性 123456789vehicle // &#123;&#125;var Beer = function Beer() &#123;&#125;vehicle.constructor = Beervehicle // &#123;constructor: function Beer()&#125;vehicle.constructor == Beer // truevehicle instanceof Beer // falsevehicle instanceof Vehicle // true 可以想成這時有兩個 constructor 一個是我們加上的普通屬性，一個是底層屬性。底層內建的 constructor 我們是無法變更的。它是用來搭配 new 使用的。 3. 讓這個物件繼承 Vehicle.prototype (Function 物件的 prototype)到這一步事情變得有趣了 一個 function 本質上是一個特殊的物件，並且就像其他物件一樣。它也是有屬性的。而這個 Function 物件 預設會自動取得一個叫 prototype 的屬性，是一個空物件。這個物件會經過一些特別的處理。 當我們透過 constructor 的方式建立一個物件時，它會繼承這個 prototype 物件 的所有屬性。 讓我們來看一點程式碼理解一下 123Vehicle.prototype.wheel = 4var v = new Vehicle()v.wheel // 4 這個剛產生的 v 物件會從 Vehicle 的 prototype 中擷取 wheel。 看起來像是把屬性複製過去，但這個繼承的行為不只是單純的複製屬性到新物件上。這個物件代理了 prototype 所有的屬性。也就是說即使在建立之後，Vehicle Function 物件 的 prototype 加了新東西，這個物件還是能夠取得。 12345Vehicle.prototype.wheel = 6Vehicle.prototype.brand = 'BMW'v.wheel // 6v.brand // BMW 重點來了，我們還是可以單獨覆寫 instance 物件實例的屬性，這麼做並不會異動 prototype 的屬性 123v.wheel = 8v.wheel // 8(new Vehicle()).wheel // 6 當然我們也可以有 method 的使用方式。在屬性上的 function 一般稱為方法(method)。 12Vehicle.prototype.go = function go() &#123;return 'run'&#125;vehicle.go() // run 4. 在這個物件的 context 執行 Vehicle()最後，constructor 會自己呼叫自己。這個 function 裡面的 this 會指向我們剛剛建立的物件。 探討 this, context, scope 已經超出本文範圍，可以參考understanding scope and context in- javascript 所以我們可以這麼做 123456var Vehicle = function Vehicle(color) &#123; this.constructor this.color = color&#125;(new Vehicle('blue')).color // blue 備註：上面提到使用 new 關鍵字搭配 constructor 回傳一個新的物件，本質上是對的。但如果這個 constructor 回傳了一個其他物件那麼原本預計建構的物件會被拋棄，只回傳該內容。詳細的說明請參考javascript constructor value 小結這種方式讓我們可以實作類似 Class 的用法 12345678910// Classvar Vehicle = function Vehicle(color) &#123; // Initialization this.color = color&#125;// Instance MethodsVehicle.prototype.go = function () &#123; return 'run'&#125; 子類別這種非典型物件導向得設計，或稱 Prototype-based programming 並沒有標準的方式實作子類別。不過我們可以透過設定一個父類別的實例物件到 prototype 來達成這個功能。 也由於這種設計，所以不會有解構子 destructors 1234567891011var Car = function Car() &#123;&#125;Car.prototype = new Vehicle('blue')Car.prototype.honk = function honk() &#123;return 'BEEEE!'&#125;var car = new Car()car.honk() // 'BEEEE'car.go() // runcar.color // bluecar instanceof Car // true// 稍早我們把 Beer 設到 constructor 會是 falsecar instanceof Vehicle // true 還有一個問題，由於 Vehicle constructor 只有在設定 Car.prototype 時被呼叫一次。我們會在設定時給予 color 參數。於是我們就不能在初始化的階段給不同的物件不同的顏色。但這個問題有些 Javascript 框架已經實作它們的解決方案。 類似於 mixin 的作法有時您並不想使用類別的概念，我們只想要某個物件能夠取得另一個物件的屬性並能夠覆寫。 function 可以協助我們完成這個任務。通常這類 function 會被命名為 create 或 clone 1234567891011121314151617181920function create (parent) &#123; var fn = function () &#123;&#125; fn.prototype = parent return new fn()&#125;var company = &#123;brand: 'Benz'&#125;var car1 = create(company)var car2 = create(company)var car3 = create(company)car3.brand = 'Audi'car1.brand // Benzcar2.brand // Benzcar3.brand // Audicompany.brand = 'Toyota'car1.brand // Toyotacar2.brand // Toyotacar3.brand // Audi 總結關於 Javascript 的 prototype 相較於其他語言有點混亂難理解。即便讓語法看起來像是一般OOP但您還是需要掌握一些技巧並謹慎使用。 function 可當作 class 看待 在 Javascript 中任何一個函式(function)都可以被當作 constructor。Javascript 並沒有明顯的區別兩者，也就是說 function 可以被當作 constructor 或者當作一般函式調用。 class 所建立的 instance 屬性使用 prototype 加入繼承 constructor instance 沒有該屬性時會代理 prototype 的，但覆寫後就為自己個人的屬性 constructor instance 與 Function.prototype 是代理關係，也就是 prototype 異動時，物件的屬性會跟著更新(沒有覆寫的狀況下) 參考資源 javascript constructors prototypes and the new keyword Introduction to Object Oriented JavaScript understanding scope and context in javascrip javascript constructor return value","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Node 筆記","slug":"node-note","date":"2016-09-19T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/09/19/node-note/","link":"","permalink":"//andyyou.github.io/2016/09/19/node-note/","excerpt":"前言這篇文章試著要整理，翻譯Export This: Interface Design Patterns for Node.js Modules這篇非常值得一讀的文章。但因為這篇文章有些時日了，部分範例已經不符合現況。故這是一篇加上小弟收集彙整而成的更新翻譯。","text":"前言這篇文章試著要整理，翻譯Export This: Interface Design Patterns for Node.js Modules這篇非常值得一讀的文章。但因為這篇文章有些時日了，部分範例已經不符合現況。故這是一篇加上小弟收集彙整而成的更新翻譯。 旅程的開始當你在 Node 中載入一個模組，我們到底會取回什麼？當我們撰寫一個模組時我們又有哪些選擇可以用來設計程式的介面？在我第一次學習 Node 的時候，發現在 Node 中有太多的方式處理這個問題，由於 Javascript 本身非常彈性，加上在社群中的開發者們各自都有不同的實作風格，這讓當時的我感到有點挫折。 在原文作者的學習旅程中曾持續的觀察尋找好的方式以應用在其的工作上，在這篇文章中將會分享觀察到的 Node 模組設計方式。大略總結了 7 種設計模式(pattern) 匯出命名空間 Namespace 匯出函式 Function 匯出高階函式 High-Order Function 匯出建構子/構建函式 Constructor 匯出單一實例物件 Singleton 擴展全域物件 Extend Global Object 套用猴子補丁 Monkey Patch require, exports 和 module.exports首先我們需要先聊點基礎的知識 在 Node 官方文件中定義了匯入一個檔案就是匯入一個模組。 In Node.js, files and modules are in one-to-one correspondence. - Node 文件 每個模組內都有一個隱式(implicit)的 module 物件，這個物件身上有一個屬性 exports (即 module.exports)。當我們使用 require() 時它所傳回的，即是這個模組的 module.exports 所指向的東西。每個模組的 module.exports 預設都是一個空物件 {}，而每個模組內帶有一個 exports 捷徑變數，預設指向 module.exports。 在預設情況下，module.exports 是一個物件，而 exports 又指向該物件，所以在預設情況下，以下兩個操作視為等效：123exports.foo = 'hello';// 等同於module.exports.foo = 'hello'; 如果，你重新指定了某東西給 module.exports，當然 module.exports 跟預設物件的關係就因此被打斷，而此時 exports 捷徑變數仍然是指向預設物件的。前面有提到，當我們使用 require() 時，模組是以 module.exports 所指向的東西而揭露給外部，因此模組的介面是由 module.exports 所決定，與 exports 捷徑變數無關。因此，一旦 module.exports 被指定新值後，使用捷徑變數 exports 所掛入預設物件的內容都將無法被揭露，因而可視為無效。 為了讓您更好理解關於 exports 與 module.exports 下面的範例提供了較詳細的說明 1234567891011121314var a = &#123; id: 1 &#125;var b = aconsole.log(a) // &#123;id: 1&#125;console.log(b) // &#123;id: 1&#125;// b 參考指向 a，意味著修改 b 的屬性 a 會跟著變動b.id = 2console.log(a) // &#123;id: 2&#125;console.log(b) // &#123;id: 2&#125;// 但如果將一個全新的物件賦予 b 那麼參考的關係將會中斷b = &#123; id: 3 &#125;console.log(a) // &#123;id: 2&#125;console.log(b) // &#123;id: 3&#125; 另外比較具體的範例 12345678910// 模組預設: module.exports = &#123;&#125;, 而 exports = module.exports, 等同於指向預設的空物件/* person.js */exports.name = function () &#123; console.log('My name is andyyou.')&#125;.../* main.js */var person = require('./person.js')person.name() 12345678910/* person.js */module.exports = 'Hey, andyyou' // module.exports 不再是預設物件exports.name = function () &#123; // 透過 exports 捷徑掛進預設物件的內容, 將無法被揭露 console.log('My name is andyyou')&#125;/* main.js */var person = require('./person.js')// exports 的屬性被忽略了person.name() // TypeError: Object Hey, andyyou has no method 'name' exports 只是指向 module.exports 的參考(Reference) module.exports 初始值為 {} 空物件，於是 exports 也會取得該空物件 require() 回傳的是 module.exports 而不是 exports 所以您可以使用 exports.property_name = something 而不會使用 exports = something 一旦使用 exports = something 參考關係便會停止，也就是 exports 的資料都會被忽略。 本質上我們可以理解為所有模組都隱含實作了下面這行程式碼 (實際上 module 與 exports 是由 node 模組系統傳入給我們的模組的) 1var exports = module.exports = &#123;&#125; 現在我們知道了，當我們要匯出一個 function 時我們得使用 module.exports。如果令捷徑 exports 變數指向該 function，僅僅是捷徑 exports 對 module.exports 的關係被打斷而已，真正揭露的還是 module.exports。 另外，我們在許多專案看到下面的這行程式碼 1exports = module.exports = something 這行程式碼作用就是確保 exports 在 module.exports 被我們覆寫之後，仍可以指向相同的參考。 接著我們就可以透過 module.exports 來定義並匯出一個 function 1234/* function.js */module.exports = function () &#123; return &#123; name: 'andyyou' &#125;&#125; 使用的方式則是 1var func = require('./function') 關於 require 一個很重要的行為就是它會快取(Cache) module.exports 的值，未來每一次 require 被調用時都會回傳相同的值。它會根據匯入檔案的絕對路徑來快取，所以當我們想要模組能夠回傳不同得值時，我們就需要匯出 function，如此一來每次執行函式時就會回傳一個新值。 下面在 Node REPL 中簡易的示範 123456789$ node&gt; f1 = require('/Users/andyyou/Projects/export_this/function')[Function]&gt; f2 = require('./function') // 相同路徑[Function]&gt; f1 === f2true&gt; f1() === f2()false 您可以觀察到 require 回傳了同樣的函式物件實例，但每一次調用函式回傳的物件是不同的。更詳細的介紹可以參考官方文件，值得一讀。 現在，我們可以開始探討介面的設計模式(pattern)了。 匯出命名空間一個簡單且常用的設計模式就是匯出一個包含數個屬性的物件，這些屬性具體的內容主要是函式，但並不限於函式。如此，我們就能夠透過匯入該模組來取得這個命名空間下一系列相關的功能。 當您匯入一個命名空間類型的模組時，我們通常會將模組指定到某一個變數，然後透過它的成員(物件屬性)來存取使用這些功能。甚至我們也可以將這些變數成員直接指定到區域變數。 1234567var fs = require('fs')var readFile = fs.readFilevar ReadStream = fs.ReadStreamreadFile('./file.txt', function (err, data) &#123; console.log('readFile contents: %s', data)&#125;) 這便是fs 核心模組的做法 1var fs = exports 首先用一個新的區域變數 fs，令其為捷徑 exports，因此預設情況下 fs 就指向了 module.exports 身上的預設物件。上面這一行我們可以說，只是將捷徑變數換個名稱成為 fs 如此而已。接下來，我們就可以使用新的捷徑 fs 了，例如: fs.Stats = binding.Stats。 123fs.readFile = function (path, options, callback_) &#123; // ...&#125; 其他東西也是一樣的作法，例如匯出建構子 1234567fs.ReadStream = ReadStreamfunction ReadStream(path, options) &#123; // ...&#125;ReadStream.prototype.open = function () &#123; // ...&#125; 當匯出命名空間時，您可以指定屬性到 exports ，就像 fs 的作法，又或者可以建立一個新的物件指派給 module.exports 12345678910/* exports 作法 */exports.verstion = '1.0'/* 或者 module.exports 作法 */module.exports = &#123; version: '1.0', doYourTasks: function () &#123; // ... &#125;&#125; 一個常見的作法就是透過一個根模組(root)來彙整並匯出其他模組，如此一來只需要一個 require 便可以使用所有的模組。原文作者在Good Eggs工作時，會將資料模型(Model)拆分成個別的模組，並使用匯出建構子的方式匯出(請參考下文介紹)，然後透過一個 index 檔案 來集合該目錄下所有的資料模型並一起匯出，如此一來在 models 命名空間下的所有資料模型都可以使用 123var models = require('./models')var User = models.Uservar Product = models.Product 在 ES2015 和 CoffeeScript 中我們甚至還可以使用解構指派來匯入我們需要的功能 12345/* CoffeeScript */&#123;User, Product&#125; = require './models'/* ES2015 */import &#123;User, Product&#125; from './models' 而剛剛提到的 index.js 大概就如下 12exports.User = require('./User')exports.Person = require('./person') 實際上這樣分開的寫法還有更精簡的寫法，我們可以透過一個小小的函式庫來匯入在同一階層中所有檔案並搭配 CamelCase 的命名規則匯出。於是在我們的 index.js 中看起來就會如下 1module.exports = require('../lib/require_siblings')(__filename) 匯出函式另外一個設計模式是匯出函式當作該模組的介面。常見的作法是匯出一個工廠函式(Factory function)，然後呼叫並回傳一個物件。在使用 Express.js 的時候便是這種作法 123456var express = require('express')var app = express() // 實際上 express() 傳回的 app 是一個 function，在 JS 中函式也是物件app.get('/hello', function (req, res, next) &#123; res.send('Hi there! We are using Express v' + express.version)&#125;) Express 匯出該函式，讓我們可以用來建立一個新的 express 應用程式。在使用這種模式時，通常我們會使用 factory function 搭配參數讓我們可以設定並回傳初始化後的物件。 想要匯出 function，我們就一定要使用 module.exports ，Express 便是這麼做 123456exports = module.exports = createApplication...function createApplication () &#123; ...&#125; 上面指派了 createApplication 函式到 module.exports 然後再指給 exports 確保參考一致。同時 Express 也使用下面這種方式將導出函式當作命名空間的作法使用。 1exports.version = '3.1.1' 這邊要大略解釋一下由於 Javascript 原生並沒有支援命名空間的機制，於是大部分在 JS 中提到的 namespace 指的就是透過物件封裝的方式來達到 namespace 的效果，也就是第一種設計模式。 注意！並沒有任何方式可以阻止我們將匯出的函式作為命名空間物件使用，我們可以用其來引用其他的 function，建構子，物件。 Express 3.3.2 / 2013-07-03 之後已經將 exports.version 移除了 另外在匯出函式的時候最好為其命名，如此一來當出錯的時候我們比較容易從錯誤堆疊資訊中找到問題點。 下面是兩個簡單的例子： 1234/* bomb1.js */module.exports = function () &#123; throw new Error('boom')&#125; 123module.exports = function bomb() &#123; throw new Error('boom')&#125; 123456789101112131415$ node&gt; bomb = require('./bomb1');[Function]&gt; bomb()Error: boom at module.exports (/Users/andyyou/Projects/export_this/bomb1.js:2:9) at repl:1:2 ...&gt; bomb = require('./bomb2');[Function: bomb]&gt; bomb()Error: boom at bomb (/Users/andyyou/Projects/export_this/bomb2.js:2:9) at repl:1:2 ... 匯出函式還有些比較特別的案例，值得用另外的名稱以區分它們的不同。 匯出高階函式一個高階函式或 functor 基本上就是一個函式可以接受一個或多個函式為其輸入或輸出。而這邊我們要談論的後者 - 一個函式回傳函式當我們想要模組能夠根據輸入控制回傳函式的行為時，匯出一個高階函式就是一種非常實用的設計模式。 補充：functor &amp; monad 舉例來說 Connect 就提供了許多可掛載的功能給網頁框架。這裡的 middleware 我們先理解成一個有三個參數 (req, res, next) 的 function。 Express 從 v4.x 版之後不再相依於 connect connect middleware 慣例就是匯出的 function 執行後，要回傳一個 middleware function。在處理 request 的過程中這個回傳的 middleware function 就可以接手使用剛剛提到的三個參數，用來在過程中做一些處理或設定。同時因為閉包的特性這些設定在整個中介軟體的處理流程中都是有效的。 舉例來說，compression 這個 middleware 就可以在處理 responsive 過程中協助壓縮 123456var connect = require('connect')var app = connect()// gzip outgoing responsesvar compression = require('compression')app.use(compression()) 而它的原始碼看起來就如下 123456789module.exports = compression...function compression (options) &#123; ... return function compression (req, res, next) &#123; ... next() &#125;&#125; 於是每一個 request 都會經過 compression middleware 處理，而代入的 options 也因為閉包的關係會被保留下來 這是一種極具彈性的模組作法，也可能在您的開發項目上幫上許多忙。 middleware 在這裡您可以大略想成串連執行一系列的 function，自然其 Function Signature 要一致 匯出建構子在一般物件導向語言中，constructor 建構子指的是協助我們從類別 Class建立一個該類別物件實例的一段程式碼。 123456789// C#class Car &#123; // c# 建構子 // constructor 即 class 中用來初始化物件的 method。 public Car(name) &#123; name = name; &#125;&#125;var car = new Car('BMW'); 由於在 ES2015 之前 Javascript 並不支援類別，某種程度上在 Javascript 之中我們可以把任何一個 function 當作類別，或者說一個 function 可以當作 function 執行或者搭配 new 關鍵字當作 constructor 來使用。如果想知道更詳細的介紹可以閱讀MDN 教學。 欲匯出建構子，我們需要透過構造函式來定義類別，然後透過 new 來建立物件實例。 12345678910function Person (name) &#123; this.name = name&#125;Person.prototype.greet = function () &#123; return 'Hi, I am ' + this.name&#125;var person = new Person('andyyou')console.log(person.greet()) // Hi, I am andyyou 在這種設計模式底下，我們通常會將每個檔案設計成一個類別，然後匯出建構子。這使得我們的專案架構更加清楚。 12var Person = require('./person')var person = new Person() 整個檔案看起來會如下 12345678910/* person.js */function Person(name) &#123; this.name = name&#125;Person.prototype.greet = function () &#123; return 'Hi, I am ' + this.name&#125;exports = module.exports = Person 匯出單一物件實例 Signleton當我們需要所有的模組使用者共享物件的狀態與行為時，就需要匯出單一物件實例。 Mongoose是一個 ODM(Object-Document Mapper)函式庫，讓我們可以使用程式中的 Model 物件去操作 MongoDB。 1234567891011var mongoose = require('mongoose')mongoose.connect('mongodb://localhost/test')var Cat = mongoose.model('Cat', &#123;name: String&#125;)var kitty = new Cat(&#123;name: 'Zildjian'&#125;)kitty.save(function (err) &#123; if (err) throw Error('save failed') console.log('meow')&#125;) 那我們 require 取得的 mongoose 物件是什麼東西呢？事實上 mongoose 模組的內部是這麼處理的 12345function Mongoose() &#123; ...&#125;module.exports = exports = new Mongoose() 因為 require 的快取了 module.exports 的值，於是所有 reqire(&#39;mongoose&#39;) 將會回傳相同的物件實例，之後在整個應用程式之中使用的都會是同一個物件。 Mongoose 使用物件導向的設計模式來封裝，解耦(分離功能之間的相依性)，維護狀態使整體具備可讀性，同時透過匯出一個 Mongoose Class 的物件給使用者，讓我們可以簡單的存取使用。 如果我們有需要，它也可以建立其他的物件實例來作為命名空間使用。實際上 Mongoose 內部提供了存取建構子的方法 1Mongoose.prototype.Mongoose = Mongoose 因此我們可以這麼做 12345var mongoose = require('mongoose')var Mongoose = mongoose.Mongoosevar anotherMongoose = new Mongoose()anotherMongoose.connect('mongodb://localhost/test') 擴展全域物件一個被匯入的模組不只限於單純取得其匯出的資料。它也可以用來修改全域物件或回傳全域物件，自然也能定義新的全域物件。而在這邊的全域物件(Global objects)或稱為標準內建物件像是 Object, Function, Array 指的是在全域能存取到的物件們，而不是當 Javascript 開始執行時所產生代表 global scope 的 global object。 當我們需要擴增或修改全域物件預設行為時就需要使用這種設計模式。當然這樣的方式是有爭議，您必須謹慎使用，特別是在開放原始碼的專案上。 例如：Should.js是一個常被用在單元測試中用來判斷分析 值 是否正確的函式庫。 1234567require('should')var user = &#123; name: 'andyyou'&#125;user.name.should.equal('andyyou') 這樣您是否比較清楚了，should.js 增加了底層的 Object 的功能，加入了一個非列舉型的屬性 should ，讓我們可以用簡潔的語法來撰寫單元測試。 而在內部 should.js 做了這樣的事情 12345678910111213var should = function (obj) &#123; return new Assertion(util.isWrapperType(obj) ? obj.valueOf(): obj)&#125;...exports = module.exports = shouldObject.defineProperty(Object.prototype, 'should', &#123; set: function()&#123;&#125;, get: function()&#123; return should(this); &#125;, configurable: true&#125;); 就算看到這邊您肯定跟我一樣有滿滿的疑惑，全域物件擴展定義跟 exports 有啥關聯呢？ 事實上 123456789101112131415161718/* whoami.js */exports = module.exports = &#123; name: 'andyyou'&#125;Object.defineProperty(Object.prototype, 'whoami', &#123; set: function () &#123;&#125;, get: function () &#123; return 'I am ' + this.name &#125;&#125;)/* app.js */var whoami = require('whoami')console.log(whoami) // &#123; name: 'andyyou' &#125;var obj = &#123; name: 'lena' &#125;console.log(obj.whoami) // I am lena 現在我們明白了上面說的修改全域物件的意思了。should.js 匯出了一個 should 函式但是它主要的使用方式則是把 should 加到 Object 屬性上，透過物件本身來呼叫。 套用猴子補丁(Monkey Patch)在這邊所謂的猴子補丁特別指的是在執行時期動態修改一個類別、模組或物件(也稱 object augmentation)，通常會這麼做是希望補強某的第三方套件的 bug 或功能。 假設某個模組沒有提供您客製化功能的介面，而您又需要這個功能的時候，我們就會實作一個模組來補強既有的模組。這個設計模式有點類似擴展全域物件，但並非修改全域物件，而是依靠 Node 模組系統的快取機制，當其他程式碼匯入該模組時去補強該模組的實例物件。 預設來說 Mongoose 會使用小寫以及複數的慣例替資料模型命名。例如一個資料模型叫做 CreditCard 最終我們會得到 collection 的名稱是 creditcards 。假如我們希望可以換成 credit_cards 並且其他地方也遵循一樣的用法。 下面是我們試著使用猴子補丁的方式來替既有的模組增加功能 1234567891011121314151617181920212223242526var pluralize = require('pluralize') // 處理複數單字的函式庫var mongoose = require('mongoose')var Mongoose = mongoose.Mongoosemongoose.Promise = global.Promise // v4.1+ http://mongoosejs.com/docs/promises.htmlvar model = Mongoose.prototype.model// 補丁var fn = function(name, schema, collection, skipInit) &#123; collection = collection || pluralize.plural(name.replace(/([a-z\\d])([A-Z])/g, '$1_$2').toLowerCase()) return model.call(this, name, schema, collection, skipInit)&#125;Mongoose.prototype.model = fn/* 實際測試 */mongoose.connect('mongodb://localhost/test')var CreditCardSchema = new mongoose.Schema(&#123;number: String&#125;)var CreditCardModel = mongoose.model('CreditCard', CreditCardSchema);var card = new CreditCardModel(&#123;number: '5555444433332222'&#125;);card.save(function (err) &#123; if (err) &#123; console.log(err) &#125; console.log('success')&#125;) 您不該輕易使用上面這種方式補丁，這邊只是為了說明猴子補丁這種方式，mongoose 已經有提供官方的方式設定名稱 1var schema = new Schema(&#123;..&#125;, &#123; collection: 'your_collection_name' &#125;) 當這個模組第一次被匯入的時候便會讓 mongoose 重新定義 Mongoose.prototype.model 並將其設回原本的 model 的實作。如此一來所有 Mongoose 的實例物件都具備新的行為了。注意到這邊並沒有修改 exports 所以當我們 require 的時候得到的是預設的物件 另外如果您想使用上面這種補丁的方式時，記得閱讀原始碼並注意是否產生衝突。 請善用匯出的功能Node模組系統提供了一個簡單的機制來封裝功能，使我們能夠建立了清楚的介面。希望掌握這七種設計模式提供不同的優缺點能對您有所幫助。 在這邊作者並沒有徹底的調查所有的方式，一定有其他選項可供選擇，這邊只有描述幾個最常見且不錯的方法。 小結 namespace: 匯出一個物件包含需要的功能 root module 的方式，使用一個根模組匯出其他模組 function: 直接將 module.exports 設為 function Function 物件也可以拿來當作命名空間使用 為其命名方便偵錯 exports = module.exports = something 的作法是為了確保參考(Reference)一致 high-order function: 可以透過代入參數控制並回傳 function 。 可協助實作 middleware 的設計模式 換句話說 middleware 即一系列相同 signature 的 function 串連。一個接一個執行 constructor: 匯出類別(function)，使用時再 new，具備 OOP 的優點 singleton: 匯出單一物件實例，重點在各個檔案可以共享物件狀態 global objects: 在全域物件作的修改也會一起被匯出 monkey patch: 執行時期，利用 Node 快取機制在 instance 加上補丁 筆記 一個 javascript 檔案可視為一個模組 解決特定問題或需求，功能完整由單一或多個模組組合而成的整體稱為套件(package) require 匯入的模組具有自己的 scope exports 只是 module.exports 的參考，exports 會記錄收集屬性如果 module.exports 沒有任何屬性就把其資料交給 module.exports ，但如果 module.exports 已經具備屬性的話，那麼exports 的所有資料都會被忽略。 就算 exports 置於後方仍會被忽略 Node 初始化的順序 Native Module -&gt; Module StartNodeInstance() -&gt; CreateEnvironment() -&gt; LoadEnvironment() -&gt; Cached Native Module 載入機制 檢查是否有快取 -&gt; 有; 直接回傳 this.exports -&gt; 沒有; new 一個模組物件 cache() compile() -&gt; NativeModule.wrap() 將原始碼包進 function 字串 -&gt; runInThisContext() 建立函式 return NativeModule.exports Node 的 require 會 cache ，也就是說：如果希望模組產生不同的 instance 時應使用 function 資源 官方 module 文件 理解 module exports Export This: Interface Design Patterns for Node.js Modules module.exports v.s exports 從 node.js 原始碼看 exports 與 module.exports Export This 中文","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"//andyyou.github.io/tags/nodejs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Facebook Bot 開發小技巧","slug":"facebook-bot","date":"2016-08-26T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/08/26/facebook-bot/","link":"","permalink":"//andyyou.github.io/2016/08/26/facebook-bot/","excerpt":"流程 準備環境 使用 ngrok 取得 https 網址 建立與設定 Facebook App 與粉絲團 建立 webhook GET API 設定 Facebook App webhook 實作 webhook POST API 產生對話","text":"流程 準備環境 使用 ngrok 取得 https 網址 建立與設定 Facebook App 與粉絲團 建立 webhook GET API 設定 Facebook App webhook 實作 webhook POST API 產生對話 準備由於 Facebook bot 在執行 API 溝通的時候需要使用 SSL 協定即網址要是 https，為了在本地端開發方便。因此我們需要使用 ngrok 來協助我們產生一個 https 的網址並傳回我們的機器。當然很多文章會介紹您使用 cloudflare 但這邊為了方便開發於是使用另外一種 ssh tunnel 的方式來解決 註冊並登入 ngrok 下載並安裝 ngrok 完成安裝 ngrok 憑證的流程 1234567# 安裝可以下載檔案並放置到 /usr/lcoal/bin 或者使用 brew$ brew cask install ngrok# 登入後會看到 ngrok 提供的驗證指令$ ngrok authtoken [your_token]# 開始使用$ ngrok http [port] 啟動之後畫面如下： 建立 Facebook App 與粉絲專頁 官方教學 建立好 App 與粉絲團之後接下來為了設定 webhook，網址的部分請給定 ngrok 的網址，例如https://[hash_code].ngrok.io/webhook。而 token 則是您自訂任意的字串，稍後需要在 API 中使用驗證。 因為設定 webhook 網址時，facebook 會發一個 request 給測試該網址是否正常運作，如果不正確的話，那就沒辦法進入下一階段了。所以我們需要先將 GET API 建立完成 123456app.get('/webhook/', function (req, res) &#123; if (req.query['hub.verify_token'] === '&lt;YOUR CUSTOM TOKEN&gt;') &#123; res.send(req.query['hub.challenge']); &#125; res.send('Error, wrong validation token');&#125;) 一旦設定了若要完全移除就是要讓 API 死掉 8H。 上敘動作完成之後，我們就完成前置作業了。接著下來就是實作與機器人對談的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var express = require('express')var bodyParser = require('body-parser')var request = require('request')var app = express()var token = '&lt;YOUR_PAGE_TOKEN&gt;'var facebookApi = 'https://graph.facebook.com/v2.6/me/messages'app.use(bodyParser.urlencoded(&#123; extended: true&#125;))app.use(bodyParser.json())app.get('/', function (req, res) &#123; res.send('Hi, server')&#125;)app.get('/webhook/', function (req, res) &#123; if (req.query['hub.verify_token'] === 'abcd') &#123; res.send(req.query['hub.challenge']); &#125; res.send('Error, wrong validation token');&#125;)app.post('/webhook/', function (req, res) &#123; console.log(req.body.entry[0]) var messages = req.body.entry[0].messaging for (var i = 0; i &lt; messages.length; i++) &#123; var event = messages[i] var sender = event.sender.id if (event.message &amp;&amp; event.message.text) &#123; var text = event.message.text sendTextMessage(sender, text) &#125; &#125; res.sendStatus(200)&#125;)app.listen(8080, function () &#123; console.log('Listen on port 8080')&#125;)/** * Functions */function sendTextMessage (sender, text) &#123; messageData = &#123; text: text &#125; request(&#123; url: facebookApi, qs: &#123; access_token: token &#125;, method: 'POST', json: &#123; recipient: &#123; id: sender &#125;, message: messageData &#125; &#125;, function (err, res, body) &#123; if (err) console.log('Error sending message: ', err) else if (res.body.error) console.log('Error: ', res.body.error) &#125;)&#125; 到此我們就完成了一個簡單的 Facebook BOT 應用。","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"bot","slug":"bot","permalink":"//andyyou.github.io/tags/bot/"},{"name":"facebook","slug":"facebook","permalink":"//andyyou.github.io/tags/facebook/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"[譯] 學習 CSS clip-path 屬性","slug":"css-clip-path","date":"2016-06-28T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/06/28/css-clip-path/","link":"","permalink":"//andyyou.github.io/2016/06/28/css-clip-path/","excerpt":"整體來說網頁主要是由矩形所構成的，另一方面印刷品則具備相對多樣性。造成這樣差異的原因有很多，不過其中一個即是缺少合適的工具。這篇文章主要會介紹 clip-path 這個 css 的樣式規則可以讓我們遮掉元素的局部，就是不顯示出來。達成這項功能背後的原理就是我們可以透過它去定義可視區，類似於遮色片的概念。我們將從基礎開始然後涵蓋語法，進一步理解進階的概念。","text":"整體來說網頁主要是由矩形所構成的，另一方面印刷品則具備相對多樣性。造成這樣差異的原因有很多，不過其中一個即是缺少合適的工具。這篇文章主要會介紹 clip-path 這個 css 的樣式規則可以讓我們遮掉元素的局部，就是不顯示出來。達成這項功能背後的原理就是我們可以透過它去定義可視區，類似於遮色片的概念。我們將從基礎開始然後涵蓋語法，進一步理解進階的概念。 基礎clip 意思是剪裁，意味著修剪某物的外型。在網頁設計的情況下，是讓我們可以去決定某個元素完全隱藏或局部隱藏。而在這篇文章中另外兩個相關的概念是 clipping path 和 clipping region。 clipping path 剪裁路徑意思就是我們使用它去修剪一個元素，透過路徑組成 clipping region 剪裁範圍。這個範圍或稱區域可以是簡單的形狀或複雜的多邊形。剪裁範圍就是透過一個封閉的剪裁路徑所組成的，這與您使用 Illustrator 的鋼筆工具繪製形狀的概念是一樣的。 任何在形狀範圍外的東西都會被瀏覽器裁掉。不只包含背景其他像是內容，borders，text-shadow 效果都會被裁掉。此外瀏覽器甚至不會處理範圍外的事件像是 hover, click 等。 即便我們設定的元素不再是矩形，但周圍的元素排列方式仍然維持原本矩形的佈局。為了達成周圍的元素跟著裁切的形狀，我們可以使用 shape-outside 屬性。 同時記住不要把舊的樣式 clip 和 clip-path 等搞混了。舊有的屬性只支援矩形的裁切。 使用目前這個樣式規則的語法如下： 1clip-path: &lt;clip-source&gt; | [ &lt;basic-shape&gt; || &lt;geometry-box&gt; ] | none 上面語法表示的是： clip-source 會是一個 URL 參考到一個 SVG &lt;clipPath&gt; 元素，這個元素可以是在檔案內部的或外連的。 basic-shape 基本形狀的 function ，您可以在 CSS Shapes 規範 中找到並使用。 geometry-box 可選的參數。搭配 basic-shape 函數，它的用途是設定整張畫布的基準點，定義裁切從哪範圍開始。如果我們自訂 geometry-box 那裁切路徑便會照著我們定義的形狀，包含任何圓角設定 border-radius 。這樣說有點模糊，稍後我們會詳細介紹。 現在，讓我們來思考下面這段 css 程式 123img &#123; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);&#125; 這段設定將會裁切所有圖片為一個菱形。不過為什麼圖片會變成菱形呢？為什麼不是梯形或平行四邊形？您應該猜到了，這是因為形狀取決為我們定義的頂點。下面圖片說明了建立裁切形狀時使用的慣例 每個座標的第一個參數指定了該座標的 x 軸，第二個參數則是 y 軸。所有的點依照順時鐘的方向繪製。依照這個規則與上圖我想您應該理解了。 如果您正在使用 CodePen 測試這些語法，請注意上面的程式範例僅在 Chrome 並且需要使用 prefix 才能正常運行，您可以打開 Auto Prefix 功能。 CodePen 使用 geometry-box 裁切元素當我們要裁切 HTML 元素時，geometry-box 可以是下列值 margin-box, border-box, padding-box, content-box 1234.el &#123; clip-path: polygon(10% 20%, 20% 30%, 50% 80%) margin-box; margin: 15px;&#125; 上面的範例，margin-box 會決定我們得座標點從 margin 的範圍開始，而 (10%, 10%) 就是我們實際內容的左上角，因此 clip-path 也必須對應計算。 SVG 元素的狀況下，參數可能是 fill-box, stroke-box, view-box 。其中 view-box 會最接近整個 svg 的可視範圍。 clip-path 的使用方式關於這個屬性有很多有趣的使用方式。第一個就是它可以美化文字內容。您可以觀察一下下圖，我們透過背景色與裁切所營造出的感覺不再受限與單純的方形。 簡單說您可以簡單的使用背景色，漸層等等您已經熟悉的屬性然後搭配 clip-path ，例如上面粉紅色背景類似泡泡對話框的效果，從前我們可以要透過 border 組成三角形在透過 transform 和調整位置等屬性去完成，現在換成 clip-path 只需要一行，我們可以輕鬆完成任何不規則的形狀。 123.msg &#123; clip-path: polygon(0% 0%, 100% 0%, 100% 75%, 75% 85%, 75% 100%, 50% 80%, 0% 75%);&#125; 當然您可以用來裁切圖片使其變成各種不同的形狀，您的相片圖庫的頁面不再只能用矩形呈現。下面是一個範例建議您使用 Chrome 玩玩 CodePen 動畫這個屬性也能夠被用在動畫上。唯一要注意的是初始時和最後結果的座標數量要一致。 1234567891011@keyframes polygons &#123; 25% &#123; clip-path: polygon(20% 0%, 100% 38%, 70% 90%, 0% 100%); &#125; 50% &#123; clip-path: polygon(0 46%, 100% 15%, 55% 74%, 0 100%); &#125; 70% &#123; clip-path: polygon(100% 38%, 100% 38%, 66% 100%, 0 53%); &#125;&#125; 為了維持動畫的順暢，基本上座標數量最好保持一致，至於形狀的變化您可以透過重疊座標來實現。 奇技淫巧另外我們還可以透過 clip-path 來隱藏元素，不過這個效果類似於 visibility 和 opacity 該位置空間仍會被佔據。 123.hide &#123; clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);&#125; 關於瀏覽器支援度這個屬性暫時在 IE, Edge 是不能使用的，Firefox 也還沒完全支援只支援部份語法，在 v47 還得要套過 layout.css.clip-path-shapes.enabled 來開啟。Chrome 的話要加上 -webkit- prefix。 總結總結來說關於 clip-path 的重點大略為 設定的座標點(clip-path)需要能夠封閉，圍成一個形狀(clip-range)，這個形狀就是顯示的區域。 周圍的元素仍需要靠 shape-outside 來修正。 geometry-box 用來設定座標軸範圍，用在 HTML 和 SVG 參數是不同的。 動畫的部分座標點數量需維持一致。 目前大多數的瀏覽器支援度還不夠。 clippy 和 座標產生器可以協助我們取得座標。 原文參考 Introducing the CSS clip-path Property","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Vue 實作簡易驗證機制 App","slug":"build-app-with-vue","date":"2016-06-18T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/06/18/build-app-with-vue/","link":"","permalink":"//andyyou.github.io/2016/06/18/build-app-with-vue/","excerpt":"為了顯示出 Vue.js 強大的能力 ，本文將會逐步指導建置一個簡單的前端應用程式。搭配 Node 所建置的後端程式範例。前後端兩個程式是完全分離的，後端使用 RESTful API 的方式負責取得資料與驗證。本文旨在說明如何替 Vue.js 程式加上驗證機制，過程中我們會使用 vue-router, vue-resource 實作 Login 與 Signup 元件展示如何檢索和儲存使用者的 jwt token，最後執行驗證機制取得那些需要授權的資料。","text":"為了顯示出 Vue.js 強大的能力 ，本文將會逐步指導建置一個簡單的前端應用程式。搭配 Node 所建置的後端程式範例。前後端兩個程式是完全分離的，後端使用 RESTful API 的方式負責取得資料與驗證。本文旨在說明如何替 Vue.js 程式加上驗證機制，過程中我們會使用 vue-router, vue-resource 實作 Login 與 Signup 元件展示如何檢索和儲存使用者的 jwt token，最後執行驗證機制取得那些需要授權的資料。 安裝與設定首先從組織前端程式開始，讓我們先來建立專案： 123$ mkdir auth-front-app$ cd auth-front-app$ npm init --yes 安裝我們所需要的 npm 套件，我們會在這個專案使用 Babel, Webpack 負責建置工具的部份： 123$ npm i babel-core babel-loader babel-plugin-transform-runtime babel-preset-es2015 babel-runtime css-loader style-loader vue-hot-reload-api vue-html-loader vue-style-loader vue-loader webpack webpack-dev-server -D$ npm i bootstrap vue-resource vue-router vue -S package.json 如下： 1234567891011121314151617181920212223242526272829303132&#123; \"name\": \"auth-front-app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"license\": \"MIT\", \"devDependencies\": &#123; \"babel-core\": \"^6.10.4\", \"babel-loader\": \"^6.2.4\", \"babel-plugin-transform-runtime\": \"^6.9.0\", \"babel-preset-es2015\": \"^6.9.0\", \"babel-runtime\": \"^6.9.2\", \"css-loader\": \"^0.23.1\", \"style-loader\": \"^0.13.1\", \"vue-hot-reload-api\": \"^1.3.3\", \"vue-html-loader\": \"^1.2.3\", \"vue-loader\": \"^8.5.3\", \"vue-style-loader\": \"^1.0.0\", \"webpack\": \"^1.13.1\", \"webpack-dev-server\": \"^1.14.1\" &#125;, \"dependencies\": &#123; \"bootstrap\": \"^3.3.6\", \"vue\": \"^1.0.25\", \"vue-resource\": \"^0.8.0\", \"vue-router\": \"^0.7.13\" &#125;&#125; 安裝完套件之後就是專案目錄下新增 webpack.config.js 設定檔： 1234567891011121314151617181920212223242526272829var path = require('path')module.exports = &#123; entry: ['./src/index.js', './src/auth/index.js'], output: &#123; path: path.join(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.vue$/, loader: 'vue' &#125;, &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125; ] &#125;, /** * option: 您可以選擇把下面這段設定置於 .babelrc */ babel: &#123; presets: ['es2015'], plugins: ['transform-runtime'] &#125;&#125; 設定檔中首要的就是我們程式的進入點，我們設定了 src/index.js 和 src/auth/index.js 這兩支程式，最後會被輸出成 bundle.js。到這一步先別擔心我們還沒完成任何程式，習慣上小弟我會先構想整個專案架構，透過組織 webpack.config 可以讓我們先好好思考一下。 因為我們想使用 vue 元件 的方式組織程式碼。於是設定了負責處理 .vue 的部分，即 vue-loader 協助編譯。到此便是我們目前所需的設定，最後我們只要透過 webpack-dev-server --inline --hot 就可觀察開發的前端程式。 Module not found: Error: Cannot resolve 因為到目前為止我們只是預先規劃兩隻進入點的程式還沒實作，所以執行 webpack-dev-server 會產生錯誤。 設定後端程式因為本篇文章主要是要討論關於 Vue.js 處理驗證機制的作法，所以我們在後端部分採用 nodejs-jwt-authentication-sample。使用概略如下： 12345678910111213141516171819# 記得切換到另外的目錄$ git clone git@github.com:auth0-blog/nodejs-jwt-authentication-sample.git$ cd nodejs-jwt-authentication-sample$ npm install# 啟動後端程式$ PORT=3001 node server.js# 建立使用者 POST /users# 注意：username 和 password 必須替換$ curl -d \"username=[replace_me]&amp;password=[replace_me]\" http://localhost:3001/users# 建立成功應會回傳 &#123; \"id_token\": \"...\" &#125;# 登入 POST /sessions/create$ curl -d \"username=[replace_me]&amp;password=[replace_me]\" http://localhost:3001/sessions/create# 登入成功應會回傳 &#123; \"id_token\": \"...\" &#125;# 不需授權 API: http://localhost:3001/api/random-quote# 受保護 API: http://localhost:3001/api/protected/random-quote 注意這個後端範例的帳號資料會放在記憶體中，重啟就會消失。 配置 Vue 元件現在可以來替我們的應用程式建置元件。在專案配置一節我們安裝與使用了 vue-loader 然後提到它讓我們可以使用 .vue 的方式來撰寫元件。具體來說就是我們在一隻 [component_name].vue 的檔案中分別撰寫 &lt;template&gt;, &lt;script&gt;, &lt;style&gt; ，最終這隻檔案會被輸出成一個元件供我們組合或使用。 123# 在專案目錄下$ mkdir -p src/components$ touch src/components/Home.vue Home 元件主要透過 API 去得不須授權的資料並顯示 src/components/Home.vue 元件程式碼如下 123456789101112131415161718192021222324252627282930&lt;!-- src/components/Home.vue --&gt;&lt;template&gt; &lt;div class=\"col-sm-6 col-sm-offset-3\"&gt; &lt;h1&gt;取得不需授權的 Chunck Norris 名言&lt;/h1&gt; &lt;button class=\"btn btn-primary\" @click=\"getQuote\"&gt;取得名言&lt;/button&gt; &lt;div class=\"quote-area\" v-if=\"quote\"&gt; &lt;h2&gt;&lt;blockquote&gt;&#123;&#123;quote&#125;&#125;&lt;/blockquote&gt;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; quote: '' &#125; &#125;, methods: &#123; getQuote () &#123; this.$http.get('http://localhost:3001/api/random-quote') .then((res) =&gt; &#123; this.quote = res.data &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125; &#125;&#125;&lt;/script&gt; &lt;template&gt; 裡的就是我們要顯示的 HTML 標籤結構，裡面有一個按鈕用來呼叫 getQuote，還有一些看起來像 Angular 1.x 的特殊屬性，它們是 Vue 的 directive，像是 @click, v-if 這些都是，而 @click 又可以寫成 v-on:click 當點擊的時候會觸發我們綁定的事件(從 methods 來)，v-if 可以根據綁定的資料 quote 來決定 &lt;div class=&quot;quote-area&quot;&gt; 是否要輸出顯示。當然 Vue 也可以在樣板中使用 { {} } 的語法用來作資料綁定(從 data 來)。 &lt;script&gt; 的部分會匯出一個 JS 物件，接著會被 Vue 轉換為一個 Vue 元件。大體來說 data 可以提供我們作資料繫結，methods 可以協助我們綁定一些互動的事件。getQuote 中的 this.$http 則是從 vue-resource 中加入的功能。 目前為止程式仍無法運作，不過我們簡單的介紹了一個 .vue 元件長啥樣和一些語法的作用。詳細的用法還是需要花點時間閱讀手冊。 主程式 index.js 和 App.vueindex.js 是程式主要的進入點，我們會在這邊匯入元件，設定路由等等等。為了單純起見，整個程式所有需要的設定都會放在這隻檔案中。 新增 src/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041import Vue from 'vue'import App from './components/App.vue'import Home from './components/Home.vue'import SecretQuote from './components/SecretQuote.vue'import Signup from './components/Signup.vue'import Login from './components/Login.vue'import VueRouter from 'vue-router'import VueResource from 'vue-resource'// 替 Vue 掛上 HTTP Request 的功能Vue.use(VueResource)// 替 Vue 掛上路由的功能Vue.use(VueRouter)// export 是為了讓其他分離的程式碼也能取得路由的物件實例export var router = new VueRouter()// 定義路由router.map(&#123; '/home': &#123; component: Home &#125;, '/secretquote': &#123; component: SecretQuote &#125;, 'login': &#123; component: Login &#125;, 'signup': &#123; component: Signup &#125;&#125;)router.redirect(&#123; '*': '/home'&#125;)auth.check()// 啟動路由並將 root component 掛載到 HTML 中 id=\"app\" 的 DOM 上router.start(App, '#app') 現在我們匯入了一些 Vue 元件大致上讓我們理解該怎麼使用元件與 vue-router，但注意到我們還未實作任何程式碼。 vue-router 和 vue-resource 需要透過 Vue.use() 將功能附加到 Vue 中。同時我們也定義了一些路由，理解 vue-router 中一個路由可以對應一個元件。 接著我們便可以開始完善這些元件。第一個是我們的根元件 App.vue 1234567891011121314151617181920212223&lt;!-- src/components/App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 注意：少了最外層的 wrapper 會出現 Attribute \"id\" is ignored on component 警告 --&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a v-link=\"'home'\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=\"'login'\"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=\"'signup'\"&gt;Signup&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=\"'secretquote'\"&gt;Secret Quote&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=\"'login'\"&gt;Logout&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=\"container\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 在 App.vue 元件中我們組織了最外層的結構，我們需要一個 navbar 來切換，而更換的元件會顯示在 &lt;router-view&gt;&lt;/router-view&gt; 位置。切換頁面的連結只要使用 v-link 屬性即可。最後我們需要一個 index.html 來載入 bundle.js 以及 app 的掛載點。 注意到 v-link 中的 &quot;&#39;home&#39;&quot;，v-link 有三種設定方式請參考說明文件 新增 index.html 1234567891011121314&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Authenticate Vue App&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"node_modules/bootstrap/dist/css/bootstrap.min.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 到這一步如果您很著急想看看到底實作了些什麼，您可以先把 webpack.config 中的 src/auth/index.js 移除並在 src/index.js 把還沒實作的元件註解。 執行 webpack-dev-server --inline --hot 應該可以看到如下圖 驗證機制為了讓使用者登入我們需要發送一個 HTTP 請求給後端程式驗證，然後儲存回傳的 jwt 到 localStorage。我們可以將這段邏輯放到 Login 元件裡，不過為了重複使用，我們會將這些驗證邏輯抽出來放到 src/auth/index.js 中。 新增 src/auth/index.js 撰寫程式碼如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 看到我們之前鋪的梗了吧，exprt router 就是這邊使用。import &#123;router&#125; from '../index'const API_URL = 'http://localhost:3001'export default &#123; user: &#123; authenticated: false &#125;, login (context, creds, redirect) &#123; var url = API_URL + '/sessions/create' context.$http.post(url, creds) .then((res) =&gt; &#123; localStorage.setItem('id_token', res.data.id_token) this.user.authenticated = true console.log('Login successfully', res.data.id_token) if (redirect) &#123; router.go(redirect) &#125; &#125;) .catch((err) =&gt; &#123; console.log(err) context.error = err.data &#125;) &#125;, signup (context, creds, redirect) &#123; var url = API_URL + '/users' context.$http.post(url, creds) .then((res) =&gt; &#123; localStorage.setItem('id_token', res.data.id_token) this.user.authenticated = true if (redirect) &#123; router.go(redirect) &#125; &#125;) .catch((err) =&gt; &#123; console.log(err) context.error = err.data &#125;) &#125;, logout () &#123; localStorage.removeItem('id_token') this.user.authenticated = false &#125;, check () &#123; /** * 這邊只是單純示範，您不該在驗證邏輯單純只判斷是否有 token */ var jwt = localStorage.getItem('id_token') if (jwt) &#123; this.user.authenticated = true &#125; else &#123; this.user.authenticated = false &#125; &#125;, getAuthHeader () &#123; return &#123; 'Authorization': 'Bearer ' + localStorage.getItem('id_token') &#125; &#125;&#125; 還記得我們在 src/index.js 中有匯出 export var router 所以這邊可以取得 router 的物件實例。這隻 src/auth/index.js 匯出一些 methods 協助我們執行登入，登出，驗證帳密，註冊的行為。登入只負責取回 jwt 然後儲存，如果帳密驗證失敗整個請求就會出現錯誤，自然就不會登入成功。最後我們透過這些方法和屬性來處理前端關於登入的相關邏輯，例如使用 user.authenticated 屬性來判斷是否登入。 實作 Login 元件Login 元件中我們需要兩個 &lt;input&gt; 來輸入帳密然後使用 auth 去驗證是否成功登入。 新增 src/components/Login.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- src/components/Login.vue --&gt;&lt;template&gt; &lt;div class=\"col-sm-4 col-sm-offset-4\"&gt; &lt;h2&gt;登入&lt;/h2&gt; &lt;p&gt; 登入帳號取得更棒的名言。 &lt;/p&gt; &lt;div class=\"alert alert-danger\" v-if=\"error\"&gt; &#123;&#123;error&#125;&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"帳號\" v-model=\"credentials.username\" &gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"密碼\" v-model=\"credentials.password\" &gt; &lt;/div&gt; &lt;button class=\"btn btn-primary\" @click=\"submit\"&gt;登入並存取&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import auth from '../auth'export default &#123; data () &#123; return &#123; credentials: &#123; username: '', password: '' &#125;, error: '' &#125; &#125;, methods: &#123; submit () &#123; var credentials = &#123; username: this.credentials.username, password: this.credentials.password &#125; auth.login(this, credentials, 'secretquote') &#125; &#125;&#125;&lt;/script&gt; HTTP 請求是透過 vue-reource 來完成的，由於我們把 auth 抽出去，所以在第一個參數部分，我們需要把 context 也就是該元件的物件實例(instance)傳過去，如此一來在發生錯誤的時候我們也才能夠把錯誤訊息傳回去。第二個參數是使用者登入所需的驗證資料，第三個參數則是完成登入後要切換的頁面路由。 緊接著 Signup 元件的部份跟 Login 幾乎一樣，只是使用的 auth 方法不同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- src/components/Signup.vue --&gt;&lt;template&gt; &lt;div class=\"col-sm-4 col-sm-offset-4\"&gt; &lt;h2&gt;註冊&lt;/h2&gt; &lt;p&gt; 建立一組新帳號吧！ &lt;/p&gt; &lt;div class=\"alert alert-danger\" v-if=\"error\"&gt; &#123;&#123;error&#125;&#125; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"帳號\" v-model=\"credentials.username\" &gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"密碼\" v-model=\"credentials.password\" &gt; &lt;/div&gt; &lt;button class=\"btn btn-primary\" @click=\"submit\"&gt;註冊並存取&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import auth from '../auth'export default &#123; data () &#123; return &#123; credentials: &#123; username: '', password: '' &#125;, error: '' &#125; &#125;, methods: &#123; submit () &#123; var credentials = &#123; username: this.credentials.username, password: this.credentials.password &#125; auth.signup(this, credentials, 'secretquote') &#125; &#125;&#125;&lt;/script&gt; 實作 SecretQuote 元件 - 取得受保護的資料使用者需要登入成功之後就才能存取 secret-quote 路由，SecretQuote 元件看起來跟 Home 很像，不過在呼叫 API 的過程需要使用 jwt token。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- src/components/SecretQuote.vue --&gt;&lt;template&gt; &lt;div class=\"col-sm-6 col-sm-offset-3\"&gt; &lt;h1&gt;取得需要授權的名言&lt;/h1&gt; &lt;button class=\"btn btn-warning\" @click=\"getQuote()\"&gt;取得名言&lt;/button&gt; &lt;div class=\"quote-area\" v-if=\"quote\"&gt; &lt;h2&gt;&lt;blockquote&gt;&#123;&#123;quote&#125;&#125;&lt;/blockquote&gt;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import auth from '../auth'export default &#123; data () &#123; return &#123; quote: '' &#125; &#125;, methods: &#123; getQuote () &#123; this.$http.get('http://localhost:3001/api/protected/random-quote', null, &#123; headers: auth.getAuthHeader() &#125;) .then( (res) =&gt; &#123; this.quote = res.data &#125;) .catch((err) =&gt; &#123; console.log(err) &#125;) &#125; &#125;, route: &#123; canActivate () &#123; return auth.user.authenticated &#125; &#125;&#125;&lt;/script&gt; 透過傳入 options 參數我們可以附加資料到請求的 header 中。而 jwt header 可以透過 auth.getAuthHeader 來取得。最關鍵的部分，因為我們不希望在使用者未登入時能夠存取該路由。所以在這一步我們就會透過 vue-router 的 canActivate hook 處理。 完成剩餘的部分最後針對不同狀態處理一些是否該顯示的地方完善我們的程式碼 App.vue 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- src/components/App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 注意：少了最外層的 wrapper 會出現 Attribute \"id\" is ignored on component 警告 --&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a v-link=\"'home'\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=\"'login'\" v-if=\"!user.authenticated\"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=\"'signup'\" v-if=\"!user.authenticated\"&gt;Signup&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=\"'secretquote'\" v-if=\"user.authenticated\"&gt;Secret Quote&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a v-link=\"'login'\" v-if=\"user.authenticated\" @click=\"logout\"&gt;Logout&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=\"container\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import auth from '../auth'export default &#123; data () &#123; return &#123; user: auth.user &#125; &#125;, methods: &#123; logout () &#123; auth.logout() &#125; &#125;&#125;&lt;/script&gt; 參考資源 Build an app with Vuejs","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"vuejs","slug":"vuejs","permalink":"//andyyou.github.io/tags/vuejs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"[譯] 美化無法載入的圖片 <img>","slug":"sytling-broken-images","date":"2016-06-16T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/06/16/sytling-broken-images/","link":"","permalink":"//andyyou.github.io/2016/06/16/sytling-broken-images/","excerpt":"當網頁中無法載入圖片(通常是圖片連結失效或錯誤)時，瀏覽器預設會幫我們顯示一個小小的圖示告知我們連結失效了。 這些預設圖片每一個瀏覽器都不太一樣，通常也不太好看。這篇文章主要介紹的內容就是我們可以透過 css 來美化這個預設行為。","text":"當網頁中無法載入圖片(通常是圖片連結失效或錯誤)時，瀏覽器預設會幫我們顯示一個小小的圖示告知我們連結失效了。 這些預設圖片每一個瀏覽器都不太一樣，通常也不太好看。這篇文章主要介紹的內容就是我們可以透過 css 來美化這個預設行為。 關於 元素的兩件事為了了解如何美化壞掉的圖片，有兩個關於 &lt;img&gt; 的行為我們必須先瞭解。 能夠套用文字相關的樣式，這些樣式只會被套用在替代文字上。在圖片正常載入的情況下則沒有任何效果。 &lt;img&gt; 是一個replaced element，例如 &lt;video&gt;, &lt;object&gt; 等等，大略的意思就是這個元素呈現的外型尺寸是透過外部資源來決定的，像是圖片就是由實際圖片來決定，想知道更詳細的說明可以參考Sitepoint 提供了更好的說明。因為元素是透過外部資源來控制的，所以預設來說 :before 和 :after 這些偽元素(pseudo-elements) 應該是不能運作的，不過當圖片失效或是無法載入的時候這些偽元素就可以作用了。 因為上面這兩個原理所以我們能夠套用一些樣式只出現在 &lt;img&gt; 無法載入圖片的時候。 實作假設我們現在有一個圖片標籤 1&lt;img src=\"http://andyyou.github.io/broken.png\" alt=\"andyyou\"&gt; 提供有意義的資訊第一個重點就是我們需要設定 alt 為的就是在圖片失效的時候提供給使用者一些關於這張圖片的描述資訊。接著為了處理圖片失效的問題我們也需要提供一些資訊告訴使用者這張圖片壞了。另外就是可以透過 attr() 取得相關的資訊。 12345678910111213141516171819202122img &#123; font-family: 'Helvetica'; font-weight: 300; line-height: 1.4em; text-align: center; width: 100%; height: auto; display: block; position: relative; &amp;:before &#123; content: \"We are sorry, the image is broken :(\"; display: block; margin-bottom: 10px; &#125; &amp;:after &#123; content: \"(url: \" attr(src) \")\"; display: block; font-size: 12px; &#125;&#125; 取代預設的替代文字透過偽元素我們可以取代預設的替代文字 alt text，原理就是把偽元素蓋在預設替代文字的上方。 12345678910111213141516img:after &#123; content: \"\\f1c5\" \" \" attr(alt); font-size: 16px; font-family: FontAwesome; color: rgb(100, 100, 100); display: block; position: absolute; z-index: 2; top: 0; left: 0; width: 100%; height: 100%; background-color: #fff; /* 如果透明或不設定的話就露餡了 */&#125; 其他樣式到了這邊其實我們知道有兩個偽元素可以操作，除了顯示資訊之外其實也可以用來單純作樣式的設計 1234567891011121314151617181920212223242526272829303132333435363738img &#123; font-family: 'Helvetica'; font-weight: 300; line-height: 2em; text-align: center; width: 100%; height: auto; display: block; position: relative; min-height: 50px; &amp;:before &#123; content: \" \"; display: block; position: absolute; top: -10px; left: 0; height: calc(100% + 10px); width: 100%; background-color: rgb(230, 230, 230); border: 1px dotted rgb(200, 200, 200); border-radius: 5px; &#125; &amp;:after &#123; content: \"\\f127\" \" Broken Image of \" attr(alt); display: block; font-size: 16px; font-style: normal; font-family: FontAwesome; color: rgb(100, 100, 100); position: absolute; top: 5px; left: 0; width: 100%; text-align: center; &#125;&#125; 瀏覽器支援很不幸的並不是所有瀏覽器都完整支援 alt text, :before, :after 套用樣式。所以在部分瀏覽器上這個作法可能不被支援。 來源 Styling broken images","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Node 實作 jwt 驗證 API","slug":"implement-jwt-with-understanding","date":"2016-06-09T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/06/09/implement-jwt-with-understanding/","link":"","permalink":"//andyyou.github.io/2016/06/09/implement-jwt-with-understanding/","excerpt":"基於 token 的驗證機制在今天，我們應該常常能看到大量使用 token 來處理驗證的服務，由於大部分的網站服務開始大量使用 API，於是 token 就成了處理驗證使用者最好的方式。我們的應用程式選擇使用 token 驗證機制有些非常重要的原因，最主要是因為: 對於伺服器來說它具備 stateless(無狀態), scalable(擴展性) 移動裝置也能一併使用 可將驗證結果導向其他應用程式 更安全","text":"基於 token 的驗證機制在今天，我們應該常常能看到大量使用 token 來處理驗證的服務，由於大部分的網站服務開始大量使用 API，於是 token 就成了處理驗證使用者最好的方式。我們的應用程式選擇使用 token 驗證機制有些非常重要的原因，最主要是因為: 對於伺服器來說它具備 stateless(無狀態), scalable(擴展性) 移動裝置也能一併使用 可將驗證結果導向其他應用程式 更安全 誰已經使用 token 驗證機制大多您已經使用的 API 或網站服務已經使用 token 的方式像是 Facebook, Twitter, Google+, Github 等等 為什麼 token 會被大家接受在我們開始了解 token 的運作原理和優點之前我們先來看看過去的做法 Server based authentication 基於伺服器的驗證機制 由於 HTTP 協定是不儲存狀態的(stateless)，這意味著當我們透過帳號密碼驗證一個使用者時，當下一個 request 時它就把剛剛的資料忘了。於是我們的程式就不知道誰是誰，就要再驗證一次。過去我們的應用程式記得使用者的方式就是把資料存放在伺服器。伺服器透過 session 紀錄而儲存有幾種不同的方式，可以被存在記憶體或者是硬碟。 大略的說從 HTTP 是無法保持狀態開始，然後人們因為動態網頁的需求，需要辨別使用者或之前的操作於是有了 cookie 讓客戶端能夠紀錄資訊，在每次請求的時候附上這些資訊以提供伺服器處理。接著基於一些安全性的需求我們透過發放編號 session id的方式，把那些不希望被竄改的資訊存在伺服器記錄。之後透過 session id 來辨別使用者。 本文並非要深入探討舊有的方式所以我們簡單理解 session 會話期間(意義為進行一系列活動/溝通之期間)於網路協議時包含連線 &amp; 維持狀態的行為與資訊就是一種讓我們解決保持狀態問題的方法。 下圖就是伺服器的工作流程。 使用者對伺服器發出內容請求 伺服器回應內容給客戶端 當使用者登入時，伺服器會把登入資料儲存在 session 中，第一次進來的時候伺服器會發放一組號碼牌(session id)給使用者 下次同一個使用者(瀏覽器)再進來的時候，伺服器就可以靠 session id 來判斷這位使用者 這樣的方式陪伴著我們好多年，不過在 web 與 mobile 應用爆發性成長的今日，這樣的方式就顯現出一些問題，尤其是在擴展方面。 伺服器驗證機制的問題其中幾個最主要的問題: sessions: 每一次使用者驗證，必須建立一組紀錄在伺服器上。通常會存在記憶體中，當驗證的使用者越多存放的資料就越多。 擴展性: 由於 session 存在記憶體這就會造成擴展時的問題，當我們使用一些雲端服務增加伺服器執行負載平衡的時候把這些重要的資訊存在記憶體就會受到一些限制。 跨站: 當我們想要讓程式的一些資料交換給其他程式或行動裝置使用的時候就會遇到 cros 跨網域存取的問題。想像一下如果我們需要在一個手機 app 中呼叫原本程式中的 API 就會遇到。 CSRF 偽造跨站請求: 我們仍可能會遇到偽造跨站請求的問題，當使用者已經登入的時候 就可能會遇到這類的攻擊。 不過在這些問題中最大的問題還是屬於擴展性。 token 驗證機制如何運作基於 token 的驗證機制屬於無狀態的方式，我們不並需要在伺服器儲存任何關於使用者的資料。這個概念本身就是為了處理上述的那些問題。少了 session 表示我們的程式在使用負載平衡擴展伺服器時就不用因為這些資料交換的問題而受到限制。 雖然實作有很多種方式，不過大致上流程如下: 使用者提供帳密發出驗證請求 程式驗證憑證 程式提供回傳一個簽署過的 token 給客戶端 客戶端儲存 token ，後續請求都必須要一併包含這個 token 伺服器驗證 token 然後才回傳資料 每一道 request 都要包含 token。這個 token 應該要被包含在 HTTP header 中，也因此這種方式達成了 stateless 的特性。接著我們就可以將伺服器的存取限制設定為 Access-Control-Allow-Origin: *。關於 ACAO header 中設定為 * 同時表示這不允許請求提供憑證例如: HTTP 憑證, 客戶端的 SSL 憑證或 cookie。下圖顯示整個流程 一旦通過驗證我們就會擁有 token，我們就可以透過這個 token 做出許多應用。我們可以基於 token 建立授權甚至是傳遞給第三方應用使用。透過 token 我們就可以決定哪些行為可以放行。 token 的優點最大的好處就是擴展性和 stateless。因為 stateless 的關係我們的程式隨時都可以導入負載平衡。如果我們使用 session 那麼當使用者登入之後要繼續後續的動作就必須要把資料送回同一台伺服器。然後就可能對伺服器造成壓力。一旦採用 token 那麼這些問題就不用再擔心了。 安全性token 不像 cookie，它會在每一次 request 的時候都要帶一次，因為沒有被存放到 cookie 中也就沒有機會被其他客戶端的程式直接存取。甚至是您將 token 儲存在 cookie 中，cookie 也只是一種儲存方式而不是實際驗證機制。 token 也會過期，所以使用者會被要求在登入一次，這協助我們提高安全性。這裡提到 token revocation 的概念，讓我們可以指定某個 token 失效或者是一整組基於同一個授權的 token。 擴展性token 也可以讓我們的程式共享權限。舉例來說我們透過連結到社群平台驗證登入像是 Facebook 或 Twitter。又例如當我們在 Buffer 給予 Twitter 權限那麼我們就可以透過 Buffer 發文到 Twitter 上。使用 token 我們就可以提供特定權限或功能給第三方的應用程式。 跨平台與網域稍早我們提到 CORS，當我們需要增加其他的服務或程式我們就需要提供存取權限給該網域或程式。又比如我們有一個 API 只負責提供資料，這個時候我們或許就會使用 CDN 來處理 CORS 的問題。如果我們可以直接把伺服器的設定換成 1Access-Control-Allow-Origin: * 我們的資料或服務就可以提供給任何網域或程式來使用，當然你會說有安全性的問題，不過別忘了我們現在有 token 協助我們去驗證使用者。 標準關於建立 token 我們有一些選擇。在下面的章節我們會深入關於 API 安全性的議題，不過主要會介紹 JSON Web Tokens 標準。jwt.io提供了一些方便的除錯工具與函式庫支援的圖表。可以看到大部分的語言都有支援。 JSON Web Token 解析近年來 API 盛行不管是 Open Data 等，也就造成一個程式想要充分發揮潛能，常常會需要從其他地方取得資料，與第三方的程式整合。想想 Facebook 提供 API 讓我們可以取得資料和登入功能，Facebook 即所謂提供我們這些第三方應用存取其資料的例子。而這些都是透過 API 完成的。 現在當我們討論到關於我們自己打造自己的 API，不管是誰要完成這件事都需要面對一個問題，那就是如何確保 API 的安全性。上面我們已經探討過基於 toke 的驗證機制。現在我們要來討論的事關於 JSON Web Tokens 這個標準以及我們如何建置它。 JSON Web Token 是啥?JSON Web Tokens 又稱 JWT 發音是 jot 從名字不難看出資料是透過 JSON 傳遞的。這裡有關於 JWT 的規格草稿，不過它並不好讀。JWT 可以在不同的語言中使用包含 .NET, Python, NodeJS, Java, PHP, Ruby, Go, Haskell 等。所以基本上在各種情況下我們都能夠使用。JWT 不相依於其他東西是可以獨立使用的: 它會包含自己所有需要的資料，意味著 JWT 是可以會傳送關於自身的基本資料，一個 payload 通常指的是使用者的資訊以及一個 signature 簽章。 JWT 可以被輕易的傳送: 因為 JWT 自身就包含了必須的資料且不依賴其他東西，因此當我們要透過 API 驗證的時候它可以完美的透過 HTTP header 或者網址來傳遞。 那麼一個 JWT 到底長啥樣?要辨別一個 JWT 非常簡單，它就是三個字串透過 . 合在一起 1aaaaaaaaaa.bbbbbbbbbbb.cccccccccccc 解析一個 JWT我們很容易的就可以看出這是透過 . 連結三個不同的部份它們各自代表的是: header: 標頭資訊 payload: 處理的內容實際資料 signature: 簽章 Headerheader 包含兩個部分 宣告型別是 JWT 使用的演算法，在這個例子中是 HMAC SHA256 1234&#123; \"typ\": \"JWT\", \"alg\": \"HS256\"&#125; 一旦將上面的資訊使用 base64encode 我們就會得到第一個部分的 token 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 你可以拿著上面的 token 去 jwt.io 網站上使用工具試試。 Payload關於 payload 大體來說就是需要處理的實際資料內容，這個 payload 通常會是整個 JWT 中比較重要的資料又稱 JWT Claims 即紀錄這個 JWT 的主張或者說本次傳輸主要的目的，主張是比較抽象的描述但具體來說就是資料。我們將想要傳送的資料和一些附加的資訊放在這裡。Claims 可以不只一個，為了不產生疑義後續我們將使用英文術語 - JWT Claims。 Registered Claims關於 Claims 即傳遞的資料並不是必須的，不過根據規範我們可以使用下面這些預先定義好的 Claims 名稱讓我們可以使用: iss: 發行者的 token sub: 主題的 token aud: 接受者(聽眾)的 token exp: 這可能是 Registered Claims 最常用的，定義數字格式的有效期限，重點是有效期限一定要大於現在的時間 nbf: 生效時間，定義一個時間在這個時間之前 JWT 不能進行處理 iat: 發行的時間，可以被用來判斷 JWT 已經發出了多久 jti: JWT 唯一的識別值，可用來防止 JWT 被重複使用，尤其在一次性的 token 特別好用 Public Claims我們所建立的公開資訊例如使用者姓名等等。 Private Claims發行者與訂閱者自行溝通定義的 Claims Name 與資料 payload 範例下面這個範例有兩個 registered claims(iss 和 exp)以及兩個 public claims(name, admin) 123456&#123; \"iss\": \"andyyou.github.io\", \"exp\": 1465700328092, \"name\": \"andyyou\", \"admin\": true&#125; 第二部分的 JWT 編譯過後就是 1eyJpc3MiOiJhbmR5eW91LmdpdGh1Yi5pbyIsImV4cCI6MTQ2NTcwMDMyODA5MiwibmFtZSI6ImFuZHl5b3UiLCJhZG1pbiI6dHJ1ZX0 Signature 簽章第三個部分就是簽章，這個簽章由下面三個部分組成 header payload secret 看看範例程式碼便知是如何得到 12var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload)HMACSHA256(encodedString, 'secret') secret 的部分由伺服器持有，也因此伺服器才有辦法驗證 token 和簽發 16srTK4rBbOqlWj7le2hrwFP-iayHblLdhgVFIYU3gVg 最終得到的 JWT 就如同一開始提到的由兩個 . 串接三個編碼 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhbmR5eW91LmdpdGh1Yi5pbyIsImV4cCI6MTQ2NTcwMDMyODA5MiwibmFtZSI6ImFuZHl5b3UiLCJhZG1pbiI6dHJ1ZX0.6srTK4rBbOqlWj7le2hrwFP-iayHblLdhgVFIYU3gVg 總結來說 JWT 可以跨平台跨語言，讓不同的裝置應用或服務之間溝通，同時這個 token 可以搭配 URL, POST 參數, 或者 HTTP 標頭來傳遞使用。透過 JWT 讓我們可以快速方便的賦予 API 驗證機制。 Nodejs 實作接下來讓我們透過 Node 與 Express 實踐一個簡單的 API 然後透過 POSTman 來測試。這個範例主要的工作流程 個別有公開和需要授權的路由 使用者需要帳密通過驗證取得 token 使用者將 token 儲存在客戶端，之後的每一次請求都將包含此 token 收到請求後會驗證 token ，當 token 正確才回傳資料 建構專案目錄結構首先我們先來看看這個 Node 應用程式的檔案架構，為了單純我們會將大部分的邏輯都寫在 server.js 1234567$ mkdir simple-api$ cd simple-api$ npm init --yes$ mkdir -p app/models$ touch app/models/user.js$ touch config.js$ touch server.js 123456├── app│ └── models│ └── user.js├── config.js├── package.json└── server.js 在實務上您應該盡可能分拆與組織檔案，而不是把全部的邏輯都放在一起。 設定設定 package.json 12345&#123; \"name\": \"simple-api\", \"version\": \"1.0.0\", \"main\": \"server.js\"&#125; 接著安裝我們需要用到的套件與函式庫 1234567$ npm i express body-parser morgan mongoose jsonwebtoken -S# express: 輕量化的 web framework# mongoose: MongoDB 的 ORM 套件，我們使用它來操作資料庫# morgan: HTTP request logger，會於 console 輸出 request 的資訊# body-parser: 協助我們取得 POST request 的資料# jsonwebtoken: 建置/驗證 JWT 設定 Model我們需要定義一個使用者的資料模型 Model，之後會用它來建立使用者資料，這個步驟是因為我們使用 MongoDB 搭配 Mongoose，所以我們要建立 app/models/user.js 來定義 Model, Schema。 12345678var mongoose = require('mongoose')var Schema = mongoose.Schemamodule.exports = mongoose.model('User', new Schema(&#123; name: String, password: String, admin: Boolean&#125;)) 應用程式設定檔 (config.js)通常程式會有一些設定的資料像是連線字串, secret 加密字串, 這些資料我們通常會彙整在一個檔案以方便日後調整。 1234567module.exports = &#123; 'secret': 'ilovera', 'database': 'mongodb://localhost/jwt_dev'&#125;// secret: 加密與驗證 token// database: 連線字串 到這一步我們已經完成大部分的前置作業，接著要進入核心部分 server.js Node 應用程式在這一隻檔案中我們將會 載入套件與資料模型等就是我們先前安裝的那些 express, body-parser, morgan 和 Model 的部分 載入與配置設定 建立基本路由 建立 API 路由 POST http://localhost:8080/api/authenticate 確認帳密是否與資料庫吻合，如果正確就回傳 token 這個路由本身不需要驗證 GET http://localhost:8080/api/api 隨機回傳資訊，這個路由需要授權也就是需要 token 才能存取 GET http://localhost:8080/api/users 列出所有使用者，同樣這個路由也需要授權 這支程式的基本功能 12345678910111213141516171819202122232425262728293031// 載入 server 程式需要的相關套件var express = require('express')var app = express()var bodyParser = require('body-parser')var morgan = require('morgan')var mongoose = require('mongoose')// 載入 jwt 函式庫協助處理建立/驗證 tokenvar jwt = require('jsonwebtoken')// 載入設定var config = require('./config')// 載入資料模型var User = require('./app/models/user')var port = process.env.PORT || 8080mongoose.connect(config.database)app.set('secret', config.secret)// 套用 middlewareapp.use(bodyParser.urlencoded(&#123;extended: false&#125;))app.use(bodyParser.json())app.use(morgan('dev'))app.get('/', function (req, res) &#123; res.send('Hi, The API is at http://localhost:' + port + '/api')&#125;)app.listen(port, function () &#123; console.log('The server is running at http://localhost:' + port)&#125;) 完成檔案之後可以使用 node server.js 來測試，瀏覽 http://localhost:8080 應該要能看到 Hi, The API is at http://localhost:8080/api 的文字。因為我們有使用 morgan 所以應該也要能在 console 看到像 GET / 200 2.846 ms - 43 的資訊。 建立使用者帳號OK! 現在我們的程式能運作了，讓我們先來建立一組帳密。因為我們的主題是要了解 jwt 的運作流程所以這邊為了方便我們直接透過呼叫一個路由 /setup 直接建立一組帳密。在 app.get(&#39;/&#39;) 路由下面新增一組路由 12345678910111213app.get('/setup', function (req, res) &#123; var andyyou = new User(&#123; name: 'andyyou', password: '12345678', admin: true &#125;) andyyou.save(function (err) &#123; if (err) throw err console.log('User saved successfully') res.json(&#123;success: true&#125;) &#125;)&#125;) 值得注意的是在正式環境，密碼的部分不應該像上面的作法直接儲存明碼，應要加密。 接著重啟 server node server.js 瀏覽 http://localhost:8080/setup 就會建立使用者。查看資料庫應會如下圖 顯示使用者現在我們可以來實作使用者列表的 API 了，在這一步我們會使用 express.Router() 這麼做的好處是之後我們可以把整包相關的路由掛載到某個前綴路徑上。比如說我們有 /, /users, edit 等路由，透過 app.use(&#39;/api&#39;, 路由實力物件) 的方式產出 /api, /api/users, /api/edit 1234567891011121314var api = express.Router()// TODO: authenticate// TODO: verify tokenapi.get('/', function (req, res) &#123; res.json(&#123;message: 'Welcome to the APIs'&#125;)&#125;)api.get('/users', function (req, res) &#123; User.find(&#123;&#125;, function (err, users) &#123; res.json(users) &#125;)&#125;)app.use('/api', api); 每一次修改程式碼都需要重啟，不然我們就需要使用像是 nodemon 12$ npm install -g nodemon$ nodemon server.js 剛剛我們加了兩道 API 現在我們可以透過 postman 來測試看看 Imgur Imgur 現在我們可以顯示出列表了但在實務上我們大概都不希望任何人都能存取我們的這些資料，接著就是重點我們要透過驗證來保護這些資料只讓特定的使用者查詢。 驗證機制透過 http://localhost:8080/api/authenticate 路由我們將允許那些通過驗證的人存取，這個過程我們會驗證帳密，然後建立派發 token一旦使用者獲得 token，就會將其暫存在客戶端，之後每一個 request 都需要這個 token。接著伺服器端會透過 middleware 的方式在每個存取的過程驗證。 12345678910111213141516171819202122232425api.post('/authenticate', function (req, res) &#123; User.findOne(&#123; name: req.body.name &#125;, function (err, user) &#123; if (err) throw err if (!user) &#123; res.json(&#123; success: false, message: 'Authenticate failed. User not found'&#125;) &#125; else if (user) &#123; if (user.password != req.body.password) &#123; res.json(&#123; success: false, message: 'Authenticate failed. Wrong password'&#125;) &#125; else &#123; var token = jwt.sign(user, app.get('secret'), &#123; expiresIn: 60*60*24 &#125;) res.json(&#123; success: true, message: 'Enjoy your token', token: token &#125;) &#125; &#125; &#125;)&#125;) 接著透過 postman 測試我們剛完成的功能，首先 method 要換成 POST，然後參數的部份要切到 Body 使用 x-www-form-urlencoded。這個步驟我們使用 postman 模擬實際在網頁中送出 post 的過程。可以順便測試一下當密碼錯誤時是否回傳正確的資訊。 Imgur 驗證 token到了這一步我們已經實作了三道路由 /api/authenticate, /api, /api/users。最後的任務自然是要存取的過程時要驗證 token。現在我們需要建立路由的 middleware ，賦予 API驗證機制，其中 /api/authenticate 是不需要被保護的。需要注意的是 middleware 擺放的位置會影響是否要驗證。要驗證的路由必須要 middleware 之後。 12345678910111213141516171819202122232425262728var api = express.Router()// authenticate apiapi.use(function (req, res, next) &#123; var token = req.body.token || req.query.token || req.headers['x-access-token'] if (token) &#123; jwt.verify(token, app.get('secret'), function (err, decoded) &#123; if (err) &#123; return res.json(&#123;success: false, message: 'Failed to authenticate token.'&#125;) &#125; else &#123; req.decoded = decoded next() &#125; &#125;) &#125; else &#123; return res.status(403).send(&#123; success: false, message: 'No token provided.' &#125;) &#125;&#125;)// Others APIs// /api// /api.usersapp.use('/api', api); 這個過程我們使用 jsonwebtoken 套件來協助我們處理驗證，重要的是那個 secret 要跟我們派發時的一致。經過 middleware 的處理我們就可以判斷使用者是否通過驗證。 測試 middleware經過 middleware 中介軟體的處理我們在 api 的每一道路由(在設定 middleware 之後)都會先執行 middleware。於是我們就在這個過程處理 token 判斷是否要放行。現在我們就可以再次使用 postman 來測試，因為 jwt 的傳遞可以透過 header, body, URL Query 三種方式所以在 postman 中我們可以切換到 GET 然後使用 header 標頭方式來測試 without token Imgur with token Imgur 當然我們也能透過 query string 的方式來通過驗證。通過實作我們大致理解了 API 驗證在 Node 的實作思路，下面附上完整 server.js 程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899var express = require('express')var app = express()var bodyParser = require('body-parser')var morgan = require('morgan')var mongoose = require('mongoose')var jwt = require('jsonwebtoken')var config = require('./config')var User = require('./app/models/user')var port = process.env.PORT || 8080mongoose.connect(config.database)app.set('secret', config.secret)app.use(bodyParser.urlencoded(&#123;extended: false&#125;))app.use(bodyParser.json())app.use(morgan('dev'))app.get('/', function (req, res) &#123; res.send('Hi, The API is at http://localhost:' + port + '/api')&#125;)app.get('/setup', function (req, res) &#123; var andyyou = new User(&#123; name: 'andyyou', password: '12345678', admin: true &#125;) andyyou.save(function (err) &#123; if (err) throw err console.log('User saved successfully') res.json(&#123;success: true&#125;) &#125;)&#125;)var api = express.Router()api.post('/authenticate', function (req, res) &#123; User.findOne(&#123; name: req.body.name &#125;, function (err, user) &#123; if (err) throw err if (!user) &#123; res.json(&#123; success: false, message: 'Authenticate failed. User not found'&#125;) &#125; else if (user) &#123; if (user.password != req.body.password) &#123; res.json(&#123; success: false, message: 'Authenticate failed. Wrong password'&#125;) &#125; else &#123; var token = jwt.sign(user, app.get('secret'), &#123; expiresIn: 120 &#125;) res.json(&#123; success: true, message: 'Enjoy your token', token: token &#125;) &#125; &#125; &#125;)&#125;)api.use(function (req, res, next) &#123; var token = req.body.token || req.query.token || req.headers['x-access-token'] if (token) &#123; jwt.verify(token, app.get('secret'), function (err, decoded) &#123; if (err) &#123; return res.json(&#123;success: false, message: 'Failed to authenticate token.'&#125;) &#125; else &#123; req.decoded = decoded next() &#125; &#125;) &#125; else &#123; return res.status(403).send(&#123; success: false, message: 'No token provided.' &#125;) &#125;&#125;)api.get('/', function (req, res) &#123; res.json(&#123;message: 'Welcome to the APIs'&#125;)&#125;)api.get('/users', function (req, res) &#123; User.find(&#123;&#125;, function (err, users) &#123; res.json(users) &#125;)&#125;)app.use('/api', api)app.listen(port, function () &#123; console.log('The server is running at http://localhost:' + port)&#125;) 觀察不同套件產生之 Tokenjsonwebtoken 產生的 token 範例 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyIkX18iOnsic3RyaWN0TW9kZSI6dHJ1ZSwiZ2V0dGVycyI6e30sIndhc1BvcHVsYXRlZCI6ZmFsc2UsImFjdGl2ZVBhdGhzIjp7InBhdGhzIjp7Il9fdiI6ImluaXQiLCJhZG1pbiI6ImluaXQiLCJwYXNzd29yZCI6ImluaXQiLCJuYW1lIjoiaW5pdCIsIl9pZCI6ImluaXQifSwic3RhdGVzIjp7Imlnbm9yZSI6e30sImRlZmF1bHQiOnt9LCJpbml0Ijp7Il9fdiI6dHJ1ZSwiYWRtaW4iOnRydWUsInBhc3N3b3JkIjp0cnVlLCJuYW1lIjp0cnVlLCJfaWQiOnRydWV9LCJtb2RpZnkiOnt9LCJyZXF1aXJlIjp7fX0sInN0YXRlTmFtZXMiOlsicmVxdWlyZSIsIm1vZGlmeSIsImluaXQiLCJkZWZhdWx0IiwiaWdub3JlIl19LCJlbWl0dGVyIjp7ImRvbWFpbiI6bnVsbCwiX2V2ZW50cyI6e30sIl9ldmVudHNDb3VudCI6MCwiX21heExpc3RlbmVycyI6MH19LCJpc05ldyI6ZmFsc2UsIl9kb2MiOnsiX192IjowLCJhZG1pbiI6dHJ1ZSwicGFzc3dvcmQiOiIxMjM0NTY3OCIsIm5hbWUiOiJhbmR5eW91IiwiX2lkIjoiNTc1Y2UxYTBkY2I1NDUwZDFhNzIwZjljIn0sIl9wcmVzIjp7IiRfX29yaWdpbmFsX3NhdmUiOltudWxsLG51bGxdfSwiX3Bvc3RzIjp7IiRfX29yaWdpbmFsX3NhdmUiOltdfSwiaWF0IjoxNDY1NzMxNjU4LCJleHAiOjE0NjU3MzE3Nzh9.toeuSCZ6M0XcjS1p2Tn1h30HQIOQmrBKRsAsgaWvx9g jsonwebtoken token 解析 payload 部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; &quot;$__&quot;: &#123; &quot;strictMode&quot;: true, &quot;getters&quot;: &#123;&#125;, &quot;wasPopulated&quot;: false, &quot;activePaths&quot;: &#123; &quot;paths&quot;: &#123; &quot;__v&quot;: &quot;init&quot;, &quot;admin&quot;: &quot;init&quot;, &quot;password&quot;: &quot;init&quot;, &quot;name&quot;: &quot;init&quot;, &quot;_id&quot;: &quot;init&quot; &#125;, &quot;states&quot;: &#123; &quot;ignore&quot;: &#123;&#125;, &quot;default&quot;: &#123;&#125;, &quot;init&quot;: &#123; &quot;__v&quot;: true, &quot;admin&quot;: true, &quot;password&quot;: true, &quot;name&quot;: true, &quot;_id&quot;: true &#125;, &quot;modify&quot;: &#123;&#125;, &quot;require&quot;: &#123;&#125; &#125;, &quot;stateNames&quot;: [ &quot;require&quot;, &quot;modify&quot;, &quot;init&quot;, &quot;default&quot;, &quot;ignore&quot; ] &#125;, &quot;emitter&quot;: &#123; &quot;domain&quot;: null, &quot;_events&quot;: &#123;&#125;, &quot;_eventsCount&quot;: 0, &quot;_maxListeners&quot;: 0 &#125; &#125;, &quot;isNew&quot;: false, &quot;_doc&quot;: &#123; &quot;__v&quot;: 0, &quot;admin&quot;: true, &quot;password&quot;: &quot;12345678&quot;, &quot;name&quot;: &quot;andyyou&quot;, &quot;_id&quot;: &quot;575ce1a0dcb5450d1a720f9c&quot; &#125;, &quot;_pres&quot;: &#123; &quot;$__original_save&quot;: [ null, null ] &#125;, &quot;_posts&quot;: &#123; &quot;$__original_save&quot;: [] &#125;, &quot;iat&quot;: 1465731658, &quot;exp&quot;: 1465731778&#125; jwt-simple token sample 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJfaWQiOiI1NzVjZTFhMGRjYjU0NTBkMWE3MjBmOWMiLCJuYW1lIjoiYW5keXlvdSIsInBhc3N3b3JkIjoiMTIzNDU2NzgiLCJhZG1pbiI6dHJ1ZSwiX192IjowfQ.pZ3KHGGZwjgDryrLrAzKkfmTv4xJbekQGX3UCe8Fm1Q jwt-simple token 解析 payload 1234567&#123; &quot;_id&quot;: &quot;575ce1a0dcb5450d1a720f9c&quot;, &quot;name&quot;: &quot;andyyou&quot;, &quot;password&quot;: &quot;12345678&quot;, &quot;admin&quot;: true, &quot;__v&quot;: 0&#125; 小結透過上面的實作，我們對於 jwt 和如何實作有了基本的理解。 參考資料來源 The Ins and Outs of Token Based Authentication The Anatomy of a JSON Web Token Authenticate a Node.js API with JSON Web Tokens Build an App with Vue.js: From Authentication to Calling an API Session 介紹 使用 JWT OAuth 2.0 筆記 Postman 使用筆記","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"//andyyou.github.io/tags/nodejs/"},{"name":"jwt","slug":"jwt","permalink":"//andyyou.github.io/tags/jwt/"},{"name":"api","slug":"api","permalink":"//andyyou.github.io/tags/api/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"[譯] scroll-behavior 滑順的捲動效果","slug":"smooth-page-scroll","date":"2016-05-31T16:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/06/01/smooth-page-scroll/","link":"","permalink":"//andyyou.github.io/2016/06/01/smooth-page-scroll/","excerpt":"眾所皆知 HTML 錨點(anchor link)透過給定標籤 id 屬性跳到頁面上特定位置的功能。不過這個效果感覺上就像是閃一下就切換到該位置。為了使用體驗上的感覺有時候網站會設計一種平滑捲動到該位置的效果。 在過去這樣的效果通常會透過 jQuery 來達成，但有時候一些簡單的頁面為了達成這個功能就需要載入一堆函式庫或框架這未免有點矯枉過正。最新的 Javascript 提供了一個更有效率，加強原生 window.scrollTo 的方式。","text":"眾所皆知 HTML 錨點(anchor link)透過給定標籤 id 屬性跳到頁面上特定位置的功能。不過這個效果感覺上就像是閃一下就切換到該位置。為了使用體驗上的感覺有時候網站會設計一種平滑捲動到該位置的效果。 在過去這樣的效果通常會透過 jQuery 來達成，但有時候一些簡單的頁面為了達成這個功能就需要載入一堆函式庫或框架這未免有點矯枉過正。最新的 Javascript 提供了一個更有效率，加強原生 window.scrollTo 的方式。 一個標準的錨點已經是一個被廣泛使用的基本技巧: 透過這種方式就算新的 smooth scroll 滑順捲動的語法不被支援就的方法仍然會運作，就是跳到該位置。 123&lt;a href=\"#dest\"&gt;Click to somewhere&lt;/a&gt;...&lt;p id=\"dest\"&gt;This is the target&lt;/p&gt; 要注意的是頁面內容要超過可視區域就是至少 scroll bar 要出現，如果瀏覽器已經在畫面上顯示出兩者且沒得捲就沒有效果。因此我們需要在連結和錨點之間補上一些內容。 兩種方式由於 Smooth Scrolling API 有兩種，一種是 CSS, 一種則是 Javascript。也因此造成混亂的原因是部分瀏覽器有支援上不一致。 CSS 的方式非常簡單，只要在該元素設定 scroll-behavior: smooth; 123body &#123; scroll-behavior: smooth;&#125; 注意是 behavior 而不是 behaviour 這個方式非常方便不過目前只有 Firefox 支援，查閱 Can I Use。 Javascript然後是 Javascript 的方式 12345678var anchor = document.querySelector('a[href=\"#dest\"]')var target = document.getElementById('dest')anchor.addEventListener('click', function (e) &#123; if (window.scrollTo) &#123; e.preventDefault() window.scrollTo(&#123;'behavior': 'smooth', 'top': target.offsetTop&#125;) &#125;&#125;) 注意到 window.scrollTo 跟現有的 Javascript 在參數上有些不同，如果你直接用在 Chrome 下，您就會出現參數數量不對的錯誤，所以實務上要應用還是需要額外做些處理。 另外這種方式有一個缺點，那就是我們不能自訂 timing function。 延伸上面的 script 已經可以讓單一的錨點正常的運作，不過這種方式有點面對大量連結的時候有點麻煩。假如我們在這個頁面有幾個錨點都要這功能，那麼我們可以簡單的實作如下。 1234567891011121314151617181920var applyScrolling = function (arr, cb) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; cb.call(null, i, arr[i]) &#125;&#125;// 注意如果有使用 router 那麼自訂一個 class 可以避免一些問題var anchors = document.querySelectorAll(\"a[href^='#']\")if (window.scrollTo) &#123; applyScrolling(anchors, function (index, el) &#123; var target = document.getElementById(el.getAttribute('href').substring(1)) el.addEventListener('click', function (e) &#123; console.log(target) e.preventDefault() // 這邊跟新的 method 參數是不同的。 window.scrollTo(0, target.offsetTop) &#125;) &#125;)&#125; 譯者小結目前在 Firefox 下兩種方式都可以使用，而 Chrome 則需要額外的開啟設定。本文就是先記錄一下這些新的屬性與 API。 參考 Smooth Page Scroll in 5 Lines of JavaScript","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"手把手深入理解 webpack dev middleware 原理與相關 plugins","slug":"webpack-dev-middleware-in-express","date":"2016-05-30T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/05/30/webpack-dev-middleware-in-express/","link":"","permalink":"//andyyou.github.io/2016/05/30/webpack-dev-middleware-in-express/","excerpt":"本文將對 webpack 周邊的 middleware 與 plugin 套件等作些介紹，若您對於 webpack 還不了解可以參考這篇彙整的翻譯","text":"本文將對 webpack 周邊的 middleware 與 plugin 套件等作些介紹，若您對於 webpack 還不了解可以參考這篇彙整的翻譯 webpack dev server 是什麼?webpack dev server 是一個開發伺服器，內建 webpack 使用的 live reloading 功能。 那 webpack dev middleware 是啥?它就是一個用來組織包裝 webpack 使其可以變成中介軟體，或稱中間件的容器。回想一下 express 你大概可以明白關於 middleware 的用途，就是在輸入到輸出的過程中 加工 的一種手段。單純說 middleware 的話我們可以想成一系列任務, 動作(actions stack)，不只 express 有，在 Ruby 中的 rake 也具備這種機制。 先看看web dev server的說明 The webpack-dev-server is a little node.js Express server, which uses the webpack-dev-middleware to serve a webpack bundle. 從頭說起的話就是 webpack 本身只負責打包編譯的功能 bundle, webpack-dev-server 當然就是協助我們開發的伺服器，這個伺服器底層是靠 express 來實作的，接著思考一下我們要如何更新(live reload)呢? 當然是需要取得 webpack 編好的資料啊，於是就需要在從 request 到 response 的過程中透過 express 的 middleware 取得資料，而方法就是透過 webpack-dev-middleware 。 比起直接編譯成檔案，webpack-dev-middleware 這個套件還多了一些好處: 不需要一直寫入磁碟，所有產生的結果會直接存在記憶體 在監視模式(watch mode)下如果檔案發生異動，middleware 會馬上停止提供舊版的 bundle 並且會延遲請求的回應直到編譯完成，如此一來我們就不需要去觀察編譯是否結束了 webpack hot middleware 是什麼?我們都知道 webpack dev server 有提供一種Hot Module Replacement/Hot Reloading 熱替換的功能。在一般 webpack-dev-server 的時候我們會在 webpack.config.js 加入 new webpack.HotModuleReplacementPlugin() 或設定來啟用。而 webpack hot middleware 是給 webpack-dev-middleware 用的。就是讓我們在一般的 server 上加上熱替換的功能，總結來說就是 webpack-dev-middleware + webpack-hot-middleware 即可讓我們用 express 客製一個有熱替換功能的 webpack 開發伺服器。 使用 webpack-dev-server 當中介軟體webpack 提供了 express 的 middleware 讓我們可以處理一些靜態資源檔而不是使用 express.static。要達成這項功能，我們需要安裝 webpack-dev-middleware 和 webpack-hot-middleware 1$ npm i webpack express webpack-dev-middleware webpack-hot-middleware -D 安裝完成套件之後，首先我們需要設定一個 webpack.dev.config.js 檔案，並且在 entry 中加上 webpack/hot/dev-server 和 webpack-hot-middleware/client 12345entry: [ &apos;webpack/hot/dev-server&apos;, &apos;webpack-hot-middleware/client&apos;, &apos;client/index.js&apos;] 這個 webpack.config 主要是給開發伺服器用的，由於這時的匯出都會存在記憶體中，因此 path 可以直接設為根 12345output: &#123; path: &apos;/&apos;, publicPath: &apos;http://localhost:8080/scripts/&apos;, filename: &apos;bundle.js&apos;&#125; 最後補上任何您所需要的 loaders，最重要的是記得。 123plugins: [ new webpack.HotModuleReplacementPlugin()] 接著下來我們開始來撰寫這個開發環境的設定檔和 express 程式。我們會匯入 webpack，webpack-dev-middleware， webpack-hot-middleware 和 express。 若需要搭配樣板引擎請自行安裝 ejs 或 jade 1234var express = require('express')var webpack = require('webpack')var WebpackDevMiddleware = require('webpack-dev-middleware')var WebpackHotMiddleware = require('webpack-hot-middleware') 載入套件之後，使用 express 建立一個 http 應用程式與路由 12345app = express()router = express.Router()router.get('/', MainController)app.use(router) 上面只是一個一般的 Server 應用，為了達成 webpack 的神奇黑魔法我們需要匯入 webpack 的設定 1var config = require(&apos;./webpack.dev.config&apos;) webpack 的角色就是我們的編譯器，透過下面的程式碼建立編譯器的 instance 1var compiler = webpack(config) 重點來了，我們有了伺服器 express，有了編譯核心 webpack，接著我們需要 wrapper 來打包 webpack 將其合進 express 的 middleware stack 中。 1234app.use(WebpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath, stats: &#123; colors: true &#125;&#125;)) publicPath 就是我們想要存取前端 bundle 的網址，路徑，位置。然後我們要再加上 webpack-hot-middleware 使其具備熱替換的功能。 123app.use(WebpackHotMiddleware(compiler, &#123; log: console.log&#125;)) 最後則是 express 的監聽事件 123app.listen(8080, function () &#123; console.log('Listening on 8080')&#125;) 完整的 server 程式碼如下 123456789101112131415161718192021222324252627var express = require('express')var webpack = require('webpack')var WebpackDevMiddleware = require('webpack-dev-middleware')var WebpackHotMiddleware = require('webpack-hot-middleware')var config = require('./config/webpack.dev.config')var compiler = webpack(config)app = express()app.set('views', './views')app.set('view engine', 'ejs')app.use(express.static('public'));app.use(WebpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath, stats: &#123; colors: true &#125;&#125;))app.use(WebpackHotMiddleware(compiler))var router = express.Router()router.get('/', function (req, res, next) &#123; res.render('index', &#123; message: 'Hey there!'&#125;);&#125;)app.use(router)app.listen(8080, function () &#123; console.log('Listening on 8080')&#125;) 換個思路假設我們並不是要實作一個全站 SPA 的站，實務上我們的確會遇到需要拆分為許多 view .html 的狀況，這種情況下我們會希望自己客製的這個 server 就像 webpack-dev-server 一樣，當然，這邊只是要指出做法，如果一樣您當然就直接用 webpack-dev-server 就好了。 根據上面這個需求最簡單的方式就是透過 express.static(__dirname) 讓 express 直接 return raw 檔案。 html-webpack-plugin小弟認為在學習的過程中，最重要的就是搞懂動機，而這個 html-webpack-plugin 插件，其用途就是簡化建立 html 的過程。先回頭看看上一小節，很直覺的，我們會依據需求建立不同的頁面(.html)，因為在開發過程中很多時候前端只需要注重那些互動介面的邏輯，樣式，樣板，標籤結構 ，那我們的重點只有 client 端的 html, js, css 就不在話下了吧！再如果我們又以元件為思路中心來設計實踐的話，那麼 html 裡面大部分的東西都會往元件的 template 搬。依據 SPA 的思路，html 的責任就只是把我們的 bundle 載入並掛載 root component。 如果照著這樣的想法，不斷的新增 html 結果大部分的內容都是重複的那就不太靠譜啦。我們就需要一種簡化工作的方式。 這個套件如上面所說就是簡化建立載入 bundle 的 html的步驟，用在 webpack 打包的檔案包含每次編譯都會更新的 hash 時特方便。我們可以讓套件幫我們產生 html 或者搭配 loaders 與其他樣版引擎。 基本的用法第一種最簡單的用途就是為我們的 bundle 包上一層 html 12345plugins: [ new HtmlWebpackPlugin(&#123; filename: &apos;i_love_this_file.html&apos; &#125;)] 如果我們有多個 entry 進入點，那麼所有的 bundle 都會被加進這個自動產生的 HTML 中。如果我們透過 webpack 匯出了 css 資源檔(例如 extract-text-plugin) 那麼這些檔案也會透過 &lt;link&gt; 被加入 HTML 中。 html-webpack-plugin 的設定當然這個套件也有一些參數，讓我們可以透過設定提供其他的功能。 title: 設定該 html 的 &lt;title&gt; 標籤 filename: html 檔名，也當作路徑存取。預設是 index.html template: 樣板的路徑，也就是說我們可以先組織 HTML 在載入讓 html-webpack-plugin 幫我們注入(inject) bundle。此部分要注意相對路徑是從 server 程式檔案出發。 inject: 將所有的資源檔注入 template 或 templateContent，當值是 true, &#39;body&#39; 的時候所有的 js 資源檔都會被注入 &lt;/body&gt; 之前，&#39;head&#39; 則是 &lt;head&gt; 之間，false 自然就是關閉 true: Boolean false: Boolean head: String body: String favicon: 替 HTML 加上 favicon 路徑 minify: 傳入 html-minifier 參數物件，壓縮輸出。 options: Object false: Boolean hash: true 時替 webpack 編譯的檔案或結果路徑結尾補上 hash，這麼做的用意是在開發時期當檔案有異動時可以避免瀏覽器快取 true: Boolean false: Boolean cache: 預設是 true 快取檔案，除非檔案有異動 true: Boolean false: Boolean showErrors: 預設 true 例外或錯誤資訊會寫入 html 頁面 true: Boolean false: Boolean chunks: 允許我們加入一些程式碼片段，例如單元測試 chunksSortMode: 控制 chunks 排序 none: String auto: String dependency: String {}: Function excludeChunks: 略過部分 chunk 程式碼片段 xhtml: 設定為 true 的話 link 標籤會是 self-closing ，預設是 false true: Boolean false: Boolean 腦力激盪 - 如果要多個頁面搭配各自的 bundle?webapck 難就難在其靈活之中伴隨著複雜，不同的思路有著不同的做法。這一小節目的是為了不讓我們對 webpack 使用上僵化而提出的一個小題目。 要達成這個需求，我們可以先使用 webpack.config 中 [name] 的功能拆分我們的 bundle 12345678910&#123; entry: &#123; a: &apos;./path/src/a&apos;, b: &apos;./path/src/b&apos;, c: &apos;./path/src/c&apos; &#125;, output: &#123; filename: &apos;[name].bundle.js&apos; &#125;&#125; 接著透過 html-webpack-plugin 的參數，把 inject: false 然後 template 在各自的 template 中使用 bundle。 html-webpack-template - 更牛的方式照著上面的方式你可能又跟我抱怨，那不是又要產一堆 HTML 了嗎? 對啊！原本這個架構就是針對 SPA 設計的嘛。不過透過這樣來來回回的思考動機與流程我相信對於您日後使用 webpack 與閱讀設定有很大的幫助。現在的問題是 - 你覺得產一大堆 HTML 不是很靠譜，於是我們就有了 html-webpack-template 的產生啦 這個東西大略的用法就是 123456789101112131415161718192021plugins: [ new HtmlWebpackPlugin(&#123; title: 'Sample', filename: 'sample.html' &#125;), new HtmlWebpackPlugin(&#123; inject: false, // 必須 template: require('html-webpack-template'), // 必須 filename: 'sp.html', // 存取的路徑 // 只需要特定 bundle 可以這樣設定 chunks: ['vender'], title: 'OH My Gosh', // 可以參考 html-webpack-template 的參數設定 // 下面為提供 GA googleAnalytics: &#123; trackingId: 'UA-XXXX-XX', pageViewOnLoad: true &#125; &#125;)] html-webpack-plugin 事件特地介紹此套件的事件也是因為挺有可能會需要一些時間點對 html 動些手腳，有了事件的機制我們就可以讓其他套件修改產生的 html 非同步事件: html-webpack-plugin-before-html-generation html-webpack-plugin-before-html-processing html-webpack-plugin-after-html-processing html-webpack-plugin-after-emit 同步事件: html-webpack-plugin-alter-chunks 大略的用法就是在透過 hook event 綁定的事件做些處理 12345678compiler.plugin('compilation', function(compilation) &#123; console.log('The compiler is starting a new compilation...'); compilation.plugin('html-webpack-plugin-before-html-processing', function(htmlPluginData, callback) &#123; htmlPluginData.html += 'The magic footer'; callback(null, htmlPluginData); &#125;);&#125;); webpack-hot-middlewarewebpack-hot-middleware 這個套件只能搭配 webpack-dev-middleware 使用，其實就是把熱替換的功能加到一般 server 應用。這個模組只專注在處理 webpack 和瀏覽器溝通的機制。這個中介軟體會去訂閱監聽開發伺服器，當更新或異動發生的時候它就透過 webpack 的 HMR API 來更新。實際上讓您的程式能無縫的使用熱替換已超過本文範圍，在這部分通常會靠其他模組來處理。 安裝完套件與在伺服器 app 中套用之外，要記得 webpack.config 的 plugin 也要加上 HotModuleReplacementPlugin 12345678plugins: [ // Webpack 1.0 new webpack.optimize.OccurenceOrderPlugin(), // Webpack 2.0 fixed this mispelling // new webpack.optimize.OccurrenceOrderPlugin(), new webpack.HotModuleReplacementPlugin(), new webpack.NoErrorsPlugin()] 簡短地介紹一下 OccurrenceOrderPlugin 部份，您應該知道 webapck 會給編譯好的程式碼片段一個 id 以用來辨別。透過上面的這個 plugin 可以讓 webpack 在 id 的分派上優化並保持一致性。 接著要在 entry point 加上 webpack-hot-middleware/client 這隻檔案會連到 server 目的是當 server 重新編譯好檔案時收到通知然後更新 client 的檔案。 如何撰寫 plugin為什麼要了解怎麼寫 plugin 呢? 因為某些 plugin 可以擴展支援其他 plugin 相互傳遞資料或需要客製後續任務，所以稍微明白 plugin 的寫法可以讓我們對於 plugin 的設定更加清楚。 plugin 的架構設計促使第三方開發者讓 webpack 核心發揮出無限的潛力。在不同建置階段執行 callback ，開發者可以自訂出特有的行為。當然建置 plugin 比起開發 loader 是較進階的議題，因為我們必須要理解 webpack 內部的一些 hook 事件 編譯器與編譯結果要開發 plugin 第一步就是先了解其中最重要的兩個角色 compiler 和 compilation 物件 compiler 編譯器物件代表一個完整設定的 webpack 環境。這個物件在 webpack 發動之後就會被建置，而且只會建置一次。然後它會配置所有可以操作的設定包含 loaders, plugins。當我們套用一個 plugin 這個 plugin 會收到 compiler 的參考透過存取這個參考 reference就可以取得 webpack 環境 compilation 編譯成果這個物件代表的是某個版本的編譯後的資源檔，在運行 webpack dev middleware 期間每當檔案發生異動就會產生一個新的 compilation 也就是產生新的編譯結果。這個編譯結果包含的訊息包含 module 模組的狀態，編譯後的資源檔，發生異動的檔案，被觀察的相依套件等。這個編譯結果物件也提供一些執行 callback 的機會讓我們可以在過程中客製一些自己想要的行為。 任何 webpack plugin 都必須依靠這兩者來完成，所以有需要對其原始碼有些大概的了解 Compiler Source Compilation Source 基本 plugin 架構本質上來說 plugin 只是一個物件實例具有 apply 方法，這個 apply 會在安裝時期被 webpack compiler 執行一次。透過這一次的執行呢我們就可以繫結許多事件，直接來看看程式碼您就明白了。 1234567891011121314151617181920function MyPlugin(options) &#123; // 設定參數 this.options = options&#125;MyPlugin.prototype.apply = function(compiler) &#123; compiler.plugin('done', function() &#123; // 當 plugin 安裝完成就會... console.log('Hello World!'); &#125;) // 我們自然需要拿到編譯的結果 compiler.plugin(\"compilation\", function(compilation) &#123; console.log(compilation.assets) compilation.plugin(\"optimize\", function() &#123; console.log(\"Assets are being optimized.\"); &#125;); &#125;);&#125; OK! 我們現在並不是要開發套件所以點到這邊我想就足夠了，剩下的您可以自行參考相關文件。 text.forEach is not a function 詳細 plugin API extract-text-webpack-plugin顧名思義這個 plugin 的用途就是把 text 類型的結果匯出成一個檔案，先說這不是非常精確的描述，但概念來說 text 類型指的就是不會輸出成 module.exports 或 json 的資料。而像是 CSS 這類的資源檔 webpack 其實最終就是在 JS 中幫我們建個 style tag 的 dom 然後整包放進去。file-loader, raw-loader 等等這類內容大略就屬於 text 類型。查閱各種 loaders 回傳資料類型 於是乎以 entry point 為單位過程中解析的 text 內容就會被抽出來匯出成一個檔案。最常見的用法就是把 css 抽出來: 12345678910111213var ExtractTextPlugin = require(\"extract-text-webpack-plugin\")module.exports = &#123; module: &#123; loaders: [ &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(\"style\", \"css\") &#125; ] &#125;, plugins: [ // 注意: 這邊的副檔名如果亂下是會造成瀏覽器行為不符合預期的，例如不給副檔名那瀏覽器就會當作 binary 下載 new ExtractTextPlugin(\"styles.css\") ]&#125; 如果想要拆分多個檔案，那麼就先初始化 instance 12345678910111213141516171819let ExtractTextPlugin = require('extract-text-webpack-plugin');// multiple extract instanceslet cssExtractor = new ExtractTextPlugin('stylesheets/[name].css');let lessExtractor = new ExtractTextPlugin('stylesheets/[name].less');module.exports = &#123; module: &#123; loaders: [ &#123;test: /\\.scss$/i, loader: cssExtractor.extract(['css','sass'])&#125;, &#123;test: /\\.less$/i, loader: lessExtractor.extract(['css','less'])&#125;, ... ] &#125;, plugins: [ cssExtractor, lessExtractor ]&#125; HMR 熱替換Hot Module Replacement (HRM) 又稱熱替換，功能就是在程式運行中交換，移除，增加模組且不會使頁面重新載入。這跟我們伺服器的熱插拔差不多概念。 它是怎麼運作的?webpack 在 bundle 中即我們的 js 裡加入了一個小型的 HMR 執行環境，在編譯過程中這個 runtime 會在我們的 app 中運行。當建置完成時 webpack 也不會消失反而會持續存在，繼續監控原始碼檔案是否發生修改。一旦 webpack 發現程式有改變他就會去重新編譯那些有修改的模組，不全部重建。根據設定要嘛就是 webpack 把訊號丟給 HRM runtime 要嘛就是 HRM 自己更新異動資訊。不管哪種方式反正重點就是 HRM runtime 會取得修改的模組，接著就試著在運行的狀態下更新模組。首先會先檢查更新的模組是否能 self-accept。 關於 self-accept 先看看範例和原始碼，意思是要支援熱替換的模組或說編譯結果基本上是應該要實作 module.hot.accept 和遵循其他熱替換的規則。如果沒有辦法自己確認自己可以直接被更新，那就往上傳，通知那些 require 匯入使用自己的模組更新，就這樣層層往上。直到有人可以 accept 或到頂，不過一旦到根就表示熱替換失敗。 讀到這邊你可能通了，為什麼當我們要讓 React 支援 Hot Mode 的時候需要一個 react-hot-loader。以及因為要和 HRM 執行環境溝通的關係我們需要在 bundle 的 entry point 加上 webpack/hot/dev-server, webpack-hot-middleware/client 之類的東西。 從 App 的角度 當 App 程式開始執行(就是載入 bundle) HMR runtime 執行環境就會啟用，接下來程式就會要求 HMR runtime 幫我們檢查是否需要更新。HMR 會幫我們下載更新然後通知 App 程式有哪些更新可用。 從編譯器(webpack/compiler)的角度除了一般的資源檔像是圖片，css，編譯器還需要觸發更新事件讓程式碼可以完成新舊替換。這個”更新”包含兩個部分 更新的 Manifest 支援配置文件(json) 一或多個更新的chunks程式片段(js) 支援配置文件包含更新後編譯結果的 hash 和新的 chunks 程式碼片段的列表。而新的 chunks 則包含更新後模組的程式碼或 flag編譯器同時也會確保模組和片段 ID 是一致的，透過一個 records 的 json 檔案來儲存相關資訊。 從模組角度HMR 是選擇性的功能，所以只有在模組包含 HRM 程式碼才會被影響作用。也就是在模組中使用文件有提供的 API。一般來說模組的開發者 handler 會在模組相依的部分更新時被執行。當然也可以寫一個 handler 在這個模組更新時被呼叫。在大部分的情況並不需要為每一個模組都撰寫支援 HMR 的程式碼，當一個模組沒有遵循處理規則時就會往上層傳遞事件，意味著只有上方有一個 handler 可以處理就好，但不要讓這個冒泡事件一路冒到頂喔。 從 HMR runtime 角度模組系統的執行環境其實是額外加入的程式，用來追蹤模組之間的父子關係。 123if(module.hot) &#123; ...&#125; 從管理的角度，這個執行環境 runtime 支援 check 和 apply 兩個方法。check 的功能是發出 HTTP request 用來取得上面提到的 Manifest，當 request 失敗時就等於沒有任何更新。否則就會依照得到的更新列表去比對 chunks。對每個已載入的 chunk 都會有對應更新的程式碼要被下載。所有模組更新會被存在 runtime 中準備拿來更新。當執行環境切換成 ready 狀態就表示更新的程式碼都被下載完成了隨時可以套用。 接著 apply 方法會將所有已更新的模組的 flag 標記為 invalid 無效，然後無效的模組需要 update 的 handler 處理函式，這個 handler 會在模組中或者父節點上。只要沒有這個 handler 就會持續往上曾傳遞並標註為 invalid，一旦冒泡機制冒到頂端即 entry point 就表示熱替換失敗。 所有被標記為無效的模組都會透過 module.hot.dispose 卸載，然後更新 hash，再來所有 module.hot.accept 的 handlers 會被調用。執行環境切回 idle 狀態表示所有更新都完成了。 講這麼多其實簡單來說就是我們的模組要補一些 hot mode 的邏輯 123456789101112var app = require(\"./app\");// 模擬每 5 秒更新一次setInterval(function() &#123; console.log(app(new Date()));&#125;, 5000);if(module.hot) &#123; module.hot.accept(\"./app\", function() &#123; app = require(\"./app\"); &#125;);&#125; 檔案的更新流程左邊表示初始化時編譯器產生的結構，右邊則是當模組 4 和 9 更新時的流程。方塊表示從 Entry 開始，webpack 幫我們編譯產生的部份從 Entry 然後轉換成 Chunk 0 - 4 資源參考 html-webpack-plugin webpack dev middleware 說明","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"//andyyou.github.io/tags/webpack/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"響應式設計中百分比 % 的問題","slug":"responsive-design-dirty-secret","date":"2016-05-20T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/05/20/responsive-design-dirty-secret/","link":"","permalink":"//andyyou.github.io/2016/05/20/responsive-design-dirty-secret/","excerpt":"","text":"問題為了要能夠解釋得更清楚我們需要實作一小段跟我們會遇到的問題相關的程式碼 1234.list-item &#123; float: left; width: 33%;&#125; 現在您可能會想知道關於上面這段程式碼有什麼問題，看起來這樣並不明顯，好！假設這是一個三欄(column)的網格，就算你知道 33% + 33% + 33% = 99% 並不是 100%。但在大多數的情況下並不會有什麼問題，不過這誤差的 1% 如果遇到容器像是 1400px 時就是 14px，那就是一個蠻大的誤差了。那為什麼我們不直接調整百分比的精度呢? 我們是可以將它降低到 1.4px 甚至是 0.14px 那麼一來就不會有問題啦 1234.list-item &#123; float: left; width: 33.33%;&#125; 實際上…關於流質網格(Fluid Grid)破版的問題，…其實就只是誤差造成縫隙或偏移。所謂響應式設計(RWD)依照 Ethan Marcotte 所定義: 就是流質網格，響應式圖片，加上 Media Query 所構成。但關於流質網格卻有一個比較麻煩的問題，就是計算捨入的部分是錯誤的。當我們使用百分比設定欄位時，瀏覽器必須要根據螢幕，viewport 及可視區域將其轉換為實際的像素(pixel)。在這個轉換的過程中 Chrome, Safari, Opera 等瀏覽器全部產出錯誤的值。 Fluid：英文為液態，液體，流質定義為一種物質可持續性的改變形狀以適應周圍的壓力或容器流質網格：網格尺寸會根據父元素尺寸自動調整，簡單說即我們定義最外圍的尺寸後就像液體一樣格子會自動變形去適應尺寸 所謂的錯誤主要是因為這是需要被定義在 CSS 規範的問題。但由於 CSS 並沒有規範瀏覽器對於百分比計算精度應該要到小數第幾位，舉例來說如果 6 個欄位的網格 100% ÷ 6 = 16.666667%，那麼在一個 1000px 的可視區域 viewport 中一欄(column)的寬就是 166.66667px，但因為沒有規範，所以瀏覽器廠商各自使用自己的規則，如果瀏覽器使用四捨五入那麼在我們這個範例我們就會得到 167px 結果就是 167 x 6 = 1002 就會超出 viewport 範圍。如果捨去變成 166px 那最終我們會少 4px。 IE6 7 採用前者就是進位，這也意味著常常會超出我們想要的尺寸，WebKit 採用後者以避免破版，Opera 甚至直接在百分比動手腳把 16.66667% 直接換成 16%，結果就是一個欄位(column)的寬跟我們要的整整誤差 6px。好！在你開始罵這些開發商之前，請先想想這是因為 CSS 規範沒有定義規則啊！ 更糟糕的狀況？不幸的是，如果您同時也使用百分比來設定這些間隔(gutters)尺寸如 pedding 之類的，那麼這問題真的會非常糟糕。過去(約 2012 年)大部分佈局的方式都是採用 float 的方式，即網格中格子位置必須仰賴大量計算來完成。假設我們有一列 12 欄的網格透過百分比設定 width, margin, padding，那麼第 12 欄的位置需要前面 11 欄的 padding, margin, width 來計算，也就是說包含自己在內會有 56 次機會計算產生誤差2(padding) + 2(margin) + 1(width) = 5; 11 * 5 + 1(margin itself) = 56，假如每一次計算都誤差 1px 那麼就會有 56px 的誤差。 在你知道這點之後也就不奇怪為什麼 mediaqueri.es 網站上這麼多設計都沒有凸顯區塊邊緣的設計，因為如此一來就這個計算的誤差就比較不明顯一點。 您可以檢視範例來看看各個瀏覽器誤差的情況 那有什麼辦法?首先，我得先對那些自適應(adaptive)網頁設計的提倡者說，我明白你看到這邊非常開心。的確! 採用自適應的方法能良好的運作，因為 Adaptive Web Design 預先對 viewport 尺寸定義然後當遇到那些不符合的尺寸時則採用小一級例如：預先設計了 1024 和 960 寬的 viewport 如果遇到 1000 就採用 960 的設計。因為不使用流質網格所以完全避開了關於百分比誤差的問題。但這裡並不是要說 AWD 就是比較好的做法，只是稍微提一下採用 AWD 的話不會遇到這個問題。 響應式(Responsive) vs 自適應(Adaptive) 響應式和自適應設計共同點; 都是要處理在不同裝置下瀏覽網頁的問題，可讀性，版型等等。 最大的部分在於 RWD 是透過 Fluid Grid 和元素使其自動符合視窗或父元素尺寸，而自適應 AWD 則是預先定義可視區域的尺寸然後透過 JS CSS 等方式去套用版型樣式 最佳解決方案您可能注意到我剛剛並沒有提到 Firefox 計算的問題。Firefox 實作了一個較為先進的方式稱為 sub-pixel 渲染取代捨入計算的方式，Firefox 會替所有 CSS 屬性保留 sub-pixel 值，當元素的位置需要相依其他元素時就會把 sub-pixel 拿出來計算。這個效果相對接近設計師的期望。 IE8 也採用了 sub-pixel 顯然是為了補救 IE7 非常糟糕的計算方式。WebKit 與 Opera 以及那些使用捨去值策略的瀏覽器還沒有採用 sub-pixel 的方式。 而其中一個解決方式就是我們可以等到所有瀏覽器都採取 sub-pixel 的方式渲染，不過這可能需要等待非常久的時間。這篇文章試圖要找出解決方案而不是被動的等待，幸運的是下面有一些方式是我們今天可以採用的。 關於 CSS3 Flexbox?由於我們仍會在 Flexbox 的設計中使用百分比，如此一來或多或少還是會受到進位誤差的影響，因此 Flexbox 並不是佈局的萬能藥。 盡可能移除使用百分比的部分首先，我們必須要認同將所有佈局 Layout 每個屬性例如間隔的 padding 等都用百分比處理只是那些龜毛，強迫症開發者的樂趣，我們並不需要完全採用百分比。 第一個問題是因為在 CSS2 時盒子模型(Box model)中 padding 和 border 並不包含在元素寬內，意思是如果我們設定一個元素的寬為百分比，我們也必須使用百分比去設定 padding margin，否則計算上一定會出現不符合 100% 的狀況，但如果把 box-model 換成 box-sizing: border-box ，padding 和 border 就會包含在 width 裡，意思是我們就不需要在被迫在這些屬性上使用百分比，就可以使用固定的值 em, rem, px 等。針對網格邊界之間的間隔空間比較好的做法是使用 padding 而不是 margin。所有內容與間隔都套用保持一致比例，這樣一來比起當要顯示出邊界的樣式時才個別因為對齊的關係加上容器元素(wrapper)，前者的優點大於後者。 所以結論就是當使用 border-box 時，間距的部分 margin padding 就不會再遇到數學計算捨入的誤差問題。但在 width 方面仍然會有這個問題，不過以 12 欄來說我們把最大誤差從 56px 降低到 11px 。雖然很不錯了，但對使用者來說還是會被注意到這樣的瑕疵。 不讓捨入誤差累加捨入誤差真正的問題是因為在設計佈局時這些誤差常常是會累加的，為了要取得一個格子的左邊界定位我們必須要依賴前面同層的格子來計算，因為 float 需要依據上一個元素來排位置。那假如我們有辦法直接指定左邊界呢? 就是說如果可以就直接設定從父元素左邊界到本身的距離，然後其他元素遵循一樣 float 的排版呢? 事實證明是可以這樣做的。大約從 2004 年這個技術就已經被使用了稱為 container relative floats，這也是 Drupal 的 Zen 樣板使用的核心技術。雖然乍看之下這招不怎麼高明，但事實證明這個做法還蠻牢靠的。這個方法主要是透過在每個網格套用下面的 CSS 12float: left;margin-right: -100%; 接著每一個格子設定 margin-left 值是從父容器左邊界到其定位的距離。下面是一個簡單的範例 123456789101112131415161718.item1 &#123; float: left; width 40%; margin-left: 0; margin-right: -100%;&#125;.item2 &#123; float: left; width: 40%; margin-left: 40%; margin-right: -100%;&#125;.item3 &#123; float: left; width: 20%; margin-left: 80%; margin-right: -100%;&#125; 注意您也可以反過來設定網格對應右邊界的距離 float: right 然後 margin-left: -100%;。不過這個原理到底是啥？首先思考一下 margin-right: -100% 這個 -100% 就是外層容器的寬，接著再想想一個 float 元素 的 margin-right 是會影響緊鄰地下一個 float 元素，假如我們設定 margin-right: -10px 那麼它右邊的元素(格子)就會從原本的位置往左偏移 10px 就是減 10px。 邏輯上 -100% 意味著下一個元素應該要偏移減去容器寬的距離，不過有個重點就是如果減掉過大的值讓元素超過父容器邊界時結果並不會超出左邊界。簡言之就是 float 元素在排列位置時不用在管前面元素右邊界的位置(原本是從上一個元素的右邊界開始計算，現在不是)，只要看自己和父容器左邊界的距離就好。 試試這個範例 如果你對這個做法有一種好像 absolute 定位的感覺，覺得很不可靠，那是因為你應該沒注意到關鍵的不同點，absolute 的方式會使元素完全脫離文件排版的一個規則順序之中，且 absolute 不會影響周圍其他元素的位置，但 container-relative 的設定是可以透過 clear 移除的。這是關鍵，因為當 float 項目搭配這樣的用法就可以無視其他元素的右邊界位置，但設定 clear 時下邊界仍可以產生影響換行。這表示我們可以透過設定上一個網格或項目 clear 來換行產生新 row ，這是 absolute 辦不到的。 由於我們的網格不再被其他周圍的兄弟元素影響，我們就不再受到 HTML tag 的順序限制。如此一來我們就可以很簡單地把 HTML 中排序的第一個元素放到列的中間或者隨意把 row 中的網格任意調整位置順序。 但是這麼做我們還是沒有完全修好誤差的問題！不過我們已經減少定位相關的計算過程，現在只剩一個值就是和父元素的距離。不過這個值仍然受到捨入誤差的影響，也就是或多或少還是會遇到 1px 的誤差。不過幸運的是因為大部分的網站使用者並沒有強迫症，這樣微小的誤差並不太容易被注意到。 如果內容本身是有質量的使用者不會特別去注意那 1px 設計上的誤差，不過還有一個替代的解決方案可以幫助我們實作甚至減少這 1px 的誤差。 真的可以處理 1px 的誤差？如果您的網格 float 是往左靠，因為所有的元素都是向左對齊，所以最可能的狀況那 1px 的誤差都會顯示在最右邊的那格。即便所有列 row都對齊，這 1px 也蠻容易被發現，但如果我們把這些很明顯的地方換成對齊右邊，如此一來誤差的 1px 會被放到頁面的中間就比較不會被注意到。 使用 Zen Grids關於為什麼需要使用 CSS 預編譯器實作 RWD，那是因為例如使用 Sass 可以簡化一些我們需要的設計同時處理那些用純 CSS 會比較為複雜的地方。那麼 Zen Grids 是如何處理關於捨入誤差呢？透過使用 Zen Grids 預設就透過 border-box 來處理網格的間隔搭配 container-relative 方式，提供一些輔助方法(Methods)讓我們可以簡單的改變對齊的方向。 使用 Sass 與 calc() 處理除了 Zen Grids 的做法，透過 Sass 我們還有一些簡單的方式可以協助我們 使用除法1234567891011.list-item &#123; float: left; width: (100%/3);&#125;// or.list-item &#123; float: left; width: percentage(1/3);&#125; 透過這兩種方式 Sass 會自動幫我們把精度輸出到小數以下第五位，雖然沒有完全解決問題但是有幫助的。 使用 CSS 的 calc()現在最新的做法則是使用 calc() 這麼做是把問題交還給瀏覽器去處理，而對於那些還沒支援的瀏覽器則交給 Sass 12345.list-item &#123; float: left; width: (100% / 3); width: calc(100%/3);&#125; 結論 使用 Sass 計算方式 e.g 100%/3 使用 calc(100%/3) float 的情況下用 border-box 搭配 padding 以及 margin-right: -100% Container relative float 技術，將誤差往中間移 資源 Responsive Design’s Dirty Little Secret A Tale of CSS and Sass Precision","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"requestAnimationFrame 筆記","slug":"using-request-animation-frame","date":"2016-05-12T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/05/12/using-request-animation-frame/","link":"","permalink":"//andyyou.github.io/2016/05/12/using-request-animation-frame/","excerpt":"在 Javascript 我們曾經只有一種方式來處理跟特定時間有關的循環事件: setInterval()。簡單說就是當你需要重複某些任務時(依據時間)。您就會用到這個方法。對於動畫來說需要每秒 60 個 frames 人類才會覺得是順暢平滑的，因此我們可能會寫出像下面這樣的程式碼","text":"在 Javascript 我們曾經只有一種方式來處理跟特定時間有關的循環事件: setInterval()。簡單說就是當你需要重複某些任務時(依據時間)。您就會用到這個方法。對於動畫來說需要每秒 60 個 frames 人類才會覺得是順暢平滑的，因此我們可能會寫出像下面這樣的程式碼 123setInterval(function () &#123;&#125;, 1000/60) 除了這個方式，還有另外一種方式就是使用 requestAnimationFrame ，當然這個東西已經出現很久了，不過在這之前，大多的時候我都不需要自己造輪子，也不太有機會需要對於動畫有深入的處理。因為自己開發一些輪子的需求所以這篇文章會了解一些關於 requestAnimationFrame 的基本用法。 簡單說使用 requestAnimationFrame 有下面幾點好處 瀏覽器可以優化，讓動畫更平滑順暢 該暫停的動畫不會繼續使用 CPU 省電 最簡單的範例12345function repeatOften () &#123; requestAnimationFrame(repeatOften)&#125;requestAnimationFrame(repeatOften) 啟動/停止requestAnimationFrame 會回傳一個 ID 我們可以用這個 ID 來取消它，就類似 setTimeout, setInterval。下面我們用 jQuery 簡單的展示一個範例 1234567891011121314var globalID;function repeatOften () &#123; $('&lt;div /&gt;').appendTo('body'); globalID = requestAnimationFrame(repeatOften);&#125;$(\"#start\").on(\"click\", function() &#123; globalID = requestAnimationFrame(repeatOften);&#125;);$(\"#stop\").on(\"click\", function() &#123; cancelAnimationFrame(globalID);&#125;); 參考 polyfill CSS-Tricks","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"CSS Grid 介紹","slug":"css-grid","date":"2016-05-04T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/05/04/css-grid/","link":"","permalink":"//andyyou.github.io/2016/05/04/css-grid/","excerpt":"當我們要建置複雜的網站時 Grids 是非常重要的。其重要性我們可以從大量的 CSS 框架中窺知ㄧ二，因為幾乎所有的框架都有提供網格(Grids)系統來加速開發。隨著 CSS Grid 規範的出現，將來我們將不需要額外的樣式就可以使用網格。另外的好處就是我們將不需要再依賴 inline 和 float 來完成那些佈局需求在這篇文章我們將要介紹一些網格基本的用法，然後透過實作一個基本的部落格佈局來理解其用法。","text":"當我們要建置複雜的網站時 Grids 是非常重要的。其重要性我們可以從大量的 CSS 框架中窺知ㄧ二，因為幾乎所有的框架都有提供網格(Grids)系統來加速開發。隨著 CSS Grid 規範的出現，將來我們將不需要額外的樣式就可以使用網格。另外的好處就是我們將不需要再依賴 inline 和 float 來完成那些佈局需求在這篇文章我們將要介紹一些網格基本的用法，然後透過實作一個基本的部落格佈局來理解其用法。 瀏覽器的支援度即使在這篇文章撰寫的現在仍然只有 IE10+ 和 Edge 支援 Grid Layout - 所以這意味著暫時我們還不能在正式的專案上使用。不過我們還是可以透過開啟實驗功能 chrome://flags 讓 Chrome 支援，Firefox 則使用 about:config 的 layout.css.grid.enabled 屬性調整。 另外的方式是使用 polyfill。透過上面的這些方式我們可以開始使用網格功能。 注意：IE 目前實作的是舊版的規格。不幸的這意味著它可能跟最新的規格不相容。所以當您在實作本文的練習時建議使用 Chrome 或 Firefox。 網格系統(grid system)術語當我們在設計與執行元素的佈局時 CSS 的網格系統類似於表格的作用。然而比起表格，它有更多的功能與彈性。在這一小節我們要探討一些術語，這些術語是我們在使用網格時會需要理解的。 fr 單位：Flexible Lengths 這個單位我們用來設定可用空間的比例，意思是我們會用在 grid-rows 與 grid-columns 上。根據規範的定義空間比例的分配會在 row 或 column 的內容或長度一些非彈性的尺寸設定完成之後處理，即分配剩下閒置的空間。 lines：線用來定義元素的邊界，可以設定為垂直或水平的。下圖呈現四個垂直與四個水平的線。 tracks：兩線之間的空間稱為 tracks。如下圖有三個垂直和三個水平的 track cells：cell 即一個基本單位或說網格中的格子，如下圖我們總共有 9 個 cell，或者說用 4 條線組出來的最小單位。 areas：區域 area 是一個透過任意數 cell 組成的方形，或者說用 4 條線組出來的就是 area。所以我們可以說一個 track 也是一個 area，一個 cell 也是一個 area 在 Grid 中設定元素的位置讓我們從最基本的部分開始，在這一節我們將會學會如何使用 grids 幫元素定位到特定位置。為了要使用 CSS Grid 我們會需要一個父元素和一或多個子元素，下面我們示範一個簡單的用法 12345678&lt;div class=\"grid-container\"&gt; &lt;div class=\"grid-element item-a\"&gt;A&lt;/div&gt; &lt;div class=\"grid-element item-b\"&gt;B&lt;/div&gt; &lt;div class=\"grid-element item-c\"&gt;C&lt;/div&gt; &lt;div class=\"grid-element item-d\"&gt;D&lt;/div&gt; &lt;div class=\"grid-element item-e\"&gt;E&lt;/div&gt; &lt;div class=\"grid-element item-f\"&gt;F&lt;/div&gt;&lt;/div&gt; 在我們處理完 HTML 的結構之後第一個我們要先套用 display: grid 或者 display: inline-grid 在我們的父元素上 12345.grid-container &#123; display: grid; grid-template-columns: 200px 10px 0.3fr 10px 0.7fr; grid-template-rows: auto 20px auto;&#125; 上面範例中的 grid-template-columns 和 grid-template-rows 屬性用來設定 rows 和 columns 的各種寬的值。我們在 grid-template-columns 中定義了 5 個 columns 10px 的欄位替兩個元素之間插入一些空白的空間。第一個欄位 column 是 200px 寬。第三個欄位使用 0.3 意思是剩下空間的 30% 而第五使用 0.7 也是針對剩餘空間的部分。 在 grid-template-rows 第一個參數使用 auto 讓列(row)可以依據內容展開擴展需要的空間。20px 的部分則表示下一 row 我們用其來顯示列跟列之間的間隔空間。 See the Pen CSS Grid Layout Demo 1 by andyyou (@andyyou) on CodePen. 觀察第二欄的元素 B ，我們就是拿它來當作間隔，如果您不設定子元素的位置那麼預設瀏覽器會依序把子元素放進 cell，超過的部分會放到下一列。也就是說第二列(row)還有四個 column 的位置。 為了讓元素放置到特定的 cell 我們需要設定位置，在我們開始解釋如何設定之前先看看下面這張圖 在這個範例中，我們將會採用 line-based placements 基於線的配置，這種方式的意思是線在我們的網格(Grid)系統中扮演指揮的角色負責元素的位置配置與範圍管理。讓我們拿元素 B 來當作範例，水平橫向來看 B 從垂直的 3 號線開始到 4 號線結束，縱向來看從水平的 1 號線到 2 號線。我們使用 grid-column-start 來指定起始的垂直線，以這個範例來說就是 3 ，grid-column-end 為 4 以此類推最後我們得到的樣式如下 123456.element-b &#123; grid-column-start: 3; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2;&#125; 同樣的要把元素放置到 F 位置 CSS 樣式如下 123456.element-f &#123; grid-column-start: 5; grid-column-end: 6; grid-row-start: 3; grid-row-end: 4;&#125; 建立基本的佈局現在我們知道了關於如何設定網格系統的基礎用法了，讓我們來建立一個簡單的部落格設計佈局。我們假設這個部落格會有 header，footer，sidebar和兩個 section 1234567&lt;div class=\"grid-container\"&gt; &lt;div class=\"grid-element header\"&gt;Header&lt;/div&gt; &lt;div class=\"grid-element sidebar\"&gt;Sidebar&lt;/div&gt; &lt;div class=\"grid-element main\"&gt;Main&lt;/div&gt; &lt;div class=\"grid-element extra\"&gt;Extra Info&lt;/div&gt; &lt;div class=\"grid-element footer\"&gt;Footer&lt;/div&gt;&lt;/div&gt; 這邊我們要先記住標籤的順序並不會對 Grid 配置的位置造成任何影響，只要我們不改變 CSS，即使您把 footer 標籤放到 header 的上面也不會造成任何改變。當然我們不建議您故意這樣做，這邊的核心觀念是一旦啟用 grid 那麼元素的位置配置就由網格系統決定而不是標籤的順序。現在我們需要做的就是弄清楚 grid-row-end 這些屬性到底該設置什麼值。就像上面的範例首先我們先畫一個簡單的格線示意圖來決定這些值 我們現在稱那些垂直的線為 column 線，因為我們靠它來決定 column 的位置，而水平的線則是 row 線 從上面這張圖我們可以得知 header 會從 1 號 column 線(垂直線)到 4 號 column 線，而 row 的部分則是從 1 號 row 線(水平線)到 2 號。 123456.header &#123; grid-column-start: 1; grid-column-end: 4; grid-row-start: 1; grid-row-end: 2;&#125; 同樣的 extra content 從 column 3 到 column 4，row 5 到 6 CSS 如下 123456.extra &#123; grid-column-start: 3; grid-column-end: 4; grid-row-start: 5; grid-row-end: 6;&#125; 照著規則設定其他元素，最後結果下面的範例 See the Pen CSS Grid Layout Demo 3 by andyyou (@andyyou) on CodePen. 結論CSS Grid 讓我們可以輕鬆的建立複雜的佈局，這麼一來整份 CSS 也將更容易維護，我們不需要再與 float, position, z-index 這些屬性奮鬥，另外一個好處就是把顯示的佈局和標籤結構分離。還有就是即便是動態的內容也能夠處理，如下面影片 參考資源 Grid Introduce Flexbox vs Grid","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Openshift 筆記","slug":"openshift-note","date":"2016-04-16T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/04/16/openshift-note/","link":"","permalink":"//andyyou.github.io/2016/04/16/openshift-note/","excerpt":"","text":"常用指令1234567891011121314151617181920212223242526272829303132# 安裝 rhc$ gem install rhc$ rhc setup&lt;!--more--&gt;# 建立 app$ rhc app create [app name] ruby-2.0 postgresql-9.2# 設定好 database.yml# 顯示 app 相關資訊$ rhc show app [app name]# DB migration$ rhc ssh [app name] # SSH 至 app 環境$ cd app-root/repo$ bundle exec rake db:create RAIS_ENV=production$ bundle exec rake db:migrate RAILS_ENV=production# 修改 Server$ rhc env set OPENSHIFT_RUBY_SERVER=puma -a [app name]# 重啟$ rhc app restart [app name]# 查看錯誤 Logs$ rhc tail [app name]# 查詢 PostgreSQL$ rhc port-forward -a [app name]# 接著再用介面上的帳密登入 123456789production: adapter: postgresql encoding: unicode pool: 5 database: &lt; %=ENV[&apos;OPENSHIFT_APPNAME&apos;]%&gt; host: &lt; %=ENV[&apos;$OPENSHIFT_POSTGRESQL_DB_HOST&apos;]%&gt; port: &lt; %=ENV[&apos;$OPENSHIFT_POSTGRESQL_DB_PORT&apos;]%&gt; username: &lt; %=ENV[&apos;OPENSHIFT_POSTGRESQL_DB_USERNAME&apos;]%&gt; password: &lt; %=ENV[&apos;OPENSHIFT_POSTGRESQL_DB_PASSWORD&apos;]%&gt; 資源 完整教學 解決 rails 4.2 無法啟動 bug database.yml 範例","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"docker","slug":"docker","permalink":"//andyyou.github.io/tags/docker/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"Docker 入門筆記 - OSX","slug":"docker-note","date":"2016-04-15T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/04/15/docker-note/","link":"","permalink":"//andyyou.github.io/2016/04/15/docker-note/","excerpt":"首先需要先安裝 Docker Toolbox，工具包包含下面幾種工具","text":"首先需要先安裝 Docker Toolbox，工具包包含下面幾種工具 Docker Machine Docker Engine Docker Compose Kitematic command-line environment shell Oracle VM VirtualBox 整個流程為 安裝 Docker Toolbox 在 container 中執行 image 檔 在 Docker Hub 瀏覽可用的 image 檔 建置自己的 image 並 push 到 Docker Hub 因為 Docker 的常駐服務程式(daemon)採用 Linux 規範的核心功能，所以我們不能直接在 OSX 中執行。因此需要使用 docker-machine 來建立掛載一個虛擬機器，並且用這個虛擬機器來執行 Docker。 如果 Docker 安裝在 Linux 系統中那麼 Docker client, Docker daemon, 還有任何 Docker 容器都可以直接在本機上執行。 而在 OSX 中 Docker daemon 預設是執行在一個輕量的 Linux VM，整個 VM 被配置在記憶體中，約佔 24MB啟動時間約 5 秒。 執行 建立或開啟 docker-machine 1234567891011121314151617181920212223242526272829# 建立$ docker-machine create# 刪除$ docker-machine rm [name]# 重建$ docker-machine create --driver virtualbox default# 常用$ docker-machine [start|stop|restart|status]# 設定檔在 ~/.docker/machine/machines/default# 列表$ docker-machine ls# 連結 shell 到 default 機器$ eval \"$(docker-machine evn default)\"＃ 啟動 docker$ docker run hello-world# 顯示正在執行的 docker container$ docker ps# 安裝之後的正常開機流程$ docker-machine start$ eval \"$(docker-machine env default)\" Docker machine 運行著 Docker Engine，Engine 的部分提供我們 Docker 的核心功能。我們可以使用 image 和 container。container 意思就像是一個 instance，而 image 檔就像是 class。 docker run hello-world 中 run 是建立和執行一個 container，最後 hello-world 則是 image一個 container 等於是一個基本的 Linux 系統，而 image 則是您希望安裝到這個 container 的軟體。 docker 常用操作12345678910111213141516171819202122232425262728293031323334353637383940414243# 執行 image# docker run [image_name] [arguments]$ docker run docker/whalesay cowsay boo# local images 列表$ docker images# docker run 流程 -&gt; 檢查本地端是否有 image -&gt; 沒有的話到 docker hub 下載 -&gt; 有的話沿用# -&gt; 只有在有更新的時候才會重新下載# Dockerfile 不只可以指定環境該安裝什麼軟體，還可以指定該執行哪些指令# 建置 image，切換到 Dockerfile 目錄$ docker build -t docker-whale .# docker 建置流程 -&gt;# 1. 首先確認所有需要的資料正確# Sending build context to Docker daemon# 2. 載入 image# FROM docker/whalesay:latest# 3. 執行安裝與指令# 上傳 Docker Hub# 0. 上傳的 image 需要用帳號當作 namespace 例如: andyyou/ubuntu# 1. 打標籤或是在 docker build -t 的時候就設好# 2. push 到 docker hub# 打標籤$ docker tag 32d9cb7369aa andyyou/node:latest$ docker tag [image id] [repo_account/image_name]# 登入$docker login# 推上 docker hub$ docker push# 刪除 local image，可用 id 或 name$ docker rmi -f 7d9495d03763$ docker rmi -f docker-whale# 刪除 container$ docker rm -f [container_id/container_name] Docker with Node, MongoDB下面為如何設定 Docker 容器搭配 MongoDB 與 NodeJS 的簡短介紹。我們將一步一步的介紹關於設定與過程中可能遇到的問題。在我們熟悉 Docker 搭配 Node, MongoDB 的操作之後，我們將具備足夠基本知識來使用 Docker MongoDB12345678910111213141516171819202122232425262728# 下載 Mongo image$ docker pull mongo:latest# 啟動/執行 MongoDB container$ docker run -v \"$(pwd)\":/data --name mongo -d mongo mongod --smallfiles# -v \"$(pwd)\":/data 會把當前目錄對應到 /data# 列出正在執行的 container$ docker ps# 列出所有的 containers$ docker ps -a# 移除 container$ docker rm [container_id]# 建立一個新的 mongo container 連接到已經開啟的 mongo container 並執行連線# --rm 是退出之後就移除$ docker run -it --link mongo:mongo --rm mongo sh -c 'exec mongo \"$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/test\"'# 連線到已在執行的 container，先連線在執行 mongo$ docker exec -it 67d1db81df31 bash$ mongo$ db.col.insert(&#123;\"a\": 4&#125;)$ db.col.find().pretty()$ mongodump --db test --out /data/test-backup # 匯出 db$ mongorestore --db test-restored /data/test-backup/test # 還原 Node123456789101112131415161718# 下載 node image$ docker pull node:latest# 執行$ docker run -it --rm node # -it 參數表示保持 STDIN 和配置一個 TTY, --rm 當退出 node 的時候關閉 container# 建立一個 container 並且 mounted 到 mongo$ docker run -it --name node -v \"$(pwd)\":/data --link mongo:mongo -w /data -p 8082:3000 node bash# 建立 nodeapp container$ docker run --name nodeapp -v \"$(pwd)\":/data --link mongo:mongo -w /data/app/sandbox -p 8082:3000 -d node npm start# 顯示目前 container 的狀態$ docker logs nodeapp$ docker logs -f nodeapp# 顯示連線 IP$ docker-machine config 資源 Getting started 參考 設定 AWS 和 Docker Cloud Debian 8 基本安裝 Mongo with Node 教學 持續更新指令 錯誤處理 DevOps","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"docker","slug":"docker","permalink":"//andyyou.github.io/tags/docker/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"SSL 相關筆記","slug":"self-signed-ssl-and-others","date":"2016-04-12T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/04/12/self-signed-ssl-and-others/","link":"","permalink":"//andyyou.github.io/2016/04/12/self-signed-ssl-and-others/","excerpt":"如何自己簽一張 SSL 憑證用於測試概覽下面簡易介紹了 SSL 是如何實作以及在整個流程中各個憑證所扮演的角色。 一般網頁傳輸是透過非加密的方式，意思是每一個人只要透過工具都可以存取，並且窺視所有的傳輸內容。可以見得的，這可能造成一些問題。尤其是在安全和隱私方面，例如信用卡與銀行交易的資訊。安全套接層協議(Secure Socket Layer)也就是 SSL 是用來加密這些伺服器與客戶端傳輸的資料。簡單說就是保證兩個應用程式之間通訊的機密和完整性，也可驗證對方的身份。","text":"如何自己簽一張 SSL 憑證用於測試概覽下面簡易介紹了 SSL 是如何實作以及在整個流程中各個憑證所扮演的角色。 一般網頁傳輸是透過非加密的方式，意思是每一個人只要透過工具都可以存取，並且窺視所有的傳輸內容。可以見得的，這可能造成一些問題。尤其是在安全和隱私方面，例如信用卡與銀行交易的資訊。安全套接層協議(Secure Socket Layer)也就是 SSL 是用來加密這些伺服器與客戶端傳輸的資料。簡單說就是保證兩個應用程式之間通訊的機密和完整性，也可驗證對方的身份。 SSL 使用我們所知道的非對稱式加密，也就是我們常說的公鑰加密的方式(PKI，Public Key Cryptography)公鑰加密，這種方式總共會有兩把鑰匙(兩個加密檔)，一把是 Public 一把 Private。任何加密的資料，只能透過對應鑰匙解密。也就是說當一筆資料透過伺服器上的私鑰加密，那麼就只能透過對應的公鑰解開，反之亦然。更白話的說就是鑰匙產方通常握有私鑰，將公鑰交給信任之對象，之後要產生的加解密都靠私鑰，而信用對象的加解密都用公鑰。 如果 SSL 已經使用了公鑰對傳輸資料加密，那為什麼我們還需要一張憑證？技術面的回答是這張憑證本來就不是必須的。因為資料已經被加密，沒那麼簡單被第三方破解。然而憑證在溝通過程中扮演了一個關鍵的角色。一張憑證需要一個被信任的憑證發行機構(CA)簽署(Signed)來確認憑證的擁有者聲稱的資訊是正確的。少了被信任的簽章，資料仍然會被加密，但您所溝通的對象卻不一定跟你想的一樣。如果沒有憑證那麼偽裝式的攻擊會更容易發生。 具體來說 SSL 實際運作在第四層傳輸層 Transport Layer (TCP/UDP) 與第七層應用層之間。主要的協定或者我們說任務分成 SSL Handshake Protocol, SSL Change Cipher Spec Protocol, SSL Alert Protocol和 SSL Record Protocol SSL Handshake在開始溝通之前要先互相確認身份，遵循的規則，加密演算法或密鑰交換演算法。 SSL Change Cipher用來變更雙方傳輸加解密的演算法與驗證的規格。 SSL Alert當發生錯誤時用來傳遞錯誤訊息。 SSL Record Protocol確認資料的完整性以及沒有被篡改。 流程1 瀏覽器發送請求給 Server 包含瀏覽器支援的加密演算法資料與 TLS/SSL 版本 Server 使用自己的私鑰加密 CA 憑證給瀏覽器，同時附加一把公鑰 瀏覽器收到加密資料後嘗試使用網站的公鑰解密，這一步是為了確保憑證在傳輸過程中沒有被竄改 驗證 CA 的訊息內容之後確認網站的真實性 Server 也丟出目前支援的加密演算法和 TLS/SSL 版本，決定兩者都支援的方式 產生一組 Session Key (加密金鑰) 並用 Server 的公鑰加密 Server 用私鑰解開得知 Session Key 使用雙方協議好的 Session Key 對接下來的資料進行加解密 實作 - 步驟 1 產生一把私鑰我們會使用 openssl 來產生RSA加密演算法的私鑰和 CSR(Certificate Signing Request)憑證請求檔第一步我們需要先產生私鑰 1$ openssl genrsa -out server.key 2048 實作 - 步驟 2 產生 CSRCSR 憑證請求檔是要發給認證機構，簡單說其功用就是把你的個人資料填好附上私鑰交給認證機構來做簽證的動作 1$ openssl req -new -key server.key -out server.csr 實作 - 步驟 3(選用) 移除 Key 的密碼12$ cp server.key server.key.org$ openssl rsa -in server.key.org -out server.key 實作 - 步驟 4 產生自簽憑證1&gt; openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt Let’s Encrypt參考資源 說明 Apache 使用 创建并部署自签名的 SSL 证书到 Nginx SSL憑證設定教學 Let’s Encrypt 教學 - 中文 Let’s Encrypt 教學 Let’s Encrypt on OSX","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"//andyyou.github.io/tags/ssl/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"[譯] Houdini: 你還沒聽說！這可能是 CSS 開發中最令人興奮的事！","slug":"introduce-houdini","date":"2016-03-31T09:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/03/31/introduce-houdini/","link":"","permalink":"//andyyou.github.io/2016/03/31/introduce-houdini/","excerpt":"其實…我想說這可能是最令我感到興奮..但又害怕頭痛的功能… - 原文連結 你曾經想要使用某個 CSS 的新功能，但是最後卻因為這個功能瀏覽器還未全面支援而放棄了嗎？甚至更糟糕的狀況，瀏覽器已經支援了但卻充滿問題。我敢打賭這些情況你肯定遇過了。如果上面這種情形你曾經遇過，那麼你是應該關心一下 Houdini。","text":"其實…我想說這可能是最令我感到興奮..但又害怕頭痛的功能… - 原文連結 你曾經想要使用某個 CSS 的新功能，但是最後卻因為這個功能瀏覽器還未全面支援而放棄了嗎？甚至更糟糕的狀況，瀏覽器已經支援了但卻充滿問題。我敢打賭這些情況你肯定遇過了。如果上面這種情形你曾經遇過，那麼你是應該關心一下 Houdini。 Houdini 是 w3c 新的任務團隊，他們的終極目標就是解決上面這些問題 - 讓瀏覽器更迅速廣泛的支援 CSS 新特性。這個計畫試圖透過提供一系列新的 API，也是第一次讓開發者可以擴充 CSS 本身的能力。透過 hook 的方式讓我們可以在瀏覽器渲染的過程動點手腳。 Hooks 簡易說明：Hooks 英文翻譯為鉤子，在程式術語中所表達的是在程式特定位置埋入一段預留的程式碼，用來呼叫其他對應的程式碼。可以大略想成在某個片段先空出一個位置，這個位置可以在事後再放入動作，不放也沒關係。 不過具體來說這到底是什麼意思？這麼做真的好嗎？還有這樣做到底能在我們的開發過程提供些什麼幫助。 在這篇文章，我將試著回答這些問題。不過在這之前我們必須要先搞清楚，到底我們在今時今日遇到什麼問題，為什麼我們需要做這些改變。接下來我們將會更具體的說明 Houdini 是什麼東西和這傢伙會怎麼解決這些問題，並且列出目前開發中一些令人興奮的功能。最後我將提供一些比較具體實例的說明。 Houdini 試圖要解決什麼問題？每一次當我寫了一篇文章來介紹一些 CSS 的新功能時總是會有人留言像是 這實在太棒了! 不過我們可能要再等個 10 年才能使用 我能體會這種毫無建設性的留言….從過往的歷史來看，這的確需要花上好幾年的時間從功能提案到廣泛採用。而其中最關鍵的原因是唯一讓 CSS 增加新功能的方式就是透過下面這個標準流程。 因為瀏覽器本身牽涉太廣泛，對於這樣的流程我本身沒有任何反對意見。當然我們也知道這會耗掉很長的時間。舉例來說 flexbox 首次提案是在 2009 年，而時至今日我們還是見到開發者在抱怨支援的瀏覽器不夠。這個問題正緩慢的解決中，因為幾乎所有的瀏覽器都會自動更新，不過即使是現代瀏覽器(Modern Browser)在功能提案到實際能使用該功能還是有一段挺長的時間。 有趣的是並不是所有 Web 領域的東西都處在這樣的情況，看看最近的 Javascript，為什麼 Javascript 可以發展如此迅速 從上圖這種流程，構想提案到實際用在產品上有時候只需要幾天的時間。例如：我已經在產品上使用了 async/await 的功能。這個功能甚至還沒有一個瀏覽器支援。 你還可以看到兩個社群截然不同的狀況，在 Javascript 社群你可以聽到人們開始在抱怨更新速度太快，而在 CSS 社群則多是看到一堆人在抱怨學那麼多東西沒用，還需要非常久的時間才能使用。 那為什麼我們不可以使用 CSS Polyfills？看完 Javascript 的流程第一個直覺的想法是那我們也來為 CSS 提供 Polyfills，聽起來可能蠻可行的，如果有 Polyfills 那麼 CSS 也可以像 Javascript 一樣快速的演進，不是嗎？可惜的是，這並不像想的那麼容易，用舊有技術實現新的功能或 API 在 CSS 中異常的困難，在大部分的情況下會整個犧牲掉效能。 Javascript 是一個動態語言，意味著我們相對容易用 Javascript 替 Javascript 補上 Polyfills。對 CSS 來說我們相對很少使用 CSS 來做 Polyfills。一般頂多就是使用轉譯器來產生 CSS 例如 PostCSS 就是這樣的東西。如果你想直接對 DOM 結構或者元素的 Layout，位置加上 Polyfills，那麼我們就必須要在客戶端執行對應的邏輯程式。 不幸的是瀏覽器對於這方面並不提供任何簡單的方式。 下圖我們簡單的歸納瀏覽器從收到 HTML 文件到顯示在螢幕上概略的流程。藍色區塊就是 Javascript 能夠控制結果的關鍵點 在上圖中我們認知到身為一個開發者，你對於瀏覽器解析 HTML 和 CSS 轉換成 DOM, CSSOM 的過程幾乎沒有控制權，尤其在瀏覽器對元素佈局以及渲染方面。唯一在這個過程中我們能夠掌握的就是 DOM 的存取，是不是該換 CSSOM 做些開放了。不過這邊先提一下 Houdini 網站上提到的改良 CSSOM的部分：確認跨瀏覽器行為不一致以及缺少關鍵功能的問題。 關於缺少關鍵功能部分，舉例來說，瀏覽器中的 CSSOM 並不會顯示跨站存取的樣式規則，而且會直接忽略那些它看不懂的樣式，這也意味著如果你想增加一個瀏覽器未支援的功能，你是不可以使用 CSSOM。反而要用 DOM 去找到 &lt;style&gt; 和 &lt;link rel=&quot;stylesheet&quot;&gt; 自己取得 CSS 然後解析再把它們補回 DOM。當然，更新 DOM 通常也表示瀏覽器必須要重新執行整個流程。 雖然整個流程重新渲染看起來並不會造成非常嚴重的效能問題，甚至這可能已經是常出現的情況，不過如果我們需要處理像是 scoll window resize mouse keyboard 這些事件，大量的更新次數可能就會很明顯地看出變慢了。更慘的是當你發現大部分的 CSS Polyfills 都有它們自己的解析方式和套用邏輯，而解析和套用是非常複雜的事情，導致這些 polyfills 通常不是很肥就是容易出錯。 總結上述所說的就是，現階段如果你想要瀏覽器對於呈現做些不同的行為那麼你就必須要靠 DOM 去調整。 但，為什麼我需要修改瀏覽器內部的渲染引擎？對我來說，這絕對是能夠回答整篇文章最關鍵的問題。如果你已經看到這邊，請仔細的閱讀這個部分! 看到這邊我很肯定有一部份的人會想：我根本不需要這個。我只是建置一個一般的網頁，我不會想去對瀏覽器內部動手腳。如果你是這麼想的，那麼我強烈建議你先停一下，去檢查過去你已經用在開發中的那些技術。對瀏覽器套用樣式的流程取得一些存取權限和 hooks 並不是只為了創造一些很屌的火力展示 - 這主要是希望給開發者和框架作者有更多的解決方案，功能去完成下面這兩件事： 統一跨瀏覽器樣式的不同行為 開發新功能或者解決相容性問題 - 補上新功能的 polyfills ，讓我們可以快點使用到這些新技術 如果你曾使用過像是 jQuery 這類的函式庫，你已經受惠於這種功能！事實上，這也是現今大多數前端框架或函式庫的主要賣點。Github 上 5 個流行的 Javascript 專案 - AngularJS, D3, jQuery, React, Ember 都處理了很多跨瀏覽器不同行為的問題。 不過上面說的是 Javascript 的部分，現在讓我們來想想關於 CSS 和所有跨瀏覽器的問題。即便是最流行的 CSS Framework 像 Bootstrap，Fundation 也聲明跨瀏覽器相容性的問題他們並沒有完全處理 - 只是避開那些問題。跨瀏覽器 CSS 的 bug 不只在過去存在，即使是今天也還存在像是 flexbox` 的問題。 想像一下如果任何 CSS 的樣式規則可以確保在任何瀏覽器有著一致的行為那我們的開發生涯該是多麽美好。再進一步如果任何你從 Blog，Conferences 或 Meetup 得知的新功能像是 CSS Grids, CSS Sanp points, Sticky positioning 我們馬上就能夠在今天開始使用，而你需要做的就是從 Github 下載程式碼。 這就是 Houdini 的理想。這個未來正是該工作團隊試圖實現的目標。你說你根本不想去撰寫那些 polyfills 也沒關係，但你大概會想使用吧！？畢竟只要有人寫出 polyfills 我們就可以從中得到幫助。 那麼 Houdini 現階段有什麼功能正在開發？如同上面提到的，開發者對於瀏覽器渲染的過程沒有太多存取控制的機會，現階段只能從 DOM 下手。 為了解決這個問題，Houdini 團隊將提倡了一些新的規範，關於在渲染流程中賦予開發者其他部分的控制權。下圖顯示新的規範中開發者可以操作的部分。注意規範中灰色區塊是已規劃但還未被寫入規範的。 下面我們將簡介每個新的規範並且說明其功能。完整的清單請查閱Houdini Drafts CSS Parser APICSS Parser API 目前還未被寫入規範，意思是這邊提到任何內容極有可能會改變。不過基本來說它的概念是讓開發者可以擴充 CSS Parser ，提供新的語法結構，舉例來說：新的 media 語法，新的偽類 pseudo-classes 等等 一旦解析器知道關於新的結構，它就可以正確地將其運用在 CSSOM 上。 CSS 屬性與值的 APICSS 已經具有客製屬性的功能，並且在之前的文章說明過對此感到非常興奮。CSS 屬性與值的 API除了自訂屬性將更進一步使其具備型別。 關於加入型別有非常多的好處，不過大體來說最大的賣點就是讓開發者可以客製 transition 和 animate。這在今天是辦不到的。不懂！？看看下面的例子 1234567body &#123; --primary-theme-color: tomato; transition: --primary-theme-color 1s ease-in-out;&#125;body.night-theme &#123; --primary-theme-color: darkred;&#125; 上面的例子如果 night-theme class 被加到 &lt;body&gt; 元素那麼該頁面有參考 --primary-theme-color 屬性的值將會慢慢的從 tomato 轉換到 darkred。如下範例 123p &#123; color: var(--primary-theme-color);&#125; 在現階段，如果你要完成這個功能你得為每一個元素撰寫 transition，因為現在過渡效果是跟在元素上並不是跟著屬性。另一個有趣的功能就是註冊 hook，提供開發者一個方式來修改自訂屬性的最終值，用在 polyfills 方面這可能是非常實用的。 CSS Typed OMCSS Typed OM大概就是目前 CSSOM 第二版的概念。目的是解決當前 CSS 模型的問題，也包含 CSS Parser API 和 CSS 屬性和值 API 追加的新功能。 Typed OM 另外一個主要的目標是改善效能。將 CSSOM 目前使用的字串值換成具意義型別，因此在Javascript 操作的表現會得到顯著效能的提升。 CSS Layout APICSS Layout API提供開發者撰寫自己的佈局模組。透過佈局模組意味著任何東西可以被傳入 display 屬性。這將是第一次開發者有辦法透過原生的方式改變佈局提供像是 display: flex 和 display: table 這樣不同的模組。 例如 Masonry Layout 流瀑式版型 這樣複雜的佈局方式在今天是不可能單單只透過 CSS 就完成的。雖然它的效果令人驚艷但可惜的是通常都有效能相關的問題，在低階的裝置上尤其明顯。 CSS Layout API 讓開發者透過 registerLayout 的方法，允許註冊一個 layout 的名稱，然後用一個 Javascript class 來組織邏輯。下面就是一個簡單的範例 1234567891011registerLayout('masonry', class &#123; static get inputProperties() &#123; return ['width', 'height'] &#125; static get childrenInputProperties() &#123; return ['x', 'y', 'position'] &#125; layout(children, constraintSpace, styleMap, breakToken) &#123; // Layout logic goes here. &#125;&#125; 如果你感受不到上面範例的意義，也不用擔心。最主要的是說你可以像下面範例這樣使用，你只要找到別人寫好的例如 masonry.js 接著在 CSS 中使用就好了。 123body &#123; display: layout('masonry');&#125; CSS Paint APICSS Paint API 和 Layout API 非常類似，不過它提供一個 registerPaint 方法。開發者可以在 CSS 中使用 paint() 函式，透過傳入的名稱產生一個 CSS 圖片。這邊有個簡單的範例就是繪製一個有顏色的圓形 12345678910111213141516registerPaint('circle', class &#123; static get inputProperties() &#123; return ['--circle-color']; &#125; paint(ctx, geom, properties) &#123; // Change the fill color. const color = properties.get('--circle-color'); ctx.fillStyle = color; // Determine the center point and radius. const x = geom.width / 2; const y = geom.height / 2; const radius = Math.min(x, y); // Draw the circle \\o/ ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI, false); ctx.fill(); &#125;&#125;); CSS 的用法如下 1234.bubble &#123; --circle-color: blue; background-image: paint('circle');&#125; 現在套用 .bubble 的元素會產生一個藍色圓形的背景圖。這個圓會跟元素尺寸一樣且置中。 Worklets關於上面列出的規範和一些範例你可能會想知道你該把它們放在哪裏？答案是 worklet scripts。worklets 類似於 Web workers，它允許我們匯入 script 檔案，可以在不同的階段執行 Javascript 程式碼，並且它不相依於主要執行緒。worklet script 為了確保效能會嚴格的限制能夠操作的型別。 捲軸效果和動畫雖然針對捲軸效果(scrolling)和動畫方面還沒有官方的規範，不過這是 Houdini 其中一個備受期待的功能。最終 API 會允許開發者將程式邏輯放在一個負責組織執行的 worklet，而不是主要執行緒上。這個東西會支援修改一些 DOM 的屬性。透過這種方式就可以只更新特定屬性，而不是全部重新渲染。 如此一來開發者就可以容易的做出高效能的 scrolling 和動畫類型的應用，例如 sticky scroll header 或是平行捲動 parallax 的效果。你可以在使用案例中得知這些 API 試圖要解決的問題。 儘管還沒有正式的官方規範，實驗性的開發已經在 Chrome 上展開了。事實上 Chrome 團隊目前正在使用這些主要的 API 實作 CSS Snap point 和 Sticky positioning。這是很驚人的，因為這意味著 Houdini API 有足夠的效能讓 Chrome 新功能採用。如果你仍然擔心 Houdini 效能的問題，你可以看看下面這個影片以及原始碼 那我現在可以做些什麼？如同上面提到的，我想每一個網站開發者都應該關注 Houdini。這將是讓我們開發生活變得更美好的未來。即使你不會直接使用 Houdini 規範內定義的東西，你幾乎會用到架構在它之上的許多東西。雖然這個未來還不會立即到來，但它可能比我們想的還要快到來。 所有主流瀏覽器的廠商在 2016 年初已經在雪梨有場面對面的會議交流，對於 Houdini 的建置與開發沒有太多異議。可以說 Houdini 是否會成為下一件大事已經不是個問題，問題應該是何時導入比較恰當。 當然瀏覽器供應商對於建置這些新功能自有一些優先順序，通常會根據那些使用者迫切需要的功能為優先。所以如果你關心這個關於樣式與佈局的擴展功能，你希望可以不用等待瀏覽器開發商經過漫長的開發程序，就使用 CSS 的新功能請告訴那些相關的開發成員你需要這個功能。 另一方面你可以透過提供一些真實世界的使用案例，就是那些你想做的功能但現今技術卻異常難實現。已經有一些案例列在這個 Github 專案。你可以透過發個 Pull Request 來加入協作。 Houdini 開發團隊真的希望能夠從網頁開發人員中取得真正需求與問題，使這些功能更加完善周到。因為通常參與規格書制訂的工程師只專注在瀏覽器身上，他們並不知道應用程式開發者的痛點。全靠我們來告訴他們了。 參考資源 CSS-TAG Houdini Editor Drafts - W3C 最新草稿 CSS-TAG Houdini Task Force Specifications - 官方 Github 專案 Houdini Samples - 實驗範例 原文出處","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"RaspberryPi with node 安裝筆記","slug":"raspberrypi-with-node","date":"2016-03-08T11:00:00.000Z","updated":"2016-10-10T13:23:41.000Z","comments":true,"path":"2016/03/08/raspberrypi-with-node/","link":"","permalink":"//andyyou.github.io/2016/03/08/raspberrypi-with-node/","excerpt":"安裝完 NOOBS 之後…","text":"安裝完 NOOBS 之後… 設定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&gt; raspi-config # 設定語系，時區&gt; startx # 開啟圖形化介面# 更新軟體&gt; sudo apt-get -y update&gt; sudo apt-get -y upgrade&gt; sudo apt-get -y dist-upgrade# 更新韌體&gt; rpi-update&gt; reboot# 安裝遠端桌面&gt; sudo apt-get install xrdp # Microsoft Remote Desktop 即可連線# 安裝酷音&gt; sudo apt-get install scim-chewing# 安裝中文字體&gt; sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy# 安裝 node-arms&gt; wget http://node-arm.herokuapp.com/node_latest_armhf.deb&gt; sudo dpkg -i node_latest_armhf.deb# (安裝 node 錯誤)dpkg: regarding node_latest_armhf.deb containing node: nodejs-legacy conflicts with node node (version 4.2.1-1) is to be installed. node provides node and is to be installed.dpkg: error processing archive node_latest_armhf.deb (--install): conflicting packages - not installing nodeErrors were encountered while processing: node_latest_armhf.deb# (除錯)&gt; sudo apt-get remove nodered&gt; sudo apt-get remove nodejs nodejs-legacy&gt; sudo apt-get remove npm # if you installed npm# 安裝 PhantomJS&gt; sudo apt-get install g++ flex bison-doc bison gperf ruby ruby-dev perl libsqlite3-dev sqlite3 libfontconfig1-dev icu-doc libicu-dev libfreetype6 libssl-dev libpng12-dev libjpeg8-dev ttf-mscorefonts-installer fontconfig build-essential chrpath git-core openssl&gt; git clone git://github.com/ariya/phantomjs.git&gt; cd phantomjs&gt; git checkout 2.1.1&gt; ./build.py&gt; sudo chmod -x ~/phantomjs/bin/phantomjs&gt; sudo chmod 775 ~/phantomjs/bin/phantomjs&gt; sudo ln -s /home/pi/phantomjs/bin/phantomjs /usr/bin/ dpkg 常用指令123456789101112&gt; dpkg -l package_name # 列出該 package 相關資訊&gt; dpkg -l | less # 列出系統中所有安裝的軟體&gt; dpkg -L package_name # 列出該 package 所有檔案擺放位置&gt; dpkg -S file_name # 搜尋 file 所屬 package&gt; dpkg -i package_name # 安裝軟體&gt; dpkg -r package_name # 移除軟體&gt; dpkg -x package_name.deb target_dir # 解 .deb 檔案成數個檔案&gt; dpkg -i --force-overwrite-i package_name # 強制安裝軟體&gt; dpkg -i --force-all package_name # 強制安裝軟體&gt; dpkg -r --purge --force-deps package_name # 強制移除軟體&gt; dpkg --get-selections # 列出系統中所有安裝的軟體&gt; dpkg --pending --remove # 移除多餘的軟體 參考 裝置 基本安裝含無線網路 Raspberry Pi 安裝中文輸入法與字型 安裝 Node 除錯，含 v1, v2 安裝 Node 含開機自動執行設定 常用軟體 編譯 PhantomJS 安裝 PhantomJS","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"//andyyou.github.io/tags/nodejs/"},{"name":"raspberry-pi","slug":"raspberry-pi","permalink":"//andyyou.github.io/tags/raspberry-pi/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"line-height 問題筆記","slug":"line-height-notes","date":"2016-03-08T11:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/03/08/line-height-notes/","link":"","permalink":"//andyyou.github.io/2016/03/08/line-height-notes/","excerpt":"line-height 歸納 line-height 有五種屬性可用，預設是 normal 他會拿 font-size * 1.2 normal number ex: 1.2, 1.8 =&gt; 倍數 unit ex: 18px, 2em, 3rem, etc… percentage ex: 90% inherit =&gt; line-height from parent","text":"line-height 歸納 line-height 有五種屬性可用，預設是 normal 他會拿 font-size * 1.2 normal number ex: 1.2, 1.8 =&gt; 倍數 unit ex: 18px, 2em, 3rem, etc… percentage ex: 90% inherit =&gt; line-height from parent inline box12345containing-box line-boxes (會看一行中的 line-height 誰最高來決定，所有內容共用此水平垂直線) inline-box (影響高的設定：line-height, 中文每一個單`字`是一個 inline-box，英文的話則是一個 word 為一個 inline-box), (設定為 inline 的 tag) content-area (影響高的設定：font-size, 隱形的區塊，純文字沒有圖片的情況下 box-model 的高決定權在 line-height) character 影響 box 高度的規則只有 height 和 line-height，一個 tag 如果沒設 height 的話最後決定高度的一定是 line-height 要說 font-size 也是因為預設 line-height = font-size * 1.2 使用 inherit 時，用百分比效能較差，用數值最佳 font-size: 12px, line-height: 0 在只有文字的情況下，parent tag 不會被撐開，但是放入圖片就會被撐開。codepen 實現多行垂直置中外層包一個如下屬性的 container 即可 12line-height: [height];font-size: 0; 資源 MUKI - 深入 CSS 之 line-height 應用 深入常見 vertical-align 問題 css行高line-height的一些深入理解及应用","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Cache 筆記","slug":"cache-notes","date":"2016-03-08T11:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/03/08/cache-notes/","link":"","permalink":"//andyyou.github.io/2016/03/08/cache-notes/","excerpt":"瀏覽器 cache 是一種機制，透過特定狀態告知瀏覽器不需要重新下載檔案 cache 最早使用 Expires 和 Pragma，現今主要使用 Cache-Control 來控制 cache 大略流程，在實際下載檔案之前發生： cache 的實際處理機制存在瀏覽器中，也就是我們需要透過指令(cache-directives)告訴瀏覽器該怎麼處理 瀏覽器設定為不提供 cache ，完全忽略下面步驟直接請求資源 瀏覽器發送請求，此時可包含 cache-request-directive 這部分的資訊主要是拿來和 server 協商比對用的 伺服器判斷是否有更新並回傳通知 cache-response-directive","text":"瀏覽器 cache 是一種機制，透過特定狀態告知瀏覽器不需要重新下載檔案 cache 最早使用 Expires 和 Pragma，現今主要使用 Cache-Control 來控制 cache 大略流程，在實際下載檔案之前發生： cache 的實際處理機制存在瀏覽器中，也就是我們需要透過指令(cache-directives)告訴瀏覽器該怎麼處理 瀏覽器設定為不提供 cache ，完全忽略下面步驟直接請求資源 瀏覽器發送請求，此時可包含 cache-request-directive 這部分的資訊主要是拿來和 server 協商比對用的 伺服器判斷是否有更新並回傳通知 cache-response-directive 不需更新則回傳 304 Header 2 至 3 步驟用來判斷是否發出下載資源的請求，如果在 1 的狀況則發出請求，因為不帶任何 Date, Etag 資訊所以就會重新拉一份回來 常用 directives 列表 - Cache-Control no-store 完全不存 cache no-cache 會存 cache 但是每次重新請求 = 無視 cache max-age 判斷是否要重新請求檔案，在一定秒數之內不需要重新請求，除非遇上 max-stale private | public 判斷該使用者能否使用 max-stale 指定資源過期 must-revalidate 定義上類似 no-cache 但是更嚴格，會跟原始 server 比對而不是 proxy 。如果 max-stale 過期整份文件包含子請求都會更新。實際運作則是交由瀏覽器自行判斷是否更新。 s-maxage 用於 CDN 如果 max-age 也存在會覆寫 max-age 簡言之，除了瀏覽器直接關閉 cache 功能外，其他都需要和 server 端協商並透過 cache-directives 決定行為 除了 Cache-Control 還有 Date, Etag 驗證權杖, Last-modified 用來資訊判斷是否重新請求(現今多使用 Cache-Control) Etag - If-None-Match: [hash] Date(傳送), Last-modified(回覆) - If-Modified-Since Etag 格式分成寬鬆和嚴謹 12ETag: &quot;1234abcd&quot; 嚴謹ETag: W/&quot;1234abcd&quot; 寬鬆 在 client 端過期的資料本應要更新，但如果 server 端的資料也沒有更新，我們就沒有理由再去下載已存在於快取中相同的資料，因此 Etag 就是用來確認這件事 關於 Etag 我們唯一要做的就是確認 server 有提供此功能，之後 browser 會幫我們處理後續流程 1234567client --&gt; serverclient &lt;-- server Etag: &apos;x234dff&apos; Cache-Control: max-age=120 單位是秒 ...client --&gt; server 拿著資料去 server 比對 CDNCDN 就是卡在 server 與 users 之間的另外的 server 我們將網址的 Name Server 指向 CDN。CDN 會到我們的 server cache 資料，協助我們管理 DNS &amp; Cache 的部分，也擋在我們服務之前所以偶而可以協助擋 DDoS A Beginner’s Guide to HTTP Cache Headers 淺談 cache - ★★★★★ 推薦 Google - HTTP 快取 Cache Control 與 ETag 初探 HTTP 1.1 Cache 機制 w3c 規範","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"cache","slug":"cache","permalink":"//andyyou.github.io/tags/cache/"},{"name":"mechanism","slug":"mechanism","permalink":"//andyyou.github.io/tags/mechanism/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"重讀 Axel 的 Javascript 中的 Expression vs Statement 一文","slug":"expressions-vs-statements-in-js","date":"2016-03-06T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/03/06/expressions-vs-statements-in-js/","link":"","permalink":"//andyyou.github.io/2016/03/06/expressions-vs-statements-in-js/","excerpt":"前言原文在此，對於 Axel 的文章一直有種雖然短卻難以讀透的感覺。這篇文章是再讀一次的翻譯搭配自己的理解說明，如有錯誤歡迎指教。","text":"前言原文在此，對於 Axel 的文章一直有種雖然短卻難以讀透的感覺。這篇文章是再讀一次的翻譯搭配自己的理解說明，如有錯誤歡迎指教。 註: 下面一些範例當我們在瀏覽器 console 執行時，回傳值與程式執行的順序在 Chrome 與 Firefox 會有差別。注意一下箭頭符號就知道哪個是 return 了。例如 12345678910&gt; function foo () &#123;console.log('foo');&#125;&gt; foo();// 在 Chrome 是fooundefined// 在 Firefox 是undefinedfoo 1. Statements 述句和 Expressions 表達式一直以來，在讀技術文章的時候您一定不陌生這兩個詞，因為小弟過去對於這種細枝末節並不是很重視，加上計算機背景又不深厚。所以對於一些文章和概念的掌握度一直不是很精確。這次重讀一遍 Axel 的文章，希望能夠對 javascript 有更深入的理解。 事實上，在 javascript 中能夠清楚的分辨 expressions 和 statements 的差異對於撰寫程式碼是有一定的幫助，可以避免掉入一些陷阱。 簡單來說一個表達式 expressions 會產生一個值，我們會在撰寫它的地方期望得到一個值。舉例來說像是調用 function 中的引數(arguments)，或者指定式 = 的右邊都屬於 expressions 的位置。 參數(parameters)，引數(arguments) parameters 即在 function 中定義必須在呼叫程序時傳遞，可以用來取值的符號(變數名稱) arguments 是實際呼叫時，傳入的值 下面的每一行都是一個 expression： 123myvar100 + xfn(\"a\", \"b\") 而大體來說述句 statements 即執行動作，完成特定任務。賦值，迴圈和 if 述句都是 statements 的例子。在我們實際撰寫的程式碼中到底是怎麼區分的呢？讓我們看看 MDN 上定義的 if 述句 1234if (condition) statement1[else statement2] 要明白這些事情我們得先從 syntax 開始講起，基本上程式是透過一系列規定好的語法組成，稱為 syntax ，它類似於我們人類語言中的文法，不管是中文還是英文。一個程式要遵循著 syntax 並且由一系列 statements 組成的。 javascript 直譯器在解析程式碼時對於語法結構，即這些程式碼出現的位置會有對應的處理方式。 另外，拿上面的例子來說，任何 javascript 預期會有 statements 的地方你都可以使用 expressions，例如在 statement1 的地方呼叫一個 function。這個 function 就稱作 expression statement 屬於一種特殊的 statement ，這個 function 自然可以 return 一個值，同時也可以在內部產生一些 side effect，不過如果我們重點擺在一些 side effect 部分時，通常就會回傳 undefined。如下圖 通常一個 statement 是獨立的，只會完成某項任務，不過如果它影響了整個程式例如: 異動了機器內部的狀態，或者影響後面的 statement，這些造成的改變我們就稱為 side effect (副作用) 反過來，我們不可以在預期是 expression 的地方換成 statement。例如我們不可以在 function 的引數的地方改成 if 述句。 歸納一下關係如下： syntax statements expression statements expressions 2. statements 與 expressions讓我們看一下這兩段類似功能的程式碼，我們可能會更加清楚它們之間的分別。 if 條件式語句和條件運算子(三元運算子)123456var x;if (y &gt;= 0) &#123; x = y;&#125; else &#123; x = -y;&#125; 上面這幾句程式碼無疑都是 statements，另外 expression 也有個對應的寫法和上面這段程式碼完全等價 1var x = (y &gt;= 0 ? y : -y); 在等號和分號之間的就是一個 expression，其中的 () 不是必須的，但加上去比較容易閱讀。 分號; 與 逗號,在 javascript 中 statement 之間我們可以用 ; 分號來區分和串連。 1foo(); bar() 而 expression 也有一個鮮為人知的 , 運算子可以用來串連。 1foo(), bar() 兩個 expression 都會執行，但是返回最後面的。 123456$ 'a', 'b''b'$ var x = ('x', 'y')$ x'y' 3. 容易產生誤會的 expressions (看起來像 statements)有些 expressions 看起來像是 statements。下面我們會列出一些容易產生疑義的例子逐一討論。主要是因為它們會因為不同的位置產生不同的行為。 物件實字(Object Literal)與程式碼區塊(Block)下面這段範例是一個物件實字，屬於 expression ，用來產生一個物件 123&#123; foo: bar(3, 5)&#125; Object Literal 是一個透過 {} 與 , 逗號分隔的鍵值對列表就是 var o = {name:&#39;Object&#39;} 這樣的寫法。 同時它還是一個符合規範的 statement，因為它具備了： block: 一段 statement 放在 {} 中 label: 我們可以在任何一段 statement 之前放上一個 label，在這邊 label 是 foo: statement: 一個 expression statement bar(3, 5) 所以 {} 到底是一個 block 還是物件實字，你可能會說是物件那讓我們來看看下面這個奇怪的例子 123456789101112131415161718192021222324252627282930313233343536373839404142// 在看這個奇怪的範例之前讓我們先看看一些 javascript 的行為// 當我們把非數字相加時&gt; 1 + 'string''1string'&gt; 1 + undefinedNaN&gt; 1 + null1&gt; 1 + [2,3,]\"12,3\"&gt; 1 + &#123;name: 'andyyou'&#125;\"1[object Object]\"// 上面的範例我們得知，除了 undefined 和 null，基本上 js 會把物件先 `toString()` 再相加。&gt; [].toString()\"\"&gt; [1, 2, 3].toString()\"1,2,3\"&gt; var o = &#123;&#125;;&gt; o.toString();\"[object Object]\"// 有了上面的基礎知識之後，讓我們來看看這令人嚇尿的行為&gt; [] + &#123;&#125;\"[object Object]\"// 好！這題如我們所料，[] 產生 \"\" 加上 &#123;&#125; 產生 \"[object Object]\"// 先問你個問題: + 兩邊的運算元能不能互換而結果不變// 你可能回答: 是！！！// 但....&gt; &#123;&#125; + []0 上面程式碼最後一句的 {} 是一個 block 所以執行完之後接 +[]。 12&gt; +[]0 嚇尿了吧！除了 if, 迴圈外 javascript 也具有獨立的 block。下面這段程式碼說明了 label 和 block 的用法: 12345678function test (printTwo) &#123; printing: &#123; console.log('One'); if (!printTow) break printing; console.log('Two'); &#125; console.log('Three');&#125; 執行的結果 12345678&gt; test(false)\"One\"\"Three\"&gt; test(true)\"One\"\"Two\"\"Three\" 從上面驗證了 {} 的語法如果遇到 statements 的位置，就會被當成 statements，而如果在 expressions 的位置就會被當解析成一個值。 1234567&gt; &#123;&#125; + [];// 就是一個最好的例子，&#123;&#125; 被當作 statement 就是一個 block// 如果換成&gt; var x = &#123;&#125;;// 那他就是一個 expression 代表一個值 - 一個物件 讓我們接著看下一個例子。 Function expression 與 function 宣告下面的程式碼是一個 function expression 1function () &#123;&#125; 你也可以給 function expression 一個名稱 1function foo () &#123;&#125; 在當作 function expression 時上面的 function 名稱 foo 只存在在 function 內部能使用，舉例來說像是一個遞迴。你可能困惑了，我們到底在說啥？看看下面的例子，我們要說的是當 function 放在 statements 和 expressions 不同位置時的差異 1234var fn = function me(x) &#123; return x &lt;= 1 ? 1 : x * me(x-1)&#125; // = 等號右邊是一個 expression 的位置fn(10); // 3628800console.log(me); // ReferenceError: me is not defined 具名的 function expression 和函數宣告的寫法看起來是沒有區別的。但實際上這兩者的效果截然不同，function expression 產生一個值(一個 function)。函數宣告則產生一個行為，即建立一個變數，然後它的值是一個 function。而且只有 function expression 可以被立即調用，函數宣告不行。 從上面這幾點看來能夠區分 expression 和 statement 挺重要的。 4. 使用物件實字與 function expression 當作 statements我們已經看到有一些 expression 和 statement 語法上是沒有區別的。這意味著相同的程式碼會有不同行為取決於它出現在 expression 的位置或者是 statement 位置。為了防止產生疑義。javascript 會禁止 expression statement 使用 {} 或 function 開頭。 換句話說就是在 javascript 認定為 statement 的位置，使用了 expression 會變成 expression statement。這並不是 expression，所以產生一些特殊的狀況 {} 會被當作 block 解釋，function 開頭的語法會被當作函數定義。所你當你想要使用這兩者為開頭撰寫 expression statement 時，你可以放上 () 可以確保位於一個 expression 的位置。 這就是 statement 或者 expression 所延伸的問題，也可以說造成我們極度混亂的根源。讓我們來看看 eval 和立即調用函式： evaleval 會解析他的引數當做一句 statement。如果你希望 eval 回傳一個物件你就需要在物件實字外圍放上() 12345&gt; eval(\"&#123;foo: 123&#125;\");123&gt; eval(\"(&#123;foo: 123&#125;)\");&#123;foo: 123&#125; 下次再閱讀文件的時候是不是更有感覺了。 立即調用函式立即調用函式的部分 12(function () &#123; return \"abc\" &#125;())'abc' 如果你省略了 () 如下，你就會得到一個語法錯誤的訊息。function 宣告不可以匿名。 12function () &#123; return \"abc\" &#125;()SyntaxError: function statement requires a name 就算替 function 加上名稱還是噴錯 12function foo() &#123; return \"abc\" &#125;()SyntaxError: syntax error 因為函數宣告不能立即調用(IIFE)，不過除了使用 () 還有些技巧，當我們硬要要把某段程式當做 expression 執行時，可以使用一元運算子 + 或 !，不過和()的方式比起來這會影響回傳結果，如果你不在意的話這也是一種方式。 123&gt; +function () &#123; console.log(\"hello\") &#125;()NaNhello 這個 NaN 是 + 遇上 undefined 的結果，喔！對了還有一種是透過 void 的方式 123&gt; void function () &#123; console.log(\"hello\") &#125;()undefinedhello 連續使用立即調用函式當你在連續呼叫 IIFE 的時候必須要注意不要忘記分號 ; 結尾 123(function () &#123;&#125;())(function () &#123;&#125;())// TypeError: undefined is not a function 上面的程式碼會產生錯誤因為 javascript 以為第二行的 () 是要拿第一行產生的結果當作一個函數來呼叫。 123(function () &#123;&#125;());(function () &#123;&#125;())// OK 下面範例因為 javascript 自動補上分號的功能，使用一元運算子的話 ; 可以省略。 123void function () &#123;&#125;()void function () &#123;&#125;()// OK javascript 會自動補上分號是因為接在第一行之後的 void 並不是可以接下去的語句(符合規範能串在一起的寫法)。 另外關於 javascript 自動補上分號有幾項建議如下： 在 return，break，continue，++，– 五種 statement 中，換行字元可完全等於 ;。 var，if，do while，for，continue，break，return，with，switch，throw，try，debugger 關鍵字開頭，以及空的 statement，上一行會自動補上分號。 遇到 expression statement 和 function expression 情況非常複雜，後面請務必要加上分號。 凡 ( 和 [ 開頭的 statements 前面或上一句不加非常危險。 想要更深入明白 ASI，請參考。 總結 syntax : 語法(文法)，該怎麼組織 statements 與 expressions。 expressions : 會產生一個值，其意義就是代表一個值的表式例如 x + y。 statements : 完成某項任務的操作。賦值，條件判斷，宣告都算是 statements; if (condiction) { console.log(&#39;WoooW!&#39;) }。 expression statements : 屬於一種 statement，其產生一個值(或說回傳一個值)，並完成某項任務。例如：x += 1 或者在 statement 執行一個 side effect 的函數呼叫。 在 statements 位置放入 expressions 要小心(即 expression statement)，因為 javascript 對於 expression 和 expression statement 解釋行為是不一樣的。 下面這兩種語法對於其位置尤其需要注意 function statement 位置: 當作函數宣告，即建立一個變數它的值是一個 function。，不能立即調用。 expression 位置: 為 function expression 產生一個為 function 的值，可以被立即調用(IIFE)。 {} statement 位置: block 一個程式碼區塊，例如 for, label 的 block。 expression 位置: 物件實字，建立一個值 - 物件。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"深入 css z-index 屬性","slug":"z-index","date":"2016-03-02T16:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/03/03/z-index/","link":"","permalink":"//andyyou.github.io/2016/03/03/z-index/","excerpt":"說來汗顏，一直以來對於 css 常常是不求勝解。直到自己需要打造自己的輪子才發現對 z-index 完全不熟悉。關於 z-index 的問題其實非常少人完全明白它到底是怎麼運作的。事實上這並不複雜，不過如果你不曾花些時間閱讀規範可能你不曾察覺一些重要的觀念。","text":"說來汗顏，一直以來對於 css 常常是不求勝解。直到自己需要打造自己的輪子才發現對 z-index 完全不熟悉。關於 z-index 的問題其實非常少人完全明白它到底是怎麼運作的。事實上這並不複雜，不過如果你不曾花些時間閱讀規範可能你不曾察覺一些重要的觀念。 問題在下面的 HTML 中我們有三個 &lt;div&gt; 元素，每一個元素包含著一個 &lt;span&gt;，我們給 &lt;span&gt; 設定背景色 - 分別是綠, 紅, 藍。每個 &lt;span&gt; 同時也設定 absolute 位置設在文件的左上角。約略的重疊在其他 &lt;span&gt; 這樣我們就可以觀察整個堆疊的行為。 第一個 &lt;span&gt; 的 z-index: 1，其他兩者不設。 下面是我們的程式碼： 123456div span class=&quot;red&quot; REDdiv span class=&quot;green&quot; GREENdiv span class=&quot;blue&quot; BLUE 1234567891011121314151617181920212223242526.red, .green, .blue &#123; width: 100px; color: white; line-height: 100px; text-align: center; position: absolute;&#125;.red &#123; z-index: 1; background: red; top: 20px; left: 20px;&#125;.green &#123; background: green; top: 40px; left: 40px;&#125;.blue &#123; background: blue; top: 60px; left: 60px;&#125; See the Pen ZWGvwV by andyyou (@andyyou) on CodePen. 這邊有個小小的挑戰: 試看看能不能把紅色區塊的 &lt;span&gt; 排到藍色和綠色 &lt;span&gt; 的後面，但要遵循下面的規則。 不能修改 HTML 結構 不能加入或修改任何元素的 z-index 不能加入或修改任何 position 屬性 目標要完成下面這樣，先不要偷看解答自己想一想。 See the Pen oxXEvx by andyyou (@andyyou) on CodePen. 解答這個解決方案是透過加入一個小於 1的 opacity 到紅色 &lt;span&gt; 的爸爸元素即 &lt;div&gt; 上面是透過加上 123div:first-child &#123; opacity: .99;&#125; 如果你現在跟我當初一樣驚訝，不相信為什麼加了 opacity: .99 可以改變元素的順序。希望剩下的文章可以幫助你更清楚這些機制。 呈現堆疊的順序z-index 看起來非常簡單，至少在我第一次看到這個屬性的時候，我只知道越大的 z-index 應該要被排在最前面(上面)，對吧？但事實上事情沒那麼單純。看起來很簡單以至於大部分的開發者都沒有花時間去理解它的規則。 在 HTML 中的任何元素可以被調整到其他元素的前面或後面，這也就是我們所知的堆疊順序(stacking order)。這樣順序的規則被很明確的定義在規範上，但如同我剛剛提到的，大多的開發者沒有認真的完全參透。 當我們沒有 z-index 和 position 屬性的時候，規則非常簡單，就是按照文件中 tag 撰寫的先後順序。好吧實際上還是有點複雜，請參考規範說明。不過呢，只要我們不使用負的 margin來覆蓋 inline 的元素，大致上我們不會遇到這些極端的情況。 當我們開始加入 position，任何被設定 position 的元素和它們的後代會呈現在其他沒有設定 position 的元素之前，這裡說的設定 position 指的是除了設為 static 以外得值例如: relative, absolute。 最後當我們也加入 z-index ，事情就變得更複雜了一點。很自然的我們會認為具備較大 z-index 的元素會排在前面，有 z-index 也會蓋在沒有的前面。但是實際上卻沒那麼簡單，首先是 z-index 只對那些有設定 position 的元素有效。如果你試著把 z-index 設在 static 的元素上，那麼什麼事都不會發生。第二點 z-index 會建立一個 stacking context ，此時就是進入重點的地方了。 Stacking Context當我們有一個 &lt;div id=&quot;parent&quot;&gt; 包著一群 &lt;div class=&quot;child&quot;&gt; 元素時，它們的堆疊順序通常會一起被移動(從父原則)，這整個群組的順序就是 stacking context，要完全理解 stacking context 我們就必須要參透 z-index 是怎麼排序 stacking order。 每一個 stacking context 有一個唯一的 HTML 元素當作其根元素，當一個新的 stacking context 或者我們翻作堆疊環境被建立在一個元素上時，這個堆疊環境就會控管它內部的子元素的順序 stacking order，意思是如果其中一個元素在這個堆疊環境中順序被排在最底下，那它就完全沒機會出現在另外一個元素排位較高的堆疊環境前面，就算他的 z-index 設成 9999999。 從另外一個角度來說，每一個被設定 position 的元素除了自己的 stacking order 另外如果內部還有子元素，就會有一個 stacking context 來管制底下的元素。 要建立一個堆疊環境 stacking context有下面三者方式，只要使用其一即可： 當元素是網頁文件的根元素通常就是 &lt;html&gt; 當元素被設定 position 除了 static 以外的值，然後 z-index 設定為除了 auto 以外的值 當元素設定了 opacity 且值小於 1 上面提到的三種方式中，前兩者大部分的開發者都知道，即使他們不懂原理但還是會使用。第三種方式除了 w3c 規範，大多開發者都不曾提到。 此外除了 opacity 另外一些新的屬性像是 transforms, filters, css-regions, paged media 等等都會產生 stacking context。還有當 css 屬性需要在超出螢幕的地方渲染，他也會產生一個 stacking context。 如何決定元素在堆疊環境中的位置實際上在 global stacking 決定整個頁面元素的排序包含 borders, background, 文字是極度複雜的而且已經超出這篇文章的範圍。不過針對大多數的應用，對於排序有些基本的認識有助於往後的開發工作，所以讓我們來一步步拆解說明 在單一堆疊環境 Stacking Context 中的順序在單一的堆疊環境從最下面(後)到上面(前)規則如下 執行堆疊的根元素。 有設定 position 且 z-index 為負數的元素和它們的子元素，-1 在 -2 前面。 沒有設定 position 的元素，一般元素。 有設定 position 且 z-index 為 auto，設定 opacity 小於 1 和其他 transforms 等屬性也在此列。 有設定 position 且 z-index 為正數。 都一樣的時候就比文件中程式碼出現的先後順序，後出現的蓋在上面。 注意：2 號情況在一個 stacking context 會被排在最下面(後面)，意思是他會躲在其他元素後面。也因此這讓元素藏在其父元素後面變成了可能。你可能會疑惑上面那句話，試想如下面這樣的結構 123div[z-index: 1, position: relative] /&lt;- 這邊建立了 stacking context div[class: &apos;parent&apos;] div[z-index: -2, position: absolute] /&lt;- 這個元素跟 parent 在同一層 stacking context 所以就躲起來了 全域的堆疊排序 Global Stacking Order清楚的了解一個堆疊環境 stacking contetxt 是如何形成的以及掌握如何排序的原則後，我們不難理解一個元素在全域的堆疊環境下會如何呈現排序，就是把 &lt;html&gt; 作為我們最上層的 stacking context。接著原則就一樣。 避免搞死自己的關鍵點就是每當我們建立了一個新的堆疊環境我們要很清楚這是為了什麼。當你把 z-index 設得很大但卻沒有產生變化，往上層元素看看，可能就會發現已經有人具備了 stacking context 的條件了。 總結回到我們一開始的問題，這次我們就直接透過 html 結構來指出這些順序吧 123456789&lt;div&gt;&lt;!-- 1 --&gt; &lt;span class=\"red\"&gt;&lt;!-- 6 --&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 2 --&gt; &lt;span class=\"green\"&gt;&lt;!-- 4 --&gt;&lt;span&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 3 --&gt; &lt;span class=\"blue\"&gt;&lt;!-- 5 --&gt;&lt;/span&gt;&lt;/div&gt; 當我們在第一個 div 加上 opacity 後，由下至上的排序應該是 123456789&lt;div&gt;&lt;!-- 3 --&gt; &lt;span class=\"red\"&gt;&lt;!-- 3.1 --&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 1 --&gt; &lt;span class=\"green\"&gt;&lt;!-- 4 --&gt;&lt;span&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- 2 --&gt; &lt;span class=\"blue\"&gt;&lt;!-- 5 --&gt;&lt;/span&gt;&lt;/div&gt; 本來是 6 的 span 因為上層的 div 也具備 stacking context 但是順序比下面 4, 5 的 span 小。自己又因為從父原則導致順序被往前推了。希望這篇文章能讓你對於 z-index 有能更加清楚。 資源 w3c 規範 詳細說明 - 中文 MDN stacking context 概覽 z-index No one told you about z-index","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Javascript 三種宣告的差異","slug":"variables-differents","date":"2016-03-01T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/03/01/variables-differents/","link":"","permalink":"//andyyou.github.io/2016/03/01/variables-differents/","excerpt":"關於下面這三種宣告的差異","text":"關於下面這三種宣告的差異 123var a = 0;a = 0;window.a = 0; var a = 0;當我們在全域使用這樣的宣告時，就是替 global execution context 在variable object中建立一個變數。在瀏覽器中這個 variable object 同時有個別名叫做 window 並且它是一個 DOM 是 window 物件而不只是一般的物件。(在一般非瀏覽器的實作這可能是對的)。上面這個 var a = 0 的結果就是你在 window 中建立了一個屬性 a 且不能刪除。它同時也在第一行程式執行之前被定義，注意在 IE8 之前在 window 建立的屬性並不屬於 enumerable 意思是你不能用 for..in 去遍歷。在 IE9, Chrome, Firefox, Opera 這些屬性是 enumerable 的。 12345678910111213141516171819var car = &#123; name: 'Lexus RX200t' &#125;;// 測試 toString 是否存在物件中console.log('toString' in car); // trueconsole.log(typeof car.toString); // function// 但，當我們用 for..in 卻看不到for (var k in car) &#123; console.log(k); // 只有 \"name\" 輸出&#125;// 一個屬性是否是 enumerable 要看物件本身的 enumerable 屬性設定// 我們可以透過 property descriptor 來觀察var d = Object.getOwnPropertyDescriptor(car, 'name');console.log(d.enumerable); // true// 要拿到所有能用的屬性則是 getOwnPropertyNamesconsole.log(Object.getOwnPropertyNames(Object.prototype)); 解釋 Enumerable a = 0在全域的情況下，隱含式的在 window 建立屬性。注意這並沒有在 variable object 建立變數，所以一個普通的屬性是可以被 delete 刪除的。強烈建議不要這麼做。這會導致您的程式產生疑義語意不清。 window.a = 0顯式的宣告一個 window 的屬性，同樣是可以刪除的。 進一步 this.a = 0 呢在全域的情況下，this 指向 window 所以這跟 window.a = 0 是一樣的 當 var 的時候，發生了什麼事當我們透過 var 定義了一個變數名稱(指的是 var n = 0，n 這個識別符號)，這個變數名稱會發生在任何程式碼執行之前詳細解釋請參考 123456789101112console.log('foo' in window); // trueconsole.log(window.foo); // undefinedconsole.log('bar' in window); // falseconsole.log(window.bar); // undefinedvar foo = 'foo'; // 看懂上面有無記錄在 variable object 和單純 property 的差異了嗎？bar = 'bar';console.log('foo' in window); // trueconsole.log(window.foo); // fooconsole.log('bar' in window); // trueconsole.log(window.bar); // bar","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Vue.js in Slim 語法的小問題 Slim::Parser::SyntaxError","slug":"vue-in-slim-delims-problem","date":"2016-02-25T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/02/25/vue-in-slim-delims-problem/","link":"","permalink":"//andyyou.github.io/2016/02/25/vue-in-slim-delims-problem/","excerpt":"","text":"當我們使用 Vue.js 搭配 slim 時(事實上 Angular 應該也有相同的問題)時 12345678910div id=&quot;app&quot; p &#123;&#123;message&#125;&#125;javascript: new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &quot;Hello, Vue.js&quot; &#125; &#125;) 立馬收到Slim::Parser::SyntaxError的錯誤訊息。 但是改成這樣卻又正常 1div id=&quot;app&quot; &#123;&#123; message &#125;&#125; 好啦！答案很明顯了就是我們有地方寫錯，讓 slim engine 誤會了。 這邊紀錄一下解法： 補上屬性第一個最簡單的方式就是幫 p 補上隨意一個屬性 12345678910div id=&quot;app&quot; p class=&quot;&quot; &#123;&#123; message &#125;&#125;javascript: new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue.js&apos;, &#125; &#125;) 加上 [], (), {} 任何一種12345678910div id=&quot;app&quot; p () &#123;&#123; message &#125;&#125;javascript: new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue.js&apos;, &#125; &#125;) 使用 |1234567891011div id=&quot;app&quot; p | &#123;&#123; message &#125;&#125;javascript: new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;Hello Vue.js&apos;, &#125; &#125;) 修改設定上面的解法都是因為 slim 預設會把 {} () [] 和 tag 後面接的 property=value 當作屬性(attributes)來解析。所以我們只要把 {} 拿掉就正常了。 新增或修改 config/initializers/slim.rb 加入 1Slim::Engine.set_options :attr_list_delims =&gt; &#123;'(' =&gt; ')', '[' =&gt; ']'&#125;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"vuejs","slug":"vuejs","permalink":"//andyyou.github.io/tags/vuejs/"},{"name":"slim","slug":"slim","permalink":"//andyyou.github.io/tags/slim/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"關於 delete 變數詭異行為與解釋","slug":"variable-delete-operate","date":"2016-02-25T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/02/25/variable-delete-operate/","link":"","permalink":"//andyyou.github.io/2016/02/25/variable-delete-operate/","excerpt":"","text":"問題發生在當我們撰寫下面程式碼的時候所發現的奇怪行為。 1234567891011121314151617var a = 1;b = 2;console.log(a); // 1console.log(b); // 2// 使用瀏覽器測試請使用 window 如果是用 node 的 REPL 環境那請改成 globalconsole.log(window.a); // 1console.log(window.b); // 2// 但接下來這麼操作delete a; // false 不能刪delete b; // true 可以刪a; // 1b; // undefined 解釋首先根據ECMA-262 §10.3,的定義 Variable environment 是一種特定型別的 Lexical environment，我們沒辦法透過任何方式直接存取。 一個 Lexical environment 用來記錄執行環境的資訊，可以把它想成是一個物件，我們會把在一個執行環境 Context的變數，函數都存在這個物件的屬性上針對函數那些定義的參數(Parameter)也會被記錄，舉例來說 function foo (a, b)() 中的 a 和 b 就會被記在 foo 的執行環境資訊中。 一個 Lexical environment 也有一個連結可以連結到外在的 Lexical environment 就是所謂的 scope chain。這個機制可以協助我們取得目前執行環境以外的變數，舉例來說就是 function 裡面可以拿到 global 的變數。 一個 Variable environment 就只是 Lexical environment 的一部份，本質上就是透過 var 宣告在執行環境中的變數或函數。 使用了 var上面的 a 使用了 var 根據 ECMAScript 定義會被記錄在 Variable environment 根據定義 Variable environment 是不能手動刪除的。也就是說除非用了 eavl，否則是不能被 delete 的。 123456var a = 1;delete a; // falseconsole.log(a); // 1// 記得清除整個環境eval('var a = 1; delete a; console.log(a)'); // undefined 沒使用 var當我們賦值卻沒有用 var，Javascript 會嘗試在 Lexical environment 尋找同名的參考。最大的不同是 Lexical environment 是嵌套的，就是它可以關聯到外面其他的 Lexical environment。當在本地找不到的時候就會往上層去找，換句話說每個 Lexical environment 都有個爸爸，而最外層的就是 global所以當我們不使用 var 而宣告一個變數時會開始在各個 scope 尋找同名變數，最終 Javascript 會拿一個 window(global) 的屬性來當作參考。而物件的屬性是可以刪除的。 結論就是第一個 var 的變數被放在 Variable environment 是不能 delete 的而第二個沒有 var 的變數它是 global 的屬性。 然後你就會問我，那為什麼第一個 a 可以用 window.a 取得，因為全域的 variable object 就是 global(window) 本身。但誰是屬性誰放在variable environment是有差的，因為程式碼看起來沒差所以會搞死人啊。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"[譯] 透過重新實作來學習參透閉包","slug":"master-closure","date":"2016-02-23T04:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/02/23/master-closure/","link":"","permalink":"//andyyou.github.io/2016/02/23/master-closure/","excerpt":"","text":"原文出處: 連結 話說網路上有很多文章在探討閉包(Closures)時大多都是簡單的帶過。大多的都將閉包的定義濃縮成一句簡單的解釋，那就是一個閉包是一個函數能夠保留其建立時的執行環境。不過到底是怎麼保留的？ 另外為什麼一個閉包可以一直使用區域變數，即便這些變數在該 scope 內已經不存在了？ 為了解開閉包的神秘面紗，我們將要假裝 Javascript 沒有閉包這東西而且也不能夠用嵌套 function 來重新實作閉包。這麼做我們將會發現閉包真實的本質是什麼以及在底層到底是怎麼運作的。 為了這個練習我們同時也需要假裝 Javascript 本身具備了另一個不存在的功能。那就是一個原始的物件當它如果被當成 function 調用的時候是可以執行的。你可能已經在其他語言中看過這個功能，在 Python 中你可以定義一個 __call__ 方法，在 PHP 則有一個特殊的方法叫 __invoke這些方法(Method)會在當物件被當作 function 調用時執行。如果我們假裝 Javascript 也有這個功能，我們可能需要這麼實作: 1234567891011let o = &#123; n: 42, __call__() &#123; return this.n; &#125;&#125;;// 當我們把物件當作 function 一樣調用時o(); // 42, 當然現在你會得到 `TypeError: o is not a function` 的錯誤// 譯者註: 之後遇到這種呼叫的情況，請使用 o.__call__() 這邊我們得到一個普通的物件，我們假裝我們可以把它當做 function 來呼叫，然後當我們這個做的同時其實我們是執行一個特殊的方法 __call__ 如果你真的要實作記得用 o.__call__()。 譯者註: 注意! 呼叫 可調用物件 例如上面的 o() 都要換成 o.__call__() 假如您想實作的時候。 現在讓我們先來看看一個簡單的閉包範例。 1234567891011121314151617181920function f() &#123; // 下面這個變數是 f() 的區域變數 // 通常，當我們離開 f 的 scope 時，這個變數 n 就應該要被回收了 let n = 42; // 嵌套的 function 參考了 n function g() &#123; return n; &#125; return g;&#125;// 讓我們透過 f() 來建立一個 g 函數let g = f();// 理論上這個變數 n 在 f() 執行完畢之後就應該要立即被回收，對吧？// 畢竟 f 已經執行完畢了，而且我們也離開了該 scope// 那為什麼 g 可以繼續參考一個已經被釋放的變數呢？g(); // 42 外層的 function f 有一個區域變數，然後裡面的 function g 參考 f 的區域變數。 接著我們把內層的 g 回傳指派給 f scope 外的變數。但我們好奇的是如果 f 執行完畢被釋放了，那為什麼 g 仍然可以取得已被釋放的 f 的區域變數呢？ 這個的魔法便是 - 一個閉包不僅僅只是一個 function。它是一個物件，具有建構子和私有資料。然後我們可以它當作 function 來使用。那如果 Javascript 沒有閉包這種用法，我們必須自己實作它呢？這就是我們接下來要看到的。 12345678910111213141516171819202122232425262728class G &#123; constructor(n) &#123; this._n = n &#125; __call__() &#123; return this._n; &#125;&#125;function f() &#123; let n = 42; // 這就是一個閉包 // 這個內層的 function 其實不只是一個 function // 它其實是一個可以被調用的物件，然後我們傳入 n 到它的建構子 let g = new G(n); return g;&#125;// 透過呼叫 f() 取得一個可以被調用的物件 glet g = f();// 現在就算原來從 f 拿到的區域變數 n 被回收了也沒關係// 可被調用的物件 g 實際上是參考自己私有的資料g(); // 42 如果您曾看過 ECMAScript 規範，可能會對實際上是參考自己私有的資料這句話產生一些疑問，先別急著否定。這邊不過是試著用另外一個較淺的角度解釋。 這邊我們把內部的 function g 用一個 G class 的實例物件(即 new 出來的物件) 取代，然後我們透過把 f 的區域變數 n 傳進 G 的建構子，藉此將變數儲存在新的實例物件私有的資料中。最終我們可以取得 f 的區域變數(n)。 OK! 各位觀眾這就是一個閉包的行為。閉包就是一個可調用的物件，可以把透過建構子把傳入的參數保留在私有的空間中。 更深入的問題？聰明的讀者已經發現還有一些行為我們還沒解釋清楚或者說我們的模擬實作是有漏洞的。讓我們來觀察其他的閉包範例 1234567891011121314151617181920function f() &#123; let n = 42; // 內部函數取得變數 n function get() &#123; return n; &#125; // 另外一個內部函數也同時存取 n function next() &#123; return n++; &#125; return &#123; get, next &#125;;&#125;let o = f();o.get(); // 42o.next();o.get(); // 43 在這個範例中，我們得到兩個閉包同時參考變數 n 。其中一個函數的操作變數會影響另外一個變數取得得值。但如果 Javascript 沒有閉包，單靠我們上面的實作行為將不會一樣。 1234567891011121314151617181920212223242526272829303132333435class Get &#123; constructor(n) &#123; this._n = n; &#125; __call__() &#123; return this._n; &#125;&#125;class Next &#123; constructor(n) &#123; this._n = n; &#125; __call__() &#123; this._n++; &#125;&#125;function f() &#123; let n = 42; // 這邊的閉包我們一樣換成可調用的物件 // 它們可以將參數傳入建構子，進而將值保留起來 let get = new Get(n); let next = new Next(n); return &#123; get, next &#125;;&#125;let o = f();o.get(); // 42o.next();o.get(); // 42 跟上面一樣，我們取代了內部 function get 和 next 的部分改成使用物件。它們是透過將值保留在物件內部進而取得 f 的區域變數，每一個物件具有自己私有的資料。同時我們也注意到其中一個可調用物件 操作 n 並不會影響另外一個。這是因為它們是傳 n 的值 value而不是傳址 reference。白話文就是複製了一分資料。並不是操作變數本身。 為了要解釋為什麼 Javascript 的閉包會參考到相同的 n 即記憶體位置是一樣的。我們需要解釋變數本身。在底層，Javascript 的區域變數跟我們從其他語言理解的觀念並不相同，它們是負責動態分配與計算參考(reference)的物件的屬性，稱為 LexicalEnvironment 物件。Javascript 的閉包其實會有一個參考指向到整個 執行環境, 上下文, Context 的 LexicalEnvironment 物件，而不是特定的變數。 如果您對於 scope 與 context 還不是很了解強烈建議您觀賞這篇 讓我們來修改我們的可調用物件讓其可以取得一個 lexical environment 而不是 n 。 1234567891011121314151617181920212223242526272829303132333435363738class Get &#123; constructor(lexicalEnvironment) &#123; this._lexicalEnvironment = lexicalEnvironment; &#125; __call__() &#123; return this._lexicalEnvironment.n; &#125;&#125;class Next &#123; constructor(lexicalEnvironment) &#123; this._lexicalEnvironment = lexicalEnvironment; &#125; __call__() &#123; this._lexicalEnvironment.n++; &#125;&#125;function f() &#123; let lexicalEnvironment = &#123; n: 42 &#125; // 現在這個可調用變數是透過一個參考 lexical environment 來改變 n // 所以現在變更的是同一個 n 了 let get = new Get(lexicalEnvironment); let next = new Next(lexicalEnvironment); return &#123; get, next &#125;&#125;// 現在我們實作的物件行為跟 javascript 一致了// 還是請注意如果您要時作，記得 o.get() 要換成 o.get.__call__() 喔let o = f();o.get(); // 42o.next();o.get(); // 43 上面實作我們將區域變數 n 換成 lexicalEnvironment 物件，然後具有一個屬性 n 。這時 Get 和 Next 的物件實例所存取的便是同一個參考(reference)即 lexical environment 物件。所以現在修改的就是相同的地方了。基本上這就是一個閉包的行為。 結論閉包是一個物件而且當它們是函數時我們可以直接調用。而事實上任何一個 Javascript 中的函數都是一個可被調用的物件也稱作 function object 或者 functor 當它們被執行或者說被實例化時會帶有一個私有的 lexical environment 物件。而想要更了解關於這個物件的看官們可以參考Lexical environment。在 Javascript 不是 function 創造閉包，function 本身就是一個閉包。 老實說譯者本身還是比較喜歡理解 context 與 variable object 的說明，接著用 一個閉包是一個函數能夠保留其建立時的執行環境 這句話來記憶。不過原作者從這個角度來解釋的確是可以概略的理解整個運作機制，希望這篇文章能讓你有所收穫。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"開發時期，CarrierWave 重產不同 version 圖片","slug":"carrierwave-recreate-version","date":"2016-02-22T16:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/02/23/carrierwave-recreate-version/","link":"","permalink":"//andyyou.github.io/2016/02/23/carrierwave-recreate-version/","excerpt":"","text":"當增加不同 version 的尺寸需要對已上傳的圖片從新產生新尺寸的圖片時 1&gt; rails c 輸入 1234Attachment.all.each do |att| att.image.recreate_versions! att.save!end","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"},{"name":"carrier wave","slug":"carrier-wave","permalink":"//andyyou.github.io/tags/carrier-wave/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"[譯] CSS 載入的未來","slug":"future-of-loading-css","date":"2016-02-17T16:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/02/18/future-of-loading-css/","link":"","permalink":"//andyyou.github.io/2016/02/18/future-of-loading-css/","excerpt":"","text":"這週閱讀到這篇有意思的文章，於是便動手寫下間單的翻譯，如果有理解錯誤的地方歡迎指教。 Chrome 正在試圖改變當 &lt;link rel=&quot;stylesheet&quot;&gt; 寫在 &lt;body&gt; 的行為，從 blink-dev 的文章並不能很清楚的知道其優點。所以這篇文章想要深入的介紹這點。 blink 是 Chrome 和 Opera 渲染引擎，而 blink-dev 是其開發社群 目前的 CSS 載入機制123456&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"/all-of-my-styles.css\"&gt;&lt;/head&gt;&lt;body&gt; …content…&lt;/body&gt; 當 CSS 段落在渲染時，會讓使用者瞪著白白的頁面直到 all-of-my-styles.css 完全下載完畢。 通常我們會把站內所有的 CSS 封裝成較少，可能只有一兩個資源檔，但這同時也意味著使用者需要下載大量的樣式設定(CSS Rules)卻沒有在該頁面使用。因為一個網站包含著各種不同的頁面與元件，而這些東西需要套用不同的樣式規則，如果因此分拆成許多檔案而產生大量的請求 request 這在 HTTP/1 是非常耗效能的。 不過在 SPDY 和 HTTP/2 卻不是這樣，傳輸許多分散的小資源只會增加一點點的開銷，並且這些東西可以個別暫存(cached)。 12345678910&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"/site-header.css\"&gt; &lt;link rel=\"stylesheet\" href=\"/article.css\"&gt; &lt;link rel=\"stylesheet\" href=\"/comment.css\"&gt; &lt;link rel=\"stylesheet\" href=\"/about-me.css\"&gt; &lt;link rel=\"stylesheet\" href=\"/site-footer.css\"&gt;&lt;/head&gt;&lt;body&gt; content&lt;/body&gt; 這樣一來就解決了許多問題，我們可以拆成很多小檔案個別載入，不過也意味著當我們在 &lt;head&gt; 下 &lt;link&gt; 時，得要知道這些頁面各自需要哪些資源。另外，瀏覽器在開始輸出之前，仍然得下載所有的 CSS。如果出現一個下載比較慢的 CSS 例如 /site-footer.css將會造成渲染的東西延遲。請觀察範例。 現階段載入 CSS 較先進的機制123456789101112131415161718192021222324&lt;head&gt; &lt;script&gt; // https://github.com/filamentgroup/loadCSS !function(e)&#123;\"use strict\" var n=function(n,t,o)&#123;function i(e)&#123;return f.body?e():void setTimeout(function()&#123;i(e)&#125;)&#125;var d,r,a,l,f=e.document,s=f.createElement(\"link\"),u=o||\"all\" return t?d=t:(r=(f.body||f.getElementsByTagName(\"head\")[0]).childNodes,d=r[r.length-1]),a=f.styleSheets,s.rel=\"stylesheet\",s.href=n,s.media=\"only x\",i(function()&#123;d.parentNode.insertBefore(s,t?d:d.nextSibling)&#125;),l=function(e)&#123;for(var n=s.href,t=a.length;t--;)if(a[t].href===n)return e() setTimeout(function()&#123;l(e)&#125;)&#125;,s.addEventListener&amp;&amp;s.addEventListener(\"load\",function()&#123;this.media=u&#125;),s.onloadcssdefined=l,l(function()&#123;s.media!==u&amp;&amp;(s.media=u)&#125;),s&#125; \"undefined\"!=typeof exports?exports.loadCSS=n:e.loadCSS=n&#125;(\"undefined\"!=typeof global?global:this) &lt;/script&gt; &lt;style&gt; /* The styles for the site header, plus: */ .main-article, .comments, .about-me, footer &#123; display: none; &#125; &lt;/style&gt; &lt;script&gt; loadCSS(\"/the-rest-of-the-styles.css\"); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 上面程式碼，我們有一些內嵌的樣式(inline style)來讓我們可以快速的渲染初始化的樣式，接著把那些還沒取得樣式的部分隱藏起來，然後開始透過 Javascript 非同步下載剩餘的樣式。這些剩餘的 CSS會覆寫掉在 .main-article 和其他選擇器內的 display: none。 這種第一次先快速的初始化渲染，然後持續匯入的方法是許多效能專家所推薦的。 為 CSS 傳送進行最佳化處理 How we make RWD sites load fast as heck Optimizing the Critical Rendering Path 看看範例 原作者實作了wiki-offline並將狀況紀錄如下圖 上面這張圖片是在 3G 的環境下測試。 不過這樣的方法還是有些不足的地方: 需要一個輕量的 Javascript 函式庫不幸的，因為 WebKit 的實作。當 &lt;link rel=&quot;stylesheet&quot;&gt; 一被加到頁面時，WebKit 會阻塞渲染(render)，直到樣式都被載入，即使這個樣式是透過 Javascript 加入的。 在 Firefox 和 IE/Edge，透過 JS 加入的樣式完全是非同步載入。Chrome 當前穩定版本然仍是遵循WebKit 的行為，不過在 Canary 已經跟 Firefox/Edge 一樣了。 載入流程被限制在兩個階段(Inline css and A css file)根據上面的模式，內嵌 CSS(inline CSS) 透過 display: none 隱藏尚未套用樣式的內容，然後非同步得載入 CSS 之後呈現內容。如果您需要增加多個 CSS 檔案那麼結果可能就是內容不按順序出現 檢視範例 如果內容還在異動的過程結果周圍的廣告就先出現這通常會讓使用者覺得不開心就關閉你的網站了。 因此被限制在只有兩個載入階段，你必須要決定哪些是第一次渲染時就要出現，哪些是比較晚的。當然，你希望上方的區塊越快顯示越好，不過所謂”上方的區塊”取決於 viewport 可視區域的大小。最後你可能決定定義一個尺寸範圍套用在所有人身上。 如果你想讓事情更加複雜，當然你可以選擇客製 CSS 相依屬性來建立 CSS 之間渲染的相依性 更簡單，更好的方式12345678910111213141516171819&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- HTTP/2 push this resource, or inline it, whichever's faster --&gt; &lt;link rel=\"stylesheet\" href=\"/site-header.css\"&gt; &lt;header&gt;…&lt;/header&gt; &lt;link rel=\"stylesheet\" href=\"/article.css\"&gt; &lt;main&gt;…&lt;/main&gt; &lt;link rel=\"stylesheet\" href=\"/comment.css\"&gt; &lt;section class=\"comments\"&gt;…&lt;/section&gt; &lt;link rel=\"stylesheet\" href=\"/about-me.css\"&gt; &lt;section class=\"about-me\"&gt;…&lt;/section&gt; &lt;link rel=\"stylesheet\" href=\"/site-footer.css\"&gt; &lt;footer&gt;…&lt;/footer&gt;&lt;/body&gt; 這個概念是透過每一個 &lt;link rel=&quot;stylesheet&quot;&gt; 在其下載樣式時去阻塞跟在後面的內容，但允許前面的內容先開始渲染。樣式表(CSS)本身的載入機制是平行的，但是套用樣式卻是要照順序的。這讓 &lt;link rel=&quot;stylesheet&quot;&gt; 的行為類似為 &lt;script&gt; 假設說 site-header, article, footer 的樣式已經載完了，但剩下的還沒，其行為如下： Header: 已輸出 Article: 已輸出 Comments: 未呈現，在該標籤之前地 CSS 還沒載完(./comment.css) About me: 未呈現，在該標籤之前地 CSS 還沒載完(./comment.css) Footer: 未呈現，在該標籤之前地 CSS 還沒載完(./comment.css)，即使自己的 CSS 已經載完了 這讓我們可以照順序輸出頁面。您甚至不需要決定哪些是”上面的區塊”，只要在元件之前匯入元件需要的 CSS 即可。 不過你還是需要注意當使用內容決定佈局(layout system)，例如 table, flexbox 時，在載入期間應避免內容異動。這不是現在才產生的問題了，只是在逐步顯示這種機制之下更常遇到。如果你看不懂這段在描述什麼看一下下面的影片就知道了。 意思是說雖然 flexbox 已經很不錯了，但 Grid 還是更推薦的 Layout system。 Chrome 的改變HTML規範並不涵蓋網頁渲染時是否應該或該如何被 CSS 阻塞，並且也不鼓勵把 &lt;link rel=&quot;stylesheet&quot;&gt; 寫在 body 中，不過所有瀏覽器都允許這麼做。 當然他們也都各自使用了自己的方式處理在 body 中的 &lt;link&gt; Chrome &amp; Safari: 一旦發現 &lt;link rel=&quot;stylesheet&quot;&gt; 就停止渲染(render)，直到發現的樣式被載入完畢。往往導致在 &lt;link&gt; 上面還未渲染的內容被卡住。 Firefox: &lt;link rel=&quot;stylesheet&quot;&gt; 在 &lt;head&gt; 中會阻塞渲染直到所有發現的樣式都被載入完畢。在 body 中的話不會阻塞渲染，除非 head 裡已經有樣式阻塞住這可能會導致 FOUC (Flash of unstyled content) ，就是畫面先以預設的樣子呈現後閃一下才套上樣式。 IE/Edge: 中斷分析器直到樣式載完，不過允許 &lt;link&gt; 上面的內容渲染(render)。 我們偏好像 IE/Edge 的行為，所以 Chrome 將會跟隨這樣的機制。目前 Chrome/Safari 的行為就只是會卡比較久的時間，Firefox 的行為相對較複雜一些，不過有一些小技巧。 Firefox 處理方式因為 Firefox 不會因為 body 中的 &lt;link&gt; 阻塞渲染。我們需要一點小技巧來避免 FOUC。幸虧有個非常簡單的方式就是透過 &lt;script&gt; 中斷解析器讓他等一等待處理狀態的樣式 12&lt;link rel=\"stylesheet\" href=\"/article.css\"&gt;&lt;script&gt; &lt;/script&gt;&lt;main&gt;…&lt;/main&gt; 這個標籤不能完全沒有內容，所以我們需要留一個”空白”。 實際執行的結果查閱範例 Firefox 和 Edge/IE 將會循序的載入輸出，而 Chrome 和 Safari 則是先看到空白的頁面一陣子直到CSS 全部載完。目前 Chrome/Safari 的行為比起把樣式連結放在 &lt;head&gt; 也沒有差到哪去，所以現在就可以開始使用這個方式，很快的 Chrome 將會往 Edge 的機制修正，這麼一來渲染會更加迅速。 以上就是一個簡單的技巧協助我們加快速度並逐步載入 CSS","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Javascript Array 筆記","slug":"javascript-array-methods","date":"2016-02-16T08:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/02/16/javascript-array-methods/","link":"","permalink":"//andyyou.github.io/2016/02/16/javascript-array-methods/","excerpt":"","text":"方法範例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// pushvar arr = [1, 2, 3];var result = arr.push(4); // result: 4, arr: [1, 2, 3, 4]// popvar arr = [1, 2, 3];var result = arr.pop(); // result: 3, arr: [1, 2]// lengthvar arr = [1, 2];arr.length; // 2// unshiftvar arr = [1, 2, 3];var result = arr.unshift(0); // result: 4, arr: [0, 1, 2, 3]// shiftvar arr = [1, 2, 3];var result = arr.shift(); // result: 1, arr: [2, 3]// splice 拼接// Array.splice(start_index, remove_num, element01, element02...)var arr = [1, 2, 3, 4, 5];var result01 = arr.splice(2, 1, 6); // result01: [3], arr: [1, 2, 6, 4, 5]var arr = [1, 2, 3, 4, 5];var result02 = arr.splice(2, 0, 6); // result02: [], arr: [1, 2, 6, 3, 5, 6]// 沒移除元素會放在該 index 元素會被往後推var arr = [1, 2, 3, 4, 5];var result03 = arr.splice(2, 0, 6, 7, 8) // result03: [], arr: [1, 2, 6, 7, 8, 3, 4, 5]// slice 切片var arr = [1, 2, 3, 4, 5];var result01 = arr.slice(1, 3); // result01: [2, 3], arr: [1, 2, 3, 4, 5]var arr = [1, 2, 3, 4, 5];var result02 = arr.slice(-2); // result02: [4, 5], arr: [1, 2, 3, 4, 5]var arr = [1, 2, 3, 4, 5];var result03 = arr.slice(-2, 0); // result03: [], arr: [1, 2, 3, 4, 5]var arr = [1, 2, 3, 4, 5];var result04 = arr.slice(0); // result04: [1, 2, 3, 4, 5], arr: [1, 2, 3, 4, 5]// indexOfvar arr = [1, 2, 3, 4, 5];var result01 = arr.indexOf(3); // result01: 2var arr = ['a', 'ab', 'abc', 'abcd'];var result02 = arr.indexOf('a'); // result02: 0var result03 = arr.indexOf('b'); // result03: -1var result04 = arr.indexOf('ab'); // result04: 1// lastIndexOfvar arr = [1, 2, 3, 2, 1];var result01 = arr.lastIndexOf(1); // result01: 4var arr = ['a', 'ab', 'abc', 'ab', 'a'];var result02 = arr.lastIndexOf('a'); // result02: 4var result03 = arr.lastIndexOf('b'); // result03: -1var result04 = arr.lastIndexOf('ab'); // result04: 3// some 陣列是否有元素符合測試var arr = [1, 2, 3, 4, 5];var result01 = arr.some(function (element, index, array) &#123; return element &gt; 3&#125;); // result01: truevar result02 = arr.some(element =&gt; element &gt; 5); // result02: false// every 陣列中是否所有元素都符合測試var arr = [1, 2, 3, 4, 5];var result01 = arr.every(function (element, index, array) &#123; return element &gt; 3&#125;); // result01: falsevar result02 = arr.every(element =&gt; element &lt; 6); // result02: true// join 串聯成字串var arr = [1, 2, 3, 4, 5];var result = arr.join(','); // result: \"1,2,3,4,5\"// sort 由小排到大var arr = [5, 4, 3, 2, 1];var result = arr.sort(); // result: [1, 2, 3, 4, 5], arr: [1, 2, 3, 4, 5]var arr = ['c', 'b', 'a', 0];var result = arr.sort(); // result: [0, 'a', 'b', 'c'], arr: [0, 'a', 'b', 'c']// reverse 由大排到小var arr = [1, 2, 3, 4, 5];var result = arr.reverse(); // result: [5, 4, 3, 2, 1], arr: [5, 4, 3, 2, 1]var arr = [0, 'a', 'b', 'c'];var result = arr.reverse(); // result: ['c', 'b', 'a', 0], arr: ['c', 'b', 'a', 0]// concat 組合並回傳一個新的陣列(flat element)var a = [1, 2];var b = [3, 4];var c = a.concat(b); // a: [1, 2], b: [3, 4], c: [1, 2, 3, 4]var d = [...a, ...b]; // a: [1, 2], b: [3, 4], d: [1, 2, 3, 4]var e = a.concat(0, [3, 4]); // e: [1, 2, 0, 3, 4]// forEachvar arr = [1, 2, 3, 4, 5];arr.forEach(function (element, index, array) &#123; console.log(element, index, array);&#125;);// 1, 0, [1, 2, 3, 4, 5]// 2, 1, [1, 2, 3, 4, 5]// 3, 2, [1, 2, 3, 4, 5]// 4, 3, [1, 2, 3, 4, 5]// 5, 4, [1, 2, 3, 4, 5]// 注意: 例外無法阻止 forEach 停止// map 遍歷所有元素至參數 callback 然後回傳一個新的陣列var arr = [1, 2, 3, 4, 5];var result01 = arr.map(function (element) &#123; return element + 10;&#125;); // arr: [1, 2, 3, 4, 5], result01: [ 11, 12, 13, 14, 15 ]var arr = [1, 4, 9];var result02 = arr.map(Math.sqrt); // arr: [1, 4, 6], result02: [1, 2 ,3]// filter 過濾元素，產生新陣列var arr = [1, 2, 3];var result = arr.filter(function (element) &#123; return element &gt; 2;&#125;); // arr: [1, 2, 3], result: [3]// reduce 從左至右當作累加器把陣列變成單值var arr = [1, 2, 3, 4, 5];var result = arr.reduce(function (previous, current, currentIndex, array) &#123; return previous + current;&#125;, 100); // result: 115// reduceRightvar arr = ['ab', 'bc', 'de'];var result = arr.reduceRight(function (pre, cur, index, arr) &#123; return pre + cur;&#125;, 'I am initial:'); // result: \"I am initial:debcab\"// 其他補充var a; // a: undefinedvar b = a += 2; // a: NaN, b: NaN =&gt; undefined += 2 =&gt; NaNvar a = null;var b = a += 2; // a:2, b: 2 Array.forEach 額外補充根據 MDN 的定義 arr.forEach(callback[, thisArg]) 當我們要在 forEach 的匿名函數中使用 this 我們可以透過 thisArg 來設定。如果不設定(undefined, null)或者不用 var self = this; 的方式保留 context，那麼預設會是指向 global 123456789101112131415var sum = 100;function Counter () &#123; this.sum = 0;&#125;Counter.prototype.add = function (arr) &#123; arr.forEach(function (el, i, arr) &#123; this.sum += el; &#125;)&#125;;var o = new Counter();o.add([1, 2, 3]);console.log(o.sum); // 0console.log(sum); // 106 在 Chrome 或者 Firefox console 底下執行的確會執向 global，但是在 nodejs v5.6.0 底下結果卻是 12console.log(o.sum); // 0console.log(sum); // 100 要注意。 正確的範例如下 1234567891011121314function Counter () &#123; this.sum = 0;&#125;Counter.prototype.add = function (arr) &#123; arr.forEach(function (el, i, arr) &#123; this.sum += el; &#125;, this); // &lt;-- here this \"thisArg\"&#125;var o = new Counter();o.add([1, 2, 3]);console.log(o.sum); // 6console.log(sum); // undefined callback methods filter (has thisArg) some (has thisArg) every (has thisArg) forEach (has thisArg) map (has thisArg) reduce reduceRight","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Chrome Dev tool 筆記","slug":"chrome-dev-tool","date":"2016-01-28T08:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/01/28/chrome-dev-tool/","link":"","permalink":"//andyyou.github.io/2016/01/28/chrome-dev-tool/","excerpt":"","text":"Element Panel ⌥⌘I 開啟 Dev Tool 選取元素的方式 對元素點右鍵 -&gt; Inspect 開啟 Dev Tool -&gt; 點擊 Dev Panel 左上角 bar 的箭頭 ICON -&gt; 選取元素 ⌘⇧C -&gt; 選取 編輯樣式 選定一個 Element 之後右邊 panel 會顯示該 Element 之樣式 開關樣式 新增或刪除樣式 右上角 -&gt; Change state(hover, active, focus, visited) Computed -&gt; 觀察 box model 點擊連結切換到 Source Shift + 點擊 CSS rule 的顏色會轉換 e.g. hex to rgb 編輯樣式時，選取某個字串 -&gt;Command+D會把一樣的都選起來 Source Panel 進入 Source panel ⌘S 可以暫時編輯檔案並存到瀏覽器的 Storage 右鍵 -&gt; Local Modifications 可以檢視歷史紀錄 Console12345678910111213console.log();console.assert(false, &apos;Information&apos;); // 錯了就噴第二個參數console.count(&apos;go&apos;); // go: 1console.count(&apos;go&apos;); // go: 2console.log(&quot;document body: %O&quot;, document.body);console.group(&quot;Authenticating user &apos;%s&apos;&quot;, user);console.log(&quot;User authenticated&quot;);console.groupEnd();console.log(&apos;%c Hello&apos;, &apos;color: orange;&apos;); // %c 使用 cssconsole.log(&quot;%O &quot;, document.body); // %O Javascript Objectconsole.log(&quot;%O &quot;, document.body); // %o DOM 詳細 Console API 學會查看 Error，切換到 Source 在 Source panel 下 ESC 開啟第二層 Console 123456$(&apos;selector&apos;) // 稱為 blind// 如果載入 jQuery 預設的 blind 會被覆寫// 回傳的是一個陣列inspect($(&apos;#title&apos;)) // 選取元素並切換到 Element Panel$0 // 當前選取的 Element$1 // 上一個 Source panel 右上角的 Pause on 按鈕打開的話，下次噴錯就會暫停 Source panel 左下角的 {} 按鈕可以把 minifed 檔案轉換成較易讀的格式 Local Storage 切換到 Resource panel Network panel Refresh 之後會記錄每個 Request ⇧ + Refresh 鍵強制全部重載 Size = Transfer size Content = Actual size 最底下的 Bar 有總和 Waterfall 裡面淺色的部分代表發出 request到回應即開始傳輸資料的時間 實心的部分代表開始下載資料 顏色的意義 HTML 藍色 JS 橘色 CSS 綠色 圖片 紫色 右邊垂直的藍色線代表 DOM loaded 意為瀏覽器解析完畢 HTML to DOM 右邊垂直紅色線則表示圖片等資源下載完畢 CSS 放在 JS 之前 Timeline 顏色的意義 Loading 藍色 執行 Script 黃色 Rendering 紫色 Painting 綠色 Size vs Content","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"chrome","slug":"chrome","permalink":"//andyyou.github.io/tags/chrome/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"從<琅琊榜>學 Redux","slug":"redux","date":"2016-01-04T06:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2016/01/04/redux/","link":"","permalink":"//andyyou.github.io/2016/01/04/redux/","excerpt":"前言這篇文章希望從另外一個角度來看關於 Redux 的機制與運用，在網路上各式的教學文章中值得先推薦的自然是官方教學如果英文不是很好的可以參考繁體中文版。這是小弟認為要學習 Redux 必讀的文件。另外還有A cartoon intro to redux也是值得一讀的好文可以加深記憶。 接著就讓我們開始吧，當然最後如果有任何錯誤，也歡迎您的指教。","text":"前言這篇文章希望從另外一個角度來看關於 Redux 的機制與運用，在網路上各式的教學文章中值得先推薦的自然是官方教學如果英文不是很好的可以參考繁體中文版。這是小弟認為要學習 Redux 必讀的文件。另外還有A cartoon intro to redux也是值得一讀的好文可以加深記憶。 接著就讓我們開始吧，當然最後如果有任何錯誤，也歡迎您的指教。 一個中國的古代智慧先別管 Flux, Redux,React 等術語了，在我們深入任何程式碼與實作之前讓我們先來聊一下關於中國的古裝宮廷劇的橋段。雖然連續劇上演的可能並不是古代真實的狀況，但就讓我們假設這樣的過程是對的。就讓我們從當紅電視劇 《琅琊榜》來聊起，相信你我都知道這樣的流程。當梁皇大大決定了要加封蕭景琰從郡王變成親王，這個時候皇上要做的就是下旨，下旨之後接著就需要一份實體的聖旨或稱詔書來完成整個流程。這份聖旨當然不是任何人都能撰寫的，它通常需要由內閣按照一定格式完成。聖旨完成之後，接著就需要太監們去負責傳旨這個流程，太監總管自然是可以差遣底下的太監去正式的宣旨，在這過程中我們合理的推測太監總管是會通知像是禮部這類單位去準備親王穿的新衣服等等。好了，我們已經講完了關於單一資料流與 Redux 了！？ 角色與其職上面的沒頭沒腦地說明讓你開始想關掉這篇文章了嗎？讓我們先用較為通俗的比喻來對應這個流程，雖然這的確不是很精確。但我相信在學習過程中多少能有點幫助。開始介紹各個角色與其對應之前先讓我們來看看 Redux 的世界裡有哪些主要角色？ state action action creator reducer store state 事件的狀態首先介紹的就是 state ，少了這個 state 那麼是無法交織出精彩的宮廷劇。這個 state表示的是一件事情的狀態，用上面的例子來說就是蕭景琰是不是親王。 action 聖旨在古代朝廷裡舉凡重要大事例如：加薪升職或者出兵打仗基本上都是需要聖旨，這個聖旨也就只是一份記錄下來，具備特定格式的文件。而在 Redux 中剛好有這麼一個角色，它就是 action 。基本上他就是一個單純的物件，記錄著要做什麼事，就像聖旨一般。 如下就是一個 action 在程式中的樣子 1234var action = &#123; type: &apos;加封親王&apos;, name: &apos;蕭景琰&apos; // 取自&lt;琅琊榜&gt;&#125; action creator 內閣這個角色在劇中通常我們會忽略，因為他的任務好無聊啊！就只是把要 執行的事情 格式化成特定的文件。講白一點，梁帝只說了一句話：加封蕭景琰為親王。自然就要有人來幫他寫完這份聖旨。 下面即 action creator 在程式中的範例：本質是一個 function 回傳 object ，這個 object 即 action 123456function actionCreator(data) &#123; return &#123; type: &apos;加封親王&apos;, name: &apos;蕭景琰&apos; // 取自&lt;琅琊榜&gt; &#125;;&#125; store 梁帝身旁的太監總管 - 高湛簡單來說，梁帝得知任何情報消息都是靠他，甚至要發聖旨也要靠他。在一般情況下太監總管幾乎等於皇上的 狀態管理中心 ，而且 就只有一個 ，管理一個國家和管理程式的狀態一樣複雜，如果到處都可以發動命令修改狀態那總會有狀態因為時間差不一致的狀況。 而要在程式中建立一個 store 我們需要先從 redux 匯入 createStore 接著如下建立 1var store = createStore(reducer) reducer 實際宣旨的太監 - 負責實際的狀態變更當太監總管把任務交代下來，底下的太監就要去執行任務，reducer 才是真正變更了狀態的角色。 雖然在劇中不是挺重要的角色，但在 Redux 所有的狀態都是由它進行異動的，要牢記的是 reducer 本質上是一個 function，必須要回傳 state 物件，最重要的是它永遠是傳入當前的 state 和 action 接著處理完後回傳另一個完整的 state ， 表示式為 (state, action) =&gt; newState。 流程在開演之前有些幕後工作要完成，首先是太監總管(store)要知道怎麼使喚部下(reducer)。 1store = createStore(reducer) createStore() 等於是前置作業，如此一來太監總管就知道該怎麼分派任務。當皇上下旨後，我們會需要內閣(action creator)的協助，得到一份聖旨(action)，接著太監總管(store)就分派(dispatch)聖旨(action)給底下的太監們(reducers)去執行。 1store.dispatch(action) 如果皇上想要知道事情的狀態那就得問太監總管 1store.getState() 另外就是當聖旨宣布後，太監總管應該也要順便通知禮部等單位進行後續的準備 1store.subscribe(listener) 這個 listener 就是當聖旨頒佈後後續要做的事，很合理的該單位總是也該知道事情進行到哪了，此時這個 function 便可以透過 getState() 來取得消息，不過要注意的是;這個太監總管不會先行通知，只會在發佈了聖旨後才會通知各部(listener)。 看到這邊我們才驚覺原來在古代的中國早就知道單一資料流的好處 XD。 而所謂的 Redux 概略的比喻就是各司其職的這些角色搭配運作流程的規範。最後讓我們先看一下概略示意虛擬碼： 12345678910111213141516171819202122232425262728293031323334353637// 注意: Javascript 的變數與 function name 並不支援中文// action typeconst 加封七珠親王 = &apos;加封七珠親王&apos;;// action creatorfunction 內閣撰寫聖旨加封 (人名, 官位) &#123; // 傳回一個 action return &#123; type: 加封七珠親王, name: 人名, level: 官位 &#125;&#125;// reducerfunction 負責的太監甲 (state, action) &#123; switch (action.type) &#123; case: 加封七珠親王: return &#123; ...state, &#123; ...state[action.name], level: action.level &#125; &#125;; default: return state; &#125;&#125;// storevar 太監總管 = createStore(太監們)// actionvar 聖旨 = 內閣撰寫聖旨加封(&apos;蕭景琰&apos;, &apos;親王&apos;)太監總管.dispatch(聖旨) 總體來說這邊只希望你記住三件事： 太監總管只有一個; 整個應用程式的 state，被儲存在一個樹狀物件放在唯一的 store 裡面。 要執行任何重大事件都需要聖旨; 改變 state 的唯一的方式是發出一個 action，也就是一個描述發生什麼事的物件。 實際去宣旨的是太監(reducer); state 的轉變必須只能在 reducer 撰寫，這永遠是一個 (state, action) =&gt; newState 的 function。 實作 Redux上面段落扯了這麼多，是希望用一個通俗的說明，讓您先大略明白整個流程，有個概念，接著我們就要以實作流程來說明。我相信目前網路上的教學不論詳細程度還是文章的質量都很難比官方教學來得好，但就是因為該文件太詳細了，有些緣由對於初學者來說不太好掌握，所以這個部分我希望能夠快速帶你走過一遍個人的實作流程，讓你能夠掌握每一個角色，有了概念後建議您搭配官方教學來深入學習。 從規劃 state 物件開始為了讓事情單純一點，我們將使用 Boilerplate 以避開一些繁瑣的設定，讓你能夠先專注在 redux 上。這個樣板包含了下面這些工具與函式庫的相關設定： webpack webpack-dev-server babel hot-reload react 建立專案指令如下： 123456&gt; git clone https://github.com/gaearon/react-hot-boilerplate.git demo // demo 可換成你喜歡的專案名稱&gt; cd demo&gt; npm install&gt; npm install redux -S# npm start 便可以開啟網站 現在，假設我們只有一個陣列 todos 要維護，這個 state 物件 結構如下 123&#123; todos: []&#125; 注意：這個 state 物件就是我們整個應用程式唯一的狀態管理中心，我們一般無法直接操作它，一切都是透過 store 管理，reducer 改變。 列舉出需要實作的行為 - action type我們只會實作一個行為 ADD_TODO 用來解釋每個角色之間的使用與關係，接著用你喜歡的編輯器開啟 demo 目錄之後，我們先建立 src/actions.js，我們使用 string 來替這些行為命名，這就是 action type。把 action type 宣告為常數並匯出不是必須的，你的確可以單純用字串就好，不過為了減少錯誤與重構的好處我們還是使用了常數的方式。 123456789101112131415/* file: src/actions.js */// action typeexport const ADD_TODO = &apos;ADD_TODO&apos;/** * action creator * 有一個 action type 就需要對應一個 action creator 用來格式化需要的資料 * 本質是一個 function 回傳一個 object 裡面包含著要執行的行為和需要的資料 */export function addTodo() &#123; return &#123; type: ADD_TODO &#125;&#125; 透過 root reducer 定義資料結構在此我們不深入探討原理，只需要知道使用 combineReducers() 傳入的物件參數等於我們最後會得到的 state 物件。 建立 src/reducers.js 並輸入程式碼如下： 1234567891011121314/* file: src/reducers.js */import &#123;combineReducers&#125; from &apos;redux&apos;import &#123;ADD_TODO&#125; from &apos;./actions&apos;/** * root reducer 就是決定 state 屬性的地方 */const rootReducer = combineReducers(&#123; // 這邊等於 state 規劃的 property todos&#125;)export default rootReducer 透過 reducer 實作變更 state 的行為用一個舊有的經驗來比喻，combineReducers 的參數部分所定義的物件，就像是我們在規劃資料庫時定義資料表(Table)一般。至於內部欄位還得靠真正被傳進去的那些 reducer 。所以實際的欄位操作得在 reducer 定義。 123456789101112131415161718192021222324252627282930313233/* file: src/reducers.js */import &#123;combineReducers&#125; from &apos;redux&apos;import &#123;ADD_TODO&#125; from &apos;./actions&apos;/** * root reducer 就是決定 state 屬性的地方 */const rootReducer = combineReducers(&#123; // 這邊等於 state 規劃的 property todos&#125;)/** * reducer: 依據 rootReducer 的屬性實作 reducer 這個 function * 注意: action 除了 type 外，還要包含修改 state 所需要的資料 * 這個資料可能是索引或者要加入的資料 * */function todos (state = [], action) &#123; switch (action.type) &#123; case ADD_TODO: return [ ...state, action.todo ] // 處理不符合 action.type 的部分，一定要回傳 state default: return state &#125;&#125;export default rootReducer 記住! reducer 是一個純函式遵循著 (state, action) =&gt; newState 的結構規範，且不得在內部產生任何 side effect。簡單說 reducer 這個函式的工作就是把 state 和 action 當作參數傳入，回傳另外一個變更後的 state，這個 state 因為不能有 side effect 所以回傳的是另外一個全新的物件。 再次強調 (state, action) =&gt; newState 所以就算你傳入的 action 跟該 reducer 無關，你也要再把 state 傳回去。記住上面的表示式，非常重要。 action 只是一個聖旨記錄了要執行的事情，而 reducer 才是實際處理 state 的地方。 根據 reducer 所需，收斂整理出需要的資料，完善 action creator 和 action這一步會隨個人習慣有所差異，有人能夠在一開始就把 action 需要的資料都定義好，但對於反應較慢的小弟我來說反過來從 reducer 推回去比較直覺一點。 重點是 action 除了 action.type 即我們的任務之外還要包含處理這個任務所需要的資料。而剛剛的 reducer 我們先假定了有 action.todo，所以讓我們回到 src/actions.js 來完善他們 123456789101112/* file: src/actions.js */// Action Typeexport const ADD_TODO = &apos;ADD_TODO&apos;;// Action Creatorexport function addTodo(todo) &#123; return &#123; type: ADD_TODO, todo &#125;&#125; store 的建立與實際測試到了這一步，我們可以來釐清這些角色之間的關係與該如何使用，開啟 src/index.js ，刪去預設產生的程式碼，改寫如下 123456789101112131415161718/* file: src/index.js */// 匯入 action creator: addTodoimport &#123;addTodo&#125; from &apos;./actions&apos;import &#123; createStore &#125; from &apos;redux&apos;import rootReducer from &apos;./reducers&apos;var store = createStore(rootReducer);var unsubscribe = store.subscribe(() =&gt; &#123; console.log(store.getState())&#125;);console.log(&apos;Initial:&apos;, store.getState());store.dispatch(addTodo(&apos;Hello, Redux&apos;)); 相信到這邊你已經明白 redux 的流程是怎麼回事了。 先設計一個單純只負責呈現的 component這部分我們要開始參透 redux 如何和 react 搭配使用，我假設你已經很了解 react ，因為這篇文章訴求是說明概念，因此就不在檔案架構上做太多分類切割。 我們的這個 component 其實就只需要 一個 input 用來把資料丟進 todos 這個陣列 一個 button 觸發儲存的行為 一個 ul li 結構用來顯示 todos 當然下面這樣的做法在實務上不是很好，但希望可以協助你方便觀察理解角色之間的應用，所以我就把他們全部放在一個檔案裡。 開啟 src/App.js 編輯程式碼如下 1234567891011121314151617181920/* file: src/App.js */import React, &#123; Component &#125; from &apos;react&apos;;export default class App extends Component &#123; render() &#123; const &#123;todos&#125; = this.props; return ( &lt;div&gt; &lt;input type=&apos;text&apos; ref=&apos;input&apos; /&gt; &lt;button&gt;Add&lt;/button&gt; &lt;ul&gt; &#123; todos.map((todo, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;todo&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125; 測試 component為了方便觀察所以並沒有把剛剛測試 store 的程式碼移除，釐清角色之間的關係而後依據目錄拆分檔案會更有幫助： 1234567891011121314151617181920212223/* file: src/index.js */import &#123; addTodo &#125; from &apos;./actions&apos;import &#123; createStore &#125; from &apos;redux&apos;import rootReducer from &apos;./reducers&apos;var store = createStore(rootReducer);import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import App from &apos;./App&apos;var unsubscribe = store.subscribe(() =&gt; &#123; console.log(store.getState())&#125;);console.log(&apos;Initial:&apos;, store.getState());store.dispatch(addTodo(&apos;Hello, Redux&apos;));render( &lt;App todos=&#123;[&apos;A&apos;, &apos;B&apos;]&#125; /&gt;, document.getElementById(&apos;root&apos;)) 將 component 與 store 連線store 和我們的 component 並不會無緣無故自訂就關聯起來，可以見得的是我們需要一個介面或一個做法來將他們倆關聯起來，而要將 store 與我們的 component 連線我們就需要 react-redux。 1&gt; npm install react-redux -S 接著在 src/index.js 完成程式碼如下 123456789101112131415161718192021222324252627/* file: src/index.js */import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import &#123; addTodo &#125; from &apos;./actions&apos;import &#123; createStore &#125; from &apos;redux&apos;import App from &apos;./App&apos;import rootReducer from &apos;./reducers&apos;// 匯入 Providerimport &#123; Provider &#125; from &apos;react-redux&apos;var store = createStore(rootReducer);var unsubscribe = store.subscribe(() =&gt; &#123; console.log(store.getState())&#125;);console.log(&apos;Initial:&apos;, store.getState());store.dispatch(addTodo(&apos;Hello, Redux&apos;));render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)) 看看上面的程式碼是不是很容易聯想到我們以前從資料庫取資料的流程，我們會需要針對特定的資料庫例如 MySQL, PostgreSQL 的 provider 函式庫，而在 redux 我們則是透過 Provider 這個方式提供一個介面讓我們的 component 能夠和 store 連線上，而實際上該如何使用還是得靠元件內部來實作。 最後實作 App 內部123456789101112131415161718192021222324252627282930/* file: src/App.js */import React, &#123; Component &#125; from &apos;react&apos;import &#123;connect&#125; from &apos;react-redux&apos;import &#123;addTodo&#125; from &apos;./actions&apos;class App extends Component &#123; render() &#123; var &#123;dispatch, todos &#125; = this.props; return ( &lt;div&gt; &lt;input type=&apos;text&apos; ref=&apos;input&apos;/&gt; &lt;button onClick=&#123;(e) =&gt; dispatch(addTodo(this.refs.input.value))&#125;&gt; Add &lt;/button&gt; &lt;ul&gt; &#123; todos.map((todo, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;todo&#125;&lt;/li&gt;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;function select (state) &#123; return state;&#125;export default connect(select)(App); select 和 connect 是什麼？connect 的用途概念上比較容易理解，我們已經有 Provider 了，但我們還是需要主動去連線。而 select 如果你用資料庫的概念來想也就非常清楚了，雖然我有一個資料庫但我並不總是要全部的資料，透過 select 可以讓我們選取我們要的部分就好。但是在上面的範例我們是全取。 總結如此我們已經走完了一遍最基礎的部分，也對各角色有了概念上的理解，這和實際原理其實有些落差。不過在學習的過程中我希望提供另一個角度的看法。當然小弟很清楚這篇文章還有很多有缺失的地方，所以才會建議當你對 redux 的掌握度有些許的進步之後一定要回頭看看官方的教學。 針對 App 的功能操作列出需要的 action type 根據 action type 實作 action creator 與定義回傳的 action，記住 reducer 需要的資料只能從這來 先構思完整的 state 結構，盡可能保持一階的結構類似資料庫正規劃 針對資料的處理 root reducer 和 reducer 透過 combineReducers() 組合 state 與對應的 reducer，概念上類似於資料庫的 Table 列表 一個 reducer 純函式 (state, action) =&gt; newState 是針對 state 撰寫處理狀態修改的邏輯 每一個 reducer 都需要針對未知的動作類型(action.type)做處理，無論如何都要傳回 state 透過 createStore(reducer) 建立一個 store。 透過 react-redux 的 Provider 來把 store 與 component 關聯起來 component 內部透過 connect 連線並取得資料，搭配 select (只是一個 filter 的 function) 資源 官方教學 繁體中文版 介紹 Redux 卡通版","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"},{"name":"redux","slug":"redux","permalink":"//andyyou.github.io/tags/redux/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"NodeJS path","slug":"nodejs-path","date":"2015-12-16T21:10:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/12/17/nodejs-path/","link":"","permalink":"//andyyou.github.io/2015/12/17/nodejs-path/","excerpt":"","text":"範例筆記 123456789101112131415161718192021222324252627282930313233343536373839/** * 詳細教學 * http://www.tutorialspoint.com/nodejs/nodejs_path_module.htm */// 正常化path.normalize(&apos;/1/../2&apos;); // =&gt; /2// 把所有路徑整合在一起並且正常化path.join(&apos;a&apos;, &apos;b&apos;); // =&gt;&apos;a/b&apos;path.join(&apos;a&apos;, &apos;./b&apos;); // =&gt; a/b&apos;path.join(&apos;a&apos;, &apos;/b&apos;); // =&gt;&apos;a/b&apos;path.join(&apos;/1&apos;, &apos;/2/3&apos;, &apos;../4&apos;); // =&gt; /1/2/4// 從第一個路徑，照著後面切換最後回傳絕對路徑path.resolve(&apos;/from&apos;, &apos;/to/path1&apos;, &apos;/to/path2&apos;); // =&gt; /to/path2path.isAbsolute(&apos;/&apos;); // =&gt; true// 從 from 到 to 的相對路徑path.relative(&apos;..&apos;, &apos;./A/B&apos;); // =&gt; [project]/A/B// 回傳該檔案所在的目錄path.dirname(&apos;node_modules/bin/webpack&apos;); // =&gt; node_modules/binpath.dirname(&apos;./node_modules/bin/webpack&apos;); // =&gt; ./node_modules/bin// 回傳路徑最後的部分，包含副檔名path.basename(&apos;node_modules/bin/webpack&apos;); // =&gt; webpackpath.basename(&apos;/1/2/3.js&apos;); // =&gt; 3.js// 只取副檔名 + .path.extname(&apos;/1/2/3.js&apos;); // =&gt; .js// 將路徑解析成物件path.parse(&apos;/1/2/3.js&apos;); // =&gt;// 從物件轉成字串path.format(&#123; root: &apos;/&apos;, dir: &apos;/1/2&apos;, base: &apos;3.js&apos;, ext: &apos;.js&apos;, name: &apos;3&apos; &#125;); // =&gt; /1/2/3.js","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"//andyyou.github.io/tags/nodejs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"深入 React 生命週期","slug":"react-lifecycle","date":"2015-12-16T21:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/12/17/react-lifecycle/","link":"","permalink":"//andyyou.github.io/2015/12/17/react-lifecycle/","excerpt":"","text":"各種情況的生命週期流程大致上元件執行生命週期方法的情形可分為四種 初始化，第一次 render getDefaultProps() getInitialState() componentWillMount() render() componentDidMount() props 發生改變時 componentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render() componentDidUpdate(prevProps, prevState) state 發生改變時 shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render() componentDidUpdate(prevProps, prevState) 元件 unmount 卸載時 componentWillUnmount() 當遇到複合式元件的狀況時，子元件的生命週期從父元件 render 之後開始發動 一旦父元件發生改變，子元件的 componentWillReceiveProps 還是會觸發。也就是每次父元件更新，子元件都會重新渲染(Update流程) 當使用 React.createClass 建立一個 component 時， render 是生命週期方法中必須的。 當 render 被呼叫時會去檢查 this.props, this.state 並且只能回傳一個 component 意即其他元素都要包在這個元件底下。 render return null 或者 false 則表示不渲染輸出，背地裡 React 則是輸出 &lt;noscript&gt; 標籤。 不可以在 render 裡面操作修改 state 和 props。 getInitialState 一定要回傳物件或 null，在元件被 mounted 之前僅被呼叫一次。 getDefaultProps 如果回傳一個物件，會和所有元件的實例物件共用，傳址不是傳值。 第一次初始化的流程 displayName 用來設定元件名稱 getDefaultProps() 當元件類別被建立時就會觸發，且和所有實例物件共享 getInitialState() 開始渲染元件時初始化 componentWillMount() 準備掛載 DOM 之前觸發 render() 執行輸出 如果裡面有其他的子元件則依據上面的流程 getInitialState() -&gt; componentWillMount() -&gt; render() -&gt; componentDidMount() componentDidMount() DOM 完成之後立即觸發(會等到子元件都完成才觸發) 更新的流程 componentWillReceiveProps(nextProps) 這邊使用 setState 不會再觸發一次 render。初始化不會被觸發 shouldComponentUpdate(nextProps, nextState) 元件是否要更新 componentWillUpdate(nextProps, nextState) 將要更新之前，不可以用 setState render() componentDidUpdate(prevProps, prevState) 呼叫 setState 不會 re-render 的方法 componentWillMount() componentWillReceiveProps() 存取 DOM 的適當時機 componentDidMount() 不得使用 setState 的事件 shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render()","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React Native Push Notifications","slug":"how-to-use-push-notification-in-react-native","date":"2015-12-07T21:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/12/08/how-to-use-push-notification-in-react-native/","link":"","permalink":"//andyyou.github.io/2015/12/08/how-to-use-push-notification-in-react-native/","excerpt":"在 React Native 中的 Push NotificationsReact Native 官方在 v0.13+ 之後支援 Push notifications 然而在這篇文章撰寫時仍然未實做完所有功能。現階段只支援靜態的推播通知，另外關於錯誤處理的功能也還在開發中Error handling","text":"在 React Native 中的 Push NotificationsReact Native 官方在 v0.13+ 之後支援 Push notifications 然而在這篇文章撰寫時仍然未實做完所有功能。現階段只支援靜態的推播通知，另外關於錯誤處理的功能也還在開發中Error handling React Native v0.12對於上面的說法你可能有些疑問，事實會說在 0.13 支援是因為 0.12 的推播功能有些 Bug 不過在 0.13 時已經處理掉了。其實 0.12 也可以用，這篇文章會包含如何修好該 Bug 的步驟。 步驟為了要能夠在 React native 中使用推播通知的功能我們需要完成下面的步驟 匯入 Push Notification 函式庫 加入表頭檔路徑 (header path) 修改 AppDelegate.m 建立憑證與開啟推播功能 撰寫程式碼完成功能 匯入函式庫第一步我們要做的就是加入 PushNotificationIOS 函式庫。這一步在官方文件中已經說明得非常清楚了你可以選擇看官方的或者下面的說明 使用 Xcode 開啟專案 在左邊檔案導覽區塊中展開 Library 目錄 透過 Finder 開啟專案並且找到 node_modules/react-native/Libraries/PushNotificationIOS 把這個 RCTPushNotification.xcodeproj 拖到 Libraries 目錄下 現在這個函式庫已經被加入到專案中了，下一步我們需要連結 binary 檔案。 點擊左側導覽區中的專案檔如下圖 1 的地方然後切換到 Build Phases 2 把 libRCTPushNotification.a 拖到 Link Binary With Libraries 如上圖 3 處 對大部分的 React native 函式庫來說加入專案中並關聯就完成設定了。不過如果我們是要使用 PushNotification 函式庫我們還需要其他的設定 加入表頭檔路徑到此函式庫已經被夾到專案中了，我們需要加入表頭檔路徑(Header Path)。這個步驟只有在當我們在編譯時需要用到函式庫內容才會需要做例如 PushNotificationIOS 和 LinkingIOS 否則這個步驟是可以省略的。要加入 Header Path 如下步驟 一樣點擊導覽區的專案如下圖 1 處 切換到 Build Settings 圖 2 搜尋 header search paths 如圖 3 Header Search Paths 欄位的路徑上點擊兩下 加入新的路徑如圖 4 取得該 Library 需要的檔案的路徑如圖 5 一般 React Native app 要填入的路徑 $(SRCROOT)/node_modules/react-native/Libraries 請確認一下該路徑後面是 recursive 如圖 6 加入的 Header Search Path 的意義，在原生 Obj-C 這個路徑就是當我們要 import 函式庫時該去哪些路徑找檔案勒就像是 JS 中 require 預設的路徑是 node_modules如此一來我們在 AppDelegate.m 匯入的時候才找得到檔案 修改 AppDelegate.m這個 PushNotificationIOS 函式庫使用了一些 Obj-C 的方法來完成註冊與接收推播訊息。然而這些方法只能夠在 AppDelegate 中使用。想想也很合理的，因為他是 Obj-C 的方法，因此我們需要加入一些程式碼將資料從 AppDelegate 傳到 PushNotificationIOS 第一步我們需要匯入 RCTPushNotificationManager.h 到 AppDelegate.m 1#import \"RCTPushNotificationManager.h\" 第二件事我們需要加入幾行程式碼 1234567891011// Required for the register event.- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; [RCTPushNotificationManager application:application didRegisterForRemoteNotificationsWithDeviceToken:deviceToken];&#125;// Required for the notification event.- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)notification&#123; [RCTPushNotificationManager application:application didReceiveRemoteNotification:notification];&#125; 少了這幾行程式，資訊將無法被傳遞到 PushNotificationIOS 替 v0.12 修補 Bug只有在專案使用的 React Native 版本是 0.12 或更早之前的才需要下面步驟這是舊版的 Bug 他導致了在 iOS8 以後的手機系統無法正常推播，意味著 0.12 遇上最新的 iOS 會不正常。下面的步驟則是修好這個 Bug 在 Xcode 中到 Library 目錄下打開 RCTPushNotification.xcodeproj/RCTPushNotificationManager.m 捲到大概 155 行 如果你使用的是 v0.11 或更早的版本 換成下面這段程式碼 123456789101112131415UIApplication *app = [UIApplication sharedApplication];if ([app respondsToSelector:@selector(registerUserNotificationSettings:)])&#123;UIUserNotificationSettings *notificationSettings = [UIUserNotificationSettings settingsForTypes:(NSUInteger)types categories:nil];[app registerUserNotificationSettings:notificationSettings];[app registerForRemoteNotifications];&#125; else &#123;[app registerForRemoteNotificationTypes:(NSUInteger)types];&#125; 如果使用的是 v0.12 換成下面的程式碼 123456789101112131415UIApplication *app = RCTSharedApplication();if ([app respondsToSelector:@selector(registerUserNotificationSettings:)])&#123;UIUserNotificationSettings *notificationSettings = [UIUserNotificationSettings settingsForTypes:(NSUInteger)types categories:nil];[app registerUserNotificationSettings:notificationSettings];[app registerForRemoteNotifications];&#125; else &#123;[app registerForRemoteNotificationTypes:(NSUInteger)types];&#125; 存檔然後 Bug 就修復了 現在我們已經把 React native 專案需要的部分都處理好了，接下來要使用推託我們必須要取得憑證 憑證設定也許你可能知道推播功能是透過 Apple 的 Server 傳到你的程式。並且為了讓功能能夠運作我們需要取得一些憑證這部分 Parse 有提供一份非常詳細的教學針對本文的部分只需要 step 1 Creating the SSL certificate 和 step 2 Creating the Provisioning Profile 一旦你完成這個步驟我們就可以開始使用推播功能了 使用推播功能在 React native 中推播功能的 API 非常直覺。也可以透過官方的文件來學習。 概覽用法首須我們需要在 Javascript 中匯入 PushNotificationIOS 1234567var &#123; AppRegistry, StyleSheet, Text, View, PushNotificationIOS // &lt;- 加入這一行&#125; = React; 取得權限在本機上要使用這個功能需要跟用戶要權限，要注意的是模擬器並不能夠使用推播必須要在實機上測試。 1PushNotificationIOS.requestPermissions(); 註冊事件當使用者註冊了接收遠端通知的時候會被觸發，透過這個事件可以取得裝置的 token 123PushNotificationIOS.addEventListener(‘register’, function(token)&#123; console.log(‘You are registered and the device token is: ‘,token)&#125;); 通知事件當收到推播通知的時候，繫結的函式會被觸發 123PushNotificationIOS.addEventListener(‘notification’, function(notification)&#123; console.log(‘You have received a new notification!’, notification);&#125;); 錯誤處理事件在這個時間點你不會看到 PushNotificationIOS 產生任何錯誤。一般來說在 iOS 例如你的憑證失效時你應該會取得錯誤訊息或者是在模擬器執行的時候，不過現階段這些錯誤都不會觸發 你可以持續關注Pull Request來看此功能是否被整合或者有其他更好的做法。 該如何傳送一個推播通知為了要能夠發送推播我們會需要一個後端和憑證，這個部分我們有下面幾種做法 使用服務採用外面的服務例如 Parse 或者 Urban Airship 建立自己的後端程式 NodeJS - node-apn Ruby - houston 憑證過程中我們可能還需要一些憑證這個時候可以參考StackOverflow的解答 參考How to use Push Notifications in React-Native (IOS)","categories":[{"name":"Mobile","slug":"Mobile","permalink":"//andyyou.github.io/categories/Mobile/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"},{"name":"react native","slug":"react-native","permalink":"//andyyou.github.io/tags/react-native/"}],"keywords":[{"name":"Mobile","slug":"Mobile","permalink":"//andyyou.github.io/categories/Mobile/"}]},{"title":"React Virtual DOM vs Incremental DOM vs Ember’s Glimmer","slug":"virtual-dom-vs-incremental-dom-vs-glimmer","date":"2015-11-29T21:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/11/30/virtual-dom-vs-incremental-dom-vs-glimmer/","link":"","permalink":"//andyyou.github.io/2015/11/30/virtual-dom-vs-incremental-dom-vs-glimmer/","excerpt":"這篇文章翻譯自 React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight 在這篇文章我們將要探討三個用來動態建立操作 DOM 的技術。當然我們也會測試紀錄其效能並且找出誰比較快。最後我們當然會分享為什麼我們選擇了其中之一用在我們的專案上。","text":"這篇文章翻譯自 React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight 在這篇文章我們將要探討三個用來動態建立操作 DOM 的技術。當然我們也會測試紀錄其效能並且找出誰比較快。最後我們當然會分享為什麼我們選擇了其中之一用在我們的專案上。 介紹在網路上有許多關於操作 Document Object Model(DOM) 的框架和函式庫。在他們之中有三個值得我們注意，因為他們的核心專注在提升效能上。React.js, Ember.js, 和最近開始崛起的 Incremental DOM。 而 React.js 和 Ember.js 提供更多功能不僅僅是建立和更新 DOMIncremental DOM 只專注在建立 DOM 樹狀結構以及讓他們可以動態更新。下面我們將探索這些框架或函式庫誰比較快一點。 在我們深入介紹分析之前如果你不是網頁設計師你也許會問什麼是 DOM 操作？通常網站是透過我們定義不同的元素 element 來構成一個樹狀結構，透過這個樹狀結構的物件來呈現網站，而這些我們稱為元素的東西就是 HTML 規範所定義的那些標籤 透過組織這些元素，開發者可以建立他們想要的網站。而 DOM 就是將一個網站的外觀透過元素來表示，例如我們可以透過 &lt;input&gt; 轉換成使用者看到的輸入框這些標籤元素是 W3C 定義的然後瀏覽器的開發商實作，最後當我們在 HTML 檔案中使用時即會呈現該元素。也因此我們可以理解隨著我們對於 UIUX 的需求，我們很常會需要動態去更新這些元素，就是當使用者與之互動時產生變化。 除了幫助我們把資料跟視覺呈現的 VIEW 繫結在一起外，上面提到的函式庫通常也會協助我們有效率的去更新 DOM。一般來說一系列的操作會對應到呼叫一系列的 DOM API 而這些呼叫會自動打包成一個呼叫或者是自動精簡調用的次數。舉例來說假設來說當我們更新了資料之後我們可能需要 移除該元素 加入新元素 修改新加入元素的屬性 所以我們會直接透過呼叫 DOM API 來執行這些變更。然後網站就會立即的呈現出我們的異動。但是這樣一步一步操作是很浪費效能的。如果換成透過虛擬模型的機制這些步驟可以被精簡到剩下一步 樣板 Templates一種非常好用且流行的一種方式就是透過樣板來建立 DOM 結構。開發者可以使用特定語法來告訴編譯器如何轉換成 DOM 結構即 HTML 文件。樣板大多看起來就像是增強版的 HTML 就是 HTML 多了一些額外的語法(.erb, .ejs)，也可能完全是另外一種(.jade, .slim)雖然樣板用起來非常直覺但並不是所有函式庫都偏好這種方式，舉例來說 React 就偏好使用 JSX，算是擴展 JS 的一種語法而不是 HTML，他允許我們在 JS 中插入一些類似 HTML 的語法另一方面 Ember 則偏好使用 Handlebars 樣板引擎 Incremental DOM 並不偏好特定樣版引擎，雖然說是不偏好特定但是 closure-templates 正默默地在開發中。Incremental DOM 也可以搭配 superview.js, starplate 甚至是 JSX React.js 的 Virtual DOMVirtual DOM 是 React 開發者給這套 DOM 操作引擎取的名字。Virtual DOM 提供一系列方法來讓函式庫知道該如何建立一個在記憶體中的 DOM 樹狀結構同時也讓其知道該如何更新那些綁定繫結的資料。關於 Virtual DOM 最重要的部分就是其辨識差異的邏輯。一旦模型被改變就會對應到記憶體中的 DOM 副本，接著這套演算法就會找出最少次數的操作來完成所有的更新 DOM 的動作。 優點 快速的辨識差異演算法 輕量化，在行動裝置上也可以使用 非常多媒體，個人 Blog 強力推薦 即使沒有 React 也可以使用 多個前端能夠使用 缺點 所有 DOM 副本都在記憶體中(高記憶體使用) 靜態和動態元素沒有分別 另外 React 已經著手在開發偵測那些靜態元素以減少檢查是否需要更新的元素數量 Ember 的 GlimmerGlimmer 是 Ember.js 最新渲染引擎的名字。 Glimmer 是 Ember 開發者試圖要在 Ember 中加入 React Virtual DOM 優點但既有的 API 仍然相容的成果Glimmer 幾乎是全部重寫 Ember 的渲染引擎並且沒有使用任何 Virtual DOM 的程式碼 在 Glimmer 中分成靜態和動態的元件，因此降低了需要確認是否更新的元素，這樣的區隔可以被實現多虧了 Handlebar 的樣板 另外一個 Glimmer 和其他解決方案的關鍵差異在於節點儲存和比對的方式。Glimmer 透過類似串流方式的物件而不是類似於 DOM 節點的物件。為了找出哪個節點需要被更新，Glimmer 的節點資料會一直跟最新得到的節點資料做比對，如果資料沒有異動就完全不需要執行任何動作 優點 快速的差異比對演算法 靜態與動態元素區隔 完全相容於 Ember 的 API 使用記憶體的部分較少 缺點 只能夠搭配 Ember 使用 只有一個前端能使用 Incremental DOMIncremental DOM 試圖要帶來更簡單的方式來處理這個問題，不在記憶體中保存整個 DOM 副本也不產生輕量化的物件型態來儲存樹狀結構的資料。Incremental DOM 使用的就是原本的 DOM 來找出資料異動的元素。你可能會問為什麼？如果這件事這麼簡單，就不需要有其他的解決方案啦它其實就是在速度和記憶體中取得一個平衡，Incremental DOM 透過移除多餘的 DOM 副本其結果就可以減少一些記憶體的使用。在實務上當然在檢查差異的時候也會降低一些速度，降低記憶體的使用主要是為了行動裝置和一些記憶體有限的裝置。 優點 降低記憶體的使用 簡單的 API 容易和許多前端框架整合 缺點 並不像其他兩者這麼快，不過這點還有點爭議下面我們會看實際的測試資料 較少社群使用 效能測試我們將挑選 dbmonster test app 來做一系列的測試，dbmonster 是一個簡單的應用程式它模擬應用程式更新大量資料時的狀況這個程式是原本是 Ember 團隊用來測試效能的，我們將使用 React, Ember 1.x 和 2.x (都具備 Glimmer) 還有 Incremental DOM所有的測試都在 Linux (Core i5-5200U CPU) 的 Chromium 46 版本執行。每個測試執行 5 次然後平均 在這兩張圖中顯示記憶體回收的時間，如同預測 Incremental DOM 在這個部分非常有效率在 MajorGC 的部分非常接近 Incremental DOM 但到了 MinorGC 就突然被拉開了。不過在上兩張圖比較有意思的是關於Ember 在 1 和 2 之間的改進的程度 在渲染輸出與繪圖方面 Ember 則表現得比其他人還要突出，Incremental DOM 則因為降低了記憶體影響了速度，在這方面 React 仍然保持第二名且非常接近 Ember 這張圖則顯示出因為長時間停止導致 Chrome 決定要移除的 frames 數量 這個數據越大將會導致有感的閃一下畫面。這一次 Incremental DOM 再次勝出，因為其花比較少的時間在 GC 意味著更多的時間可以去畫 frames其他三者差異不大 一個圖表上無法顯示出來比較重要的點是當使用瀏覽器時 Incremental DOM 感覺會比較快因為幾乎是及時回饋，不會閃一下。觀察其他收集的資料顯示 Incremental DOM 調用 Javascript 呼叫的次數相對少。不過我們還是得說 Incremental DOM 只是動態更新 DOM 的一套函式庫，而 React 和 Ember 可以處理更多事情，像是事件啊，資料的傳入等等 可以參考一下這個測試的彙整表 總結Virtual DOM, Glimmer, 和 Incremental DOM 在處理動態 DOM 操作與更新這方面都是不錯的選擇。不過因為 React 這陣子較多人在參與以及容易整合雖然使用較多的記憶體不過這個問題影響卻越來越小因為行動裝置搭載了越來越大的記憶體。Incremental DOM 的確是令人驚艷。我們期待看到 Incremental DOM 整合到其他函式庫。 React 和 Ember 事實上都取得在實務上的平衡並且二者採用了不同的方式，不過當要挑選一個函式庫時我們傾向優先關注在是否有大量使用者和是否容易整合。不過凡事還是要謹慎求證，你應該質疑這篇文章所說的並且實際跑一次自己的效能測試。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"framework","slug":"framework","permalink":"//andyyou.github.io/tags/framework/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"認識 ES6 Decorator ","slug":"explore-es2016-decorator","date":"2015-10-14T21:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/10/15/explore-es2016-decorator/","link":"","permalink":"//andyyou.github.io/2015/10/15/explore-es2016-decorator/","excerpt":"在這篇文章中我們將要探討如何使用 ES7 的新功能. ES6 新增了一個簡單更具可讀性的語法讓我們可以建立類別(class). 搭配 ES6 匯入匯出模組的語法讓我們的程式更加清楚易懂. 而 Decorators 讓我們可以在設計時期透過註記的方式修改類別與屬性.在 ES5 物件實字(Object Literal)支援值可以使用任意的表達式(Expression)而 ES6 類別單純只支援值使用函式表達式或稱作函式常量(Function Literal)現在 Decorator 讓 JS 具備了可維護性與可讀性的宣告式語法","text":"在這篇文章中我們將要探討如何使用 ES7 的新功能. ES6 新增了一個簡單更具可讀性的語法讓我們可以建立類別(class). 搭配 ES6 匯入匯出模組的語法讓我們的程式更加清楚易懂. 而 Decorators 讓我們可以在設計時期透過註記的方式修改類別與屬性.在 ES5 物件實字(Object Literal)支援值可以使用任意的表達式(Expression)而 ES6 類別單純只支援值使用函式表達式或稱作函式常量(Function Literal)現在 Decorator 讓 JS 具備了可維護性與可讀性的宣告式語法 Object Literal 是一個透過 , 逗號分隔的鍵值對列表, 再透過一個大括號包起來. 12345// object literal 又稱物件實字let obj = &#123; name: &apos;andyyou&apos;, age: 28,&#125; Function Literal 函式表達式或稱作函式常量 - 即定義一個不具名的 function, 單純觀察下面的範例會覺得其類似於一個 function 得宣告片段, 除了語法看起來像一段表達式和並沒有宣告函式名稱 123456789// Function Literalvar func = function () &#123; console.log(&apos;I am a function&apos;);&#125;// 具名 Functionfunction F() &#123; console.log(&apos;I am a function&apos;);&#125; 簡單說就是我們會對 class 或 property 使用 decorator 何謂 Decorators?如果你不熟悉 Decorator, 他們類似於一種標記或描述資料(metadata), 不過不同的是它們會被附加套用在類別, 方法, 或者屬性上.概念上就是你可以透過附加的方式來操作定義. 這麼說非常抽象讓我們看看範例: 123456789101112// 可否測試function Testable(target) &#123; target.isTestable = true&#125;@Testableclass OurClass &#123;&#125;// 接著我們就可以確認這個類別是否可以測試OurClass.isTestable // =&gt; true 上面那個 @Testbale 就是 decorator 語法, 我們用白話文來說就是透過像加註解或標記的方式讓類別或屬性增加其他功能.如果我們想要傳入參數也就是一個動態的註記函式, 我們可以透過 factory pattern 123456789101112function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable &#125;&#125;@testable(true)class OurClass &#123;&#125;console.log(&quot;OurClass: &quot;, OurClass.isTestable); // =&gt; OurClass: true 小結來說一個 decorator 是 一個表達式 一個 function 可以在其參數中取得目 target, name, property, descriptor 選擇性的回傳一個 descriptor 用來安裝在目標物件上 透過宣告的方式加入 Mixins在程式語言的概念中 Mixin 是我真的覺得好用的功能(事實上在這裡它不叫 Mixin 稱為 traits)因為在大多的開發過程我們只是要把一些功能, 方法抽出來重複使用, 實務上常遇到不好決定到底該歸納到什麼類別. 如果你要說介面(Interface)那又扯遠了 簡單的說 mixin 就是把一些功能抽出去獨立一個模組, 根據不同語言其本質可能是另一個類別或函式等等.所以我們需要的其實就是如何把這些函式或者方法抽出去和合併的方式.在 ES5 時我們可以使用 Object.assign 來合併(merge) prototype, 背地裡其實是 Polyfill 例如使用 underscore 或 lodash 的 _.extend 實作. 1$ npm i -S object.assign 123456789101112131415var assign = require(&apos;object.assign&apos;);function CarAbility() &#123;&#125;;CarAbility.prototype.run = function () &#123; console.log(&apos;Car is running&apos;);&#125;function ToyotaCar() &#123;&#125;assign(ToyotaCar.prototype, CarAbility.prototype);var car = new ToyotaCar();car.run(); // =&gt; Car is running 而在 ES6 當我們透過新的語法 class 來定義類別的時候, 我們並不能簡單的使用 prototype 當做 mixin. 且預設所有的方法(Medthod)並不是 enummerable 這是 JS 中物件底層的屬性簡單的說就是 for in 會不會將其列舉出來. Object.assign 只會合併那些物件中 enummerable 的方法此時我們可以改用物件來作為 mixin 接著透過 Object.assign 將其套用到目標類別上 1234567891011121314const CarAbility = &#123; run() &#123; console.log(&apos;foo&apos;) &#125;&#125;class BMWCar &#123;&#125;Object.assign(BMWCar.prototype, CarAbility)let car = new BMWCar();car.run(); 這是一種指令式的風格, 那如果我們可以在宣告類別的時候合併呢? 讓我們來建立一個簡單的 decorator 來完成這個需求 12345export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list) &#125;&#125; 然後我們就可以使用 ES6 的匯入語法 注意從這邊開始因為使用了 ES6 的語法所以你會需要 Babel 來編譯 123456789101112131415import &#123;mixins&#125; from &apos;./mixins&apos;const CarAbility = &#123; run() &#123; console.log(&apos;I am running&apos;); &#125;&#125;@mixins(CarAbility)class AudiCar &#123;&#125;let car = new AudiCar();car.run(); Traits既然我們已經可以透過上面的方式實作 mixin, 那為什麼還要有個 Traits, 原因是有些情況您需要更多的控制權, 當你只想合併想要的功能時, 或者遇到不同物件卻有相同名稱的函式的狀況.Traits 讓我們可以避免合併時的名稱衝突, 我們可以排除方法或者是透過 alias 別名的方式改變方法的名稱 關於實作面, 我們可以透過CocktailJS這個函式庫輕鬆實作 Traits, 這個函式庫包含了 annotations, traits 以及讓 class 具備更多陳述式的用法(或者說從外部合併屬性或方法的寫法) 這裡為了單純只說明觀念我們只使用traits-decorator, 它是一個實驗 decorator 和 bind-operators 的函式庫 12345678910111213141516171819202122232425import &#123;traits&#125; from &apos;traits-decorator&apos;;// 使用 class 為 traitsclass CarTraitClass &#123; run () &#123; console.log(&apos;I am running&apos;); &#125;&#125;// 使用 object 為 traitsconst CarTraitObject = &#123; start () &#123; console.log(&apos;The car is started&apos;); &#125;&#125;@traits(CarTraitClass, CarTraitObject)class HondaCar &#123;&#125;let car = new HondaCar();car.run(); // =&gt; I am runningcar.start(); // =&gt; The car is started 再次提醒如果你用 babel 實作需注意目前 @ 語法要啟用 experimental 即 stage 0 1$ babel [source].js -o [destination].js --stage 0 名稱衝突剛剛上面有提到關於衝突的部分, 假設我們現在遭遇到 traits 甚至是類別本身的方法名稱產生衝突的狀況, 就是名字一樣 123456789101112131415161718192021222324import &#123;traits&#125; from &apos;traits-decorator&apos;;// 使用 class 為 traitsclass CarTraitClass &#123; run () &#123; console.log(&apos;[class] I am running&apos;); &#125;&#125;// 使用 object 為 traitsconst CarTraitObject = &#123; run () &#123; console.log(&apos;[object] I am running&apos;); &#125;&#125;@traits(CarTraitClass, CarTraitObject)class HondaCar &#123;&#125;let car = new HondaCar();car.run(); 重新編譯在執行會產生錯誤(編譯時不會出錯) 1throw new Error(&apos;Method named: &apos; + methodName + &apos; is defined twice.&apos;); 很明顯的是因為我們的 run 定義了 2 次, 此時 Traits 讓開發者負責去解決這個衝突, 這部分和 mixin 不太一樣, mixin 的話會讓後面載入的方法覆寫掉前面的. 為了解決這個問題我可以排除我們不想要的 method 或者為其創造一個別名 1234567891011121314151617181920212223242526import &#123;traits, excludes&#125; from &apos;traits-decorator&apos;;// 使用 class 為 traitsclass CarTraitClass &#123; run () &#123; console.log(&apos;[class] I am running&apos;); &#125;&#125;// 使用 object 為 traitsconst CarTraitObject = &#123; run () &#123; console.log(&apos;[object] I am running&apos;); &#125;&#125;// 別名的用法// @traits(CarTraitClass, CarTraitObject::alias(&apos;drive&apos;))@traits(CarTraitClass, CarTraitObject::excludes(&apos;run&apos;))class HondaCar &#123;&#125;let car = new HondaCar();car.run(); // =&gt; [class] I am running 您可能注意到一個奇怪的小東西 :: 這是 bind-operator 基本上 bind operator 就是 .bind() 的縮寫, ::this.method = this.method.bind(this)::Car.run 會等於 Car.run.bind(Car) 而 :: 和 @ 這些語法在 Babel 都還處於實驗階段, 所以如果您要使用就必須要自己設定開啟 stage 0 總結透過這種方式我們說我們可以在設計時期就可能是類別已經寫好了的情況下透過註記來增加功能, 不要用的時候也可以輕易移除. 參考 ES 7 descorator javascript-decorators exploring-es7-decorators","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"//andyyou.github.io/tags/es6/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"OSX EL - Install Apache, MySQL, PHP Note ","slug":"osx-el-apache-mysql-php","date":"2015-10-03T21:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/10/04/osx-el-apache-mysql-php/","link":"","permalink":"//andyyou.github.io/2015/10/04/osx-el-apache-mysql-php/","excerpt":"Use Apache OSX 10.11OSX 10.11 仍然內建 Apache","text":"Use Apache OSX 10.11OSX 10.11 仍然內建 Apache 12345$ sudo apachectl start$ sudo apachectl stop$ sudo apachectl restart$ apachectl configtest # 測試設定檔$ httpd -v # Apache version 設定 document rootOSX預設有兩個網頁根目錄 System Level - 所有使用者使用同一個全域根目錄 /Library/WebServer/Documents/ User Level - 每個使用者有自己的根目錄 ~/Sites 從 10.7 之後 Apple 不再提供介面來管理必須要透過指令介面設定, 而使用 User Level 可以避開很多權限的問題所以一般建議使用 User Level User Level 設定123456$ mkdir ~/Sites# 加入 `[username].conf`$ cd /etc/apache2/users$ sudo vi [username].conf$ ls -ahl# -rw-r--r-- 1 root wheel 298 Jun 28 16:47 username.conf [username].conf 使用者網站設定 12345&lt;Directory &quot;/Users/username/Sites/&quot;&gt;AllowOverride AllOptions Indexes MultiViews FollowSymLinksRequire all granted&lt;/Directory&gt; 12345678910111213141516171819$ sudo vi /etc/apache2/httpd.conf# 解開註解# LoadModule authz_core_module libexec/apache2/mod_authz_core.so# LoadModule authz_host_module libexec/apache2/mod_authz_host.so# LoadModule userdir_module libexec/apache2/mod_userdir.so# LoadModule include_module libexec/apache2/mod_include.so# LoadModule rewrite_module libexec/apache2/mod_rewrite.so# LoadModule php5_module libexec/apache2/libphp5.so# Include /private/etc/apache2/extra/httpd-userdir.conf# 處理另外一個設定檔$ sudo vi /etc/apache2/extra/httpd-userdir.conf# 解開註解# Include /private/etc/apache2/users/*.conf# 因此, 我們一開始建立的 /etc/apache2/users/[username].conf 就能夠使用$ sudo apachectl restart # 重啟套用設定# 造訪 http://localhost/~username/ 即可看到網站, 而網頁檔案放置在 ~/Sites 設定檔的 Include 關聯 /etc/apache2/httpd.conf 解開 Include /private/etc/apache2/extra/httpd-userdir.conf之後便能夠使用 /etc/apache2/extra/httpd-userdir.conf 針對使用者目錄來設定而 httpd-userdir.conf 解開 Include /private/etc/apache2/users/*.conf 之後所有在 /etc/apache2/users的 .conf 設定就會被套用 System Level 設定設定允許 .htaccess 來複寫預設值 1234567$ sudo vi /etc/apache2/httpd.conf# AllowOverride All# 解開註解# LoadModule rewrite_module libexec/apache2/mod_rewrite.so# LoadModule php5_module libexec/apache2/libphp5.so$ sudo apachectl restart 安裝 MySQL1234567891011121314151617181920212223242526272829303132333435363738394041$ brew install mysql# 需要開機啟用的話$ ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents# homebrew suggested, notice before setting need to stop mysqld$ unset TMPDIR$ mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew --prefix mysql)&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmp# 加入設定檔$ cp -v $(brew --prefix mysql)/support-files/my-default.cnf $(brew --prefix)/etc/my.cnf# 預設 MySQL 沒有密碼執行下列指令$ $(brew --prefix mysql)/bin/mysql_secure_installation# 移除重新安裝$ brew remove mysql$ brew cleanup$ launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ sudo rm -rf /usr/local/var/mysql# 透過 brew services 操作# https://github.com/Homebrew/homebrew-services$ brew tap homebrew/services # install brew services$ brew services start mysql$ brew services stop mysql$ brew services restart mysql$ brew services list# 登入 MySQL$ mysql --host=localhost --user=root -p# 建立使用者mysql&gt; CREATE USER &apos;[username]&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;[password]&apos;;mysql&gt; SELECT User,Host FROM mysql.user;mysql&gt; GRANT ALL PRIVILEGES ON * . * TO &apos;[username]&apos;@&apos;localhost&apos;;mysql&gt; FLUSH PRIVILEGES;# 設定使用者密碼mysql&gt; SET PASSWORD FOR &apos;[username]&apos;@&apos;localhost&apos; = PASSWORD(&apos;[password_here]&apos;); 詳細建立角色權限 phpMyAdmin 安裝下載 phpMyAdmin 解壓縮並移至 document root 目錄 12345$ cd phpmyadmin$ mkdir config$ chmod o+w config# Visit http://localhost/~[username]/phpmyadmin/setup# After save file move config.inc.php to phpmyadmin folder 問題 apache2: Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1 for ServerName 解法 1234$ sudo vi /etc/apache2/httpd.conf# 修改 ServerName 隨意指定一個網址$ apachectl configtest# &gt; Syntax OK ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 1234567$ ps -ef | grep mysql$ kill -9 [id]# Check /tmp/mysql.sock exists# 檢查設定檔 $(brew --prefix)/etc/my.cnf$ touch /tmp/mysql.sock # 預設$ brew services start mysql Warning: mysqli::mysqli(): (HY000/2002): No such file or directory 1234$ cd /var$ sudo mkdir mysql$ ln -s /tmp/mysql.sock mysql/mysql.sock$ brew services restart mysql 解法 參考資源 Starting and Stopping Background Services with Homebrew Install MySQL on Mac OSX using Homebrew Get Apache, MySQL, PHP and phpMyAdmin working on OSX 10.11 El Capitan","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"osx","slug":"osx","permalink":"//andyyou.github.io/tags/osx/"},{"name":"php","slug":"php","permalink":"//andyyou.github.io/tags/php/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"第一次用 CSS - Flexbox 就上手","slug":"understand-flexbox","date":"2015-09-08T21:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/09/09/understand-flexbox/","link":"","permalink":"//andyyou.github.io/2015/09/09/understand-flexbox/","excerpt":"Flexbox 是一種新的 CSS 3 佈局模式, 在這之前 CSS 有四種佈局模式","text":"Flexbox 是一種新的 CSS 3 佈局模式, 在這之前 CSS 有四種佈局模式 block inline table positioned 在 Flexbox 和 Grid 出現之前, 開發者大量濫用 float 來達成一些複雜佈局的需求, 但本質上 float 並不是用來協助我們佈局的, 它只是一個舊有的對齊屬性.雖然 float 可以達成我們的目的, 但它伴隨著一些限制和問題, 您應該有過使用 float 搭配 clearfix 的經驗吧. 現在 CSS 3 引進了兩種新的佈局方式用來取代被我們大量濫用的 float 和 table mode Grid 將佈局區分成 rows 和 columns, 有點類似 table 但比其更強大. 不過關於 Grid 的規格仍然在開發中, 還不能使用. Flexbox 根據單一的行或列分配空間, 類似 float 調配控制元素的位置尺寸概念, 但更好用! Flexbox 規格已經完成而且今時今日多數的主流瀏覽器都支援 Flexbox 簡史明白創造這種佈局模式的動機是幫助我們學習這東西一個非常好的開始. Tab Atkins Jr : 大約在 2000 - 2009 後期, Mozilla 試著要讓 XUL Layout model 正名為 Flexbox, 我第一次得知這份草稿是在 2009 年, 但我想這應該可以追朔到 2007 年. 但這過程並沒有什麼結果; 只有 WebKit 實作一部分標準, 而且即使是 Firefox 也不符合該標準, 因為大部份的事情根本還沒被確認.接著在 2010 年左右我加入了 WG 其中的第一個任務就是替 Firefox 整理這份草稿(整份重寫), 大概在一兩年後 Microsoft 提交了第一份 Grid 標準的草稿, 我一樣是使盡全力處理(重寫)我這麼做的目標就是要取代那些因為 float, table, inline-block 等等而延伸的複雜佈局技巧, 身為一個網頁開發者我不得不這麼做.那一堆人們為了佈局而產生的奇技淫巧(hack)通常不是怎麼高明, 很難記憶, 而且往往有一堆惱人的限制, 所以我希望讓佈局模型可以更好用一點, 在處理同樣的問題時可以更簡單, 方便並且相對完整. 簡而言之: Flexbox 和 Grid 被創造出來明顯的是為了取代 float, table 等等問題而產生的 hack. 共有 3 種 Flexbox 規格?你也許聽過有 3 個 Flexbox 的規格書, 沒錯! 共有三個版本的規格書, 不過只有一個是我們要關注的. 2009 年的版本: display: box 現在已經不再跟 Flexbox 有任何關係 2011 過渡期版本: display: flexbox 只是草稿, 只被 IE10 實作, 如果可能的話應該避免使用 2012 最終版: display: flex 注意: 每一個規格在 display 屬性上使用不同的關鍵字, 如果您正在閱讀其他關於 Flexbox 的文章可以很輕易的判斷該篇文章在討論的是哪個版本.如果你看到的文章不是 display: flex 那麼你可以不看了 Flexbox 佈局具備單一方向性如同上面提到, Flexbox 會依據單一 row(橫向) 或 column(垂直) 方向放置內容項目, 讓我們來看看這句話的意思是: 一個 Flexbox 佈局由一個 flex container 組成, 裡面包含著 flex items 這個 flex container 可以設置水平或垂直, 我們可以簡稱這個特性為主軸 main axis flex container 內部第一層的子元素會遵循 main axis 的方向排列, 這些子元素可以彈性調整他們的大小, 自動擴展去使用 container 內部那些未被使用的空間, 或者自動縮小以避免超出範圍. 透過巢狀內嵌多個不同方向的 flex container 可以完成複雜的佈局. Flexbox 屬性關於 Flexbox 有非常多的屬性, 所以我會建議你如果有時間參考一下CSS Tricks Flexbox Guide這邊文章非常詳細的介紹了所有的屬性 不要被嚇到了. 雖然 Flexbox 有非常多的屬性可以設定, 但是也有一系列的預設值, 所以我們可以透過很少的程式碼來建立複雜的佈局. 123.flex-container &#123; display: flex;&#125; 單單一行 CSS 程式碼我們完成了下面這些功能 套用 .flex-container 的元素成為一個 flex container 內部第一層的子元素會變成 flex item 預設 Flex item 會依照水平的方式排列 Flex item 會依照程式碼的順序排列 Flex item 會在 container 內從左至右排列 Flex item 的尺寸會依照正規的 width 屬性或內容自身的寬, block-box(div etc) 不會自動長滿 100% 如果沒有足夠的空間, 那麼 Flex item 會自動依照寬度 width 的比例去縮小, 直到空間完全不足 scrollbar 才會出現 如果需要收縮, 則每一個 Flex item 都會收縮相同的值 Flex item 會自動展延高度使其與其他 Flex item 中最高的那個相等 對於這只有一行的 CSS 的確是包含蠻多的邏輯! 你還可以修改其中任何一個行為, 不過我希望能夠讓讀者明白關於 Flexbox 的強大 瀏覽器的支援 注意 IE 10 支援 Flexbox 不過是使用過渡時期的版本 display: flexbox 那麼對於 IE 10 以前的版本呢如果你不在乎不支援 Flexbox 的瀏覽器破版, 有點的不同, 如果是這樣你就不需要在做其他處理. 這種行為有個術語叫做優雅降級(graceful degradation)當瀏覽器看到它不懂的東西 - 例如: display: flex 他就會整個忽略, 對我們來說這是件好事, 因為這表示所有 Flexbox 的屬性都會被忽略.您設定成 Flex container 的元素會用原本的行為運作通常應該是 display: block 就結果來說整個佈局中 block 會垂直排列 搭配 Modernizr 的優雅降級如果你不能不管那些古董瀏覽器, 您可以透過 Modernizr 提供一個舊版使用 float-base 的佈局Modernizr 是一個 Javascript 函式庫, 它會自動偵測瀏覽器的功能然後在 html 或 body 元素加上一系列的樣式, 讓我們可以根據是否支援來撰寫替代性(舊版 float-base)的樣式 以 Flexbox 的例子來說如果瀏覽器不支援 Flexbox 那麼就會有一個 .no-flexbox class 被加在 html tag 上面, 如此一來我們就可以用下面的樣式來試著用其他的樣式取代 12345678.parent &#123; display: flex; &#125;.child &#123; flex: 1; &#125;.no-flexbox &#123; .child &#123; float: left; width: 50%; &#125; .parent::after &#123; @include clearfix(); &#125;&#125; 好處是您可以透過舊有的方式來針對 .no-flexbox 的部分做 CSS 的撰寫, 如果未來不再需要支援這些老舊的瀏覽器只要把 .no-flexbox 部份的樣式移除即可 不過還是有一點要注意, 當你使用 Modernizr 2.8.3 時 IE 10 並不會出現 .no-flexbox 你可以改用IE專屬的條件式註解語法 &lt;!--[if IE 10]&gt;&lt;![endif]--&gt;, autoprefixer, 或者直接更新使用 Modernizr 3+ 新版已經排除掉這個問題. Flexbox 教學 - 背景關於 Flexbox 佈局 模組目前處在 W3C 最後的草稿階段, 其目標如同上面提到的希望提供一種更有效率的方式處理元素的佈局, 對齊, 在一個容器內分散排列的方式, 甚至是不知道該元素的尺寸或者說動態調整, 這也是為什麼會叫 Flexible Box 在 Flex 佈局背後的核心觀念是賦予一個 container 容器具有能力去修改子項目的尺寸(width/height)以及排列順序, 好讓我們可以填滿容器裡的空間更具體的說好讓我們可以去適應各種尺寸裝置的螢幕. 一個 Flex container 可以擴展其子項目填滿容器裡的空間或者是收縮以防止超出容器. 更重要的是 direction-agnostic 這是 W3C 定義的術語 To make it easier to talk about flexbox layout in a general way, we will define several direction-agnostic terms here to make the rest of the spec easier to read and understand. 指的是那一系列處理方向的術語, 這跟原本的 block, inline 等佈局方式相反, 意思是指原本的佈局形式, 項目本身會具方向性例如: block 會垂直堆疊, inline 會水平排列, 而 Flex item 本身不需要知道該怎麼處理方向和排列, 是由 container 控制. 原本的方式類似在做平面設計排版, 缺少彈性去支援大型複雜的專案尤其是當裝置螢幕切換方向, 改變尺寸, 伸縮那些狀況. 備註: Flexbox 佈局相對適合用於應用程式中的元件, 小型的佈局. 對於複雜佈局來說 Grid 會相對適合. 基礎知識和術語由於 Flexbox 代表的是一整個模組, 是一系列排版的邏輯而不只是單一的 CSS 屬性, 意思是它牽扯到很多東西和屬性.其中有些屬性是要用在 Flex container 的, 另一些則是用在子項目 Flex item 如果說一般的佈局架構在 block 和 inline 的方向性上, 那麼 Flexbox 佈局則基於 flex-flow 方向, 參考下圖, 這邊就是解釋了上面提到的 w3c 定義的那些術語, 透過圖片我們很清楚的可以明白關於 Flexbox 的核心概念. 在這一小節重點是跟以往下 CSS 屬性有些不同, Flexbox 佈局的使用和樣式設定上區分成 Flex container - 設定為 display: flex 的元素 Flex item - 在 Flex container 內部第一層直接與 container 接觸到的標籤, 可以是文字或其他標籤 e.g div span container 的設定會影響 item, 位於內部的 item 也有些屬性可以覆寫 container 的設定, 為了方便說明下面開始我們會用 container 和 item 分別表示這兩者 基本上 item 會依照 main axis 主軸排列, 從 main-start 到 main-end 和 cross axis 橫軸從 cross-start 到 cross-end 排列 main axis - 即 Flex container 的主軸, 任何在內部第一層直接和 container 連接的項目稱為 Flex item 都會遵循這個主軸排列, 要注意的是這個主軸不一定要是水平的, 根據 flex-direction 屬性的設定可以改變方向性 main-start|main-end - 在 container 內部的 item 會根據主軸從 main-start 開始向 main-end 排列放置 main-size - 因為 flex-direction 屬性的設定可以改變方向性, 依據主軸方向該 item 的寬或高就是 main-size, 其屬性值來自於 item 的 width 或 height cross axis - 側軸(橫軸)指的是垂直於主軸的另外一個維度向性, 他的方向性會根據主軸而改變, 相依於主軸. cross-start|cross-end - item 會依照 Flex Line 排列放置, 類似於主軸的概念, 只不過這是另外一個維度 cross size - 概念與 main-size 相同, 不過換成側軸上 item 的寬或者高 Flex Container 屬性 display這個屬性用來定義產生一個 flex container; 一旦設定 flex 其第一層子項目就會變成 flex item.屬性值有 flex, inline-flex. 另外注意 CSS columns 在 flex container 中是沒有作用的. flex container 並不是一般的 block, 也因此我們常常在用的一些控制位置, 對齊的屬性在這個容器中並不適用也就是說在 item 設定 column-*, float, clear, vertical-align 都是沒有作用的. 但是!! 對容器本身是有用的. flex 和 inline-flex 對於內部的 item 使用起來並沒有差異, 差別是容器本身的行為, inline-flex 容器本身就會類似 inline 一樣不會預設佔滿一 row 123.container &#123; display: flex; /* or inline-flex */&#125; flex-direction 此屬性用來設定主軸的方向, 基本上是單向的佈局概念, item 可以水平或垂直排列, 一次只能設定一種方向 123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row - 預設的屬性值, 在文字方向設定 direction: ltr; 時 row 就是由左至右, 反之 rtl 則由右至左 row-reverse - 反向的 row column - 跟 row 的概念一樣不過這是垂直的 column-reverse - 跟 row-reverse 概念相同, 但是是垂直的 flex-wrap 預設 flex item 只會排成一排, 你可以修改這個屬性當 item 塞不下的時候換行 123.container&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap - 預設值, 只會有一行 wrap - 多行, 塞不下就換行 wrap-reverse - 多行, 反向排列 flex-flow這是 flex-direction 和 flex-wrap 的縮寫版預設值是 row nowrap 123.container&#123; flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt;&#125; justify-content 設定主軸的對齊方式, 這個屬性可以協助我們分配容器中扣除 item 的空間, 其行為是當所有可伸縮的長度及邊距都完成計算後剩下的空間才輪到 justify-content 來分配 123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start - 預設值, item 對齊主軸的起始點(邊界), 後續的 item 一個接著一個 flex-end - item 從主軸的終點邊界開始往回排列, 注意到我們在 Flexbox 裡 item 的順序是獨立出來的, 不要把順序和排列該對齊的位置搞在一起. center - item 置中, 換個角度看就是把剩下個空白平均分給兩邊 space-between - item 被平均分配到主軸上, 也就是說剩下的空間平均分到到 item 之間的間隔, 注意頭尾是貼齊邊界. 也就是說如果沒有多餘的空間其效果跟 flex-start 一樣 space-around - 把剩餘的空間平均分配到 item 的兩邊, 頭尾並不會貼齊邊緣, 類似下了左右的 margin. align-items 這個屬性用來設定 item 該如何沿著側軸(cross axis)對齊排列, 要注意主軸跟側軸的關係, 因為不見得主軸就是橫向的.根據大部份的情況, 把它想成用來處理垂直置中的屬性比較好記. 是指每個個別的 item 跟怎麼跟側軸對齊 123.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start - 貼齊側軸的起始點 cross-start. flex-end - 貼齊側軸 cross-end 排列 center - 置放於側軸的中央 baseline - item 會對齊 baseline stretch - 預設值, 自動把 item 的高長滿 container align-content 這個屬性比較像是垂直版的 justify-content, align-items 是以 item 的角度對齊, 而 align-content 比較像是根據 row 的高這個角度, 這個屬性的行為就是分配剩下的空間, item 高都計算完成之後, 該如何剩餘的空間. 注意, 當只有一行的時候這個屬性沒有效果 123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start - 對齊 container 側軸的起始點(cross-start)一行一行排列, 在一般水平為主軸的情況下看起來像是整塊對齊 top flex-end - 對齊側軸尾巴(cross-end) center - 整塊置中, 意思是剩餘的空間上下留白 space-between - 頭尾對齊邊緣, 剩下的空間分配到 item 之間的間隔 space-around - 把剩餘的空間平均分配到 item 的兩邊, 頭尾並不會貼齊邊緣, 類似下了左右的 margin. 不過這次是側軸的方向. 小結概略來說 container 決定 item 排列方向, 用 justify-content, align-content 來處理分配剩餘空間, 對齊. 側軸方向上還可以針對 item 該怎麼對齊用 align-items 甚至可以輕鬆完成每個項目同高, 或是各自有自己的高, 內部 item 可以依照比例伸縮, 且不會超過容器.可動態適應各種不同的螢幕尺寸. Flex Item 屬性 order 預設來說 item 會依照程式碼出現的順序排列, 然而 Flexbox 強大之處就是你可以設定 order 來調整排列順序, 順序用一個整數來表示, 也可以使用負數, 不過下面的 flex-grow 就不能用負數 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow 此屬性用來讓 item 具有伸展擴大的能力, 使用一個沒有單位的整數(負數不是合法的值), 如果有剩餘的空間就會依照數字的比例去伸長 item.舉例來說如果所有的 item 的 flex-grow 都設為 1 那麼當需要展延的時候所有 item 會分配到相同的長度. 如果你賦予其中一個 item 的 flex-grow: 2這個 item 就會被分配到比較多的空間. 或者更確切的例子假設容器 1000px, 有三個 item 各為 200px 加上 margin: 0 20px, 如此一來 1000 - (200 + 20 * 2) * 3 = 280這 280px 會依據 flex-grow 設定的比例去分配 另外需要注意的就是如果 item 設為 flex-grow: 0 則不參與空間分配 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink當空間不足時使 item 具有縮小的功能即依照比例縮小, 同樣負數無效舉例來說容器 200px 三個 item 各自 100px 加上 item 有 margin: 0 10px 那麼三個 item 的總寬是 (100 + 10 * 2) * 3 = 360總共超過 160px, 所以為了要能夠塞進容器裡, 現在我們需要砍掉 160px, 如果設定是 1:1:1 的話就是 160/3=53.33 也就是每個 item 要砍掉 53.3px也就是說在 flex-shrink 裡數字越大砍掉越多. 123.item &#123; flex-shrink: &lt;number&gt;; /* default 0 */&#125; flex-basis設定 item 的初始值, 即在 flexbox 機制開始分配剩餘空間調整 item 大小之前賦予一個初始值, 預設值是 auto當 flex-basis 不設定或設為 auto 的時候則 item 的尺寸會根據自身的屬性(width)加上 content 的寬度去計算, 概念上我們可以把其當成是 min-width. 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flexflex-grow, flex-shrink, flex-basis 的濃縮寫法第一個參數 flex-grow, 第二個是 flex-shrink 第三個是 flex-basis 預設值為 0 1 auto 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; W3C 文件建議我們善用這個屬性取代其他三者 align-self 剛剛上面我們看過了 align-items 不過 align-items 是從 flex container 的角度讓所有的 item 設定同一個值, 而 align-self 則是從 item 的角度去設定, 可以讓我們達到某一個 item 覆寫不同值 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 再次強調 float, clear, vertical-align 對於 item 是沒有作用的. 小結簡單來說 container 處理整體的方向, 空間開如何分配而 item 的屬性部分就是 order 順序, 和當空間超出去或不夠的時候 item 該如何動態增減其長度這個部分主要是針對 main size. 參考a-guide-to-flexbox","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"第一次用 jspm 就上手","slug":"jspm-getting-started","date":"2015-08-13T07:00:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/08/13/jspm-getting-started/","link":"","permalink":"//andyyou.github.io/2015/08/13/jspm-getting-started/","excerpt":"何謂 jspm ?jspm (javascript package manager) 號稱是完全支援(無摩擦)瀏覽器載入的套件管理工具","text":"何謂 jspm ?jspm (javascript package manager) 號稱是完全支援(無摩擦)瀏覽器載入的套件管理工具 jspm 也是一套套件管理工具，採用 SystemJS 來處理模組載入 當然內建也就支援動態的 ES6 模組載入 可以直接從 npm, Github 載入任何模組標準所寫得模組程式(ES6, AMD, CommonJS, global) 任何自訂的registry例如 npm 也可以透過 Registry API 來註冊連結 開發時，會將 ES6 檔案和編譯後的 plugins 分開載入 產品上線時，優化成一個 bundle ，也可透過指令將 bundle 分層或單獨執行 入門 安裝 jspm 指令 建立專案 初始化專案的設定檔 安裝來自任何 registry 的套件 安裝 jspm 指令1$ npm install jspm -g 建立專案12$ cd my-project$ npm install jspm --save-dev 上面這個步驟不是必須的，但官方建議在專案安裝一個屬於專案自己的 jspm 版本，這可以確保當系統更新的時候專案的 jspm 版本並不會被影響，在目錄底下執行 jspm -v 可以顯示該專案的版本。 此時我們沒有 package.json 所以下 --save-dev 不會把設定加到 package.json 中。 初始化專案的設定檔123456789$ jspm init# Package.json file does not exist, create it? [yes]:# Would you like jspm to prefix the jspm package.json properties under jspm? [yes]:# Enter server baseURL (public folder path) [.]:# Enter jspm packages folder [./jspm_packages]:# Enter config file path [./config.js]:# Configuration file config.js doesn't exist, create it? [yes]:# Enter client baseURL (public folder URL) [/]:# Which ES6 transpiler would you like to use, Traceur or Babel? [traceur]: 這個指令會協助我們設定 package.json 和 config.js(jspm 預設)。注意到當目錄為空的時候 jspm init 會試圖自動幫我們處理下面這些項目 baseURL: 這個設定指的是相對於在 server 上的 public folder 通常是 /，也就是 package.json 應該放置的專案根目錄，或者說當網址為根的時候該如何對應到此專案目錄。 jspm packages 目錄: jspm 會將其他相依的檔案安裝在這裡。 config 檔案路徑: 這個是 jspm 的設定檔也應該要跟 package.json 一樣放在專案的根目錄 client baseURL: 這個 URL 設定瀏覽器如何存取被託管在 server 上的目錄 transpiler: 設定使用的 compile to js language(ES6+ to ES5)。可以在任何時間透過 jspm dl-loader --babel 來修改這個選項。也可以直接在 jspm 的設定檔中透過 babelOptions 或 traceurOptions 修改。 如果你需要重新設定這些屬性，可以直接修改 package.json 接著執行 jspm install 或 jspm init 來更新 而如果想要重新發動 jspm 的詢問來更新檔案可以執行 jspm init -p 安裝來自任何 registry 的套件 例如: Github, npm …首先 registry 的意義是一個可以註冊的地方或空間。對應到程式開發領域的話指的就是像 Github, npm, gem Nuget, apt, yum 。開發者可以把自己的程式(函式庫)註冊並上傳發佈的套件管理站點或系統。 透過下面的指令可以從任何 registry 安裝 12345$ jspm install npm:lodash-node$ jspm install github:components/jquery$ jspm install jquery$ jspm install myname=npm:underscore$ jspm install [registry]:[package name] 多個套件安裝可以在同一個指令用空白隔開，上面的例子我們看到了無論是 npm 或 github 都可以透過這種方式安裝。 大部份的 npm 套件安裝不需要再加上額外的設定，這是因為 npm 站點使用專案設定規範適用於所有 Node 和 npm-style 的程式碼，也因此相容 jspm Github 的套件或說程式碼就可能需要對 jspm 補些設定 所有安裝項目的設定會存放在 package.json，而 jspm_packages 目錄和設定檔可以透過執行 jspm install 全部重建，所有相依的第三方元件仍然是透過 package.json 來紀錄設定。 原則上你不該把這些第三方的程式碼一起加入版控。 簡單來說，jspm 是透過 system.js 來處理載入模組這件事。而載入模組這件事為什麼需要處理，是因為在 js 的世界裡存在較多的標準，ES6+ 的標準又還沒普及，所以通用的載入器需求就產生了，白話文即不管你是用 CommonJS 或 AMD 甚至 ES6 寫的東西都要能夠被載入，但 jspm 並不是唯一可以處理這個問題的工具。 一個 nodejs 專案是透過 package.json 來管理相依的函式庫或套件，而 jspm 主要也是透過 package.json 來組織其設定，它會根據解析 package.json 的結果在 config.js 裡加上 system.js 以及自己需要的設定。也因此 config.js 只要透過 jspm install 就可以根據 package.json 的資料重建設定檔。 搞懂 npm, jspm, webpack 的使用上的差異我們依照模組標準開發出一個函式庫模組並丟到 npm 給大家用，npm 這個詞意義上又分成 npm-cli 指令和 npm 這個集合套件的站點，所以這邊我們提的 npm 指的是指令的部分，例如 npm install 這樣的指令來處理安裝，移除，管理的指令。 而 webpack 或 browserfiy 它們是處理模組封裝和載入的工具，意思是把你寫的 js 打包，大略的實作行為就是你在程式中用 require 來載入其他檔案最後輸出一隻打包的 js，所以安裝的部分還是用 npm ，而載入則由 webpack 這類的工具負責。 那 jspm 呢？第一個不同點就是除了你可以透過 npm 安裝專案專屬 jspm 外(用來鎖定版本)，其他套件或函式庫你都是用 jspm install [library name] 的方式來安裝。那設定呢？基本上上面就提到了; 如果你是採用 node 或 npm-style 的函式庫或模組是不用設定的，因為 jspm 會幫你把設定加到 config.js 裡面。 下面整理 jspm v.s npm + webpack 的流程順序 12345step 1. jspm 下載模組並安裝 (使用 npm 下載並安裝)step 2. 在 package.json 中紀錄設定，而程式碼安裝到 `jspm_packages` (npm 一樣把設定記錄到 package.json 檔案裝到 node_modules)step 3. 分析 package.json 後在 config.js 產生設定 (使用 webpack 自己手動寫設定)step 4. 撰寫程式碼，載入並應用模組step 5. 執行 jspm bundle (執行 webpack ./main.js ./bundle.js) 實作現在我們就可以開始在程式中撰寫載入的部分了。為了更加明白其運作。這次的練習會包含 建立一個 jspm 專案 先試著寫 ES6 語法來測試 安裝 jsx, react 撰寫一個簡單的 React Component bundle &amp; 優化 123456789101112$ mkdir jspm_new_project&gt; 建立一個空的目錄$ jspm init&gt; 初始化專案，注意 transpiler 選 babel$ jspm install jquery&gt; 試著安裝 jQuery, 我們先試著用基本的 jQuery 搭配 ES6 寫點範例$ mkdir -p assets/js/lib$ mkdir -p assets/js/components&gt; 模擬真實狀況組織 js 目錄 建立 assets/js/lib/Cat.js 1234567891011export default class Cat &#123; constructor (name) &#123; this.name = name; &#125; yell () &#123; var result = `$&#123;this.name&#125;: meow`; console.log(result); return result; &#125;&#125; 建立 assets/js/main.js 來載入我們的小貓類別 12345678import $ from 'jquery';import Cat from './lib/Cat';var cat = new Cat(\"Mily\");$(function() &#123; $(\".animal\").text(cat.yell());&#125;); 建立 index.html 來使用 main.js，伺服器部分先用簡單的 python -m SimpleHTTPServer 起一個 server 來測試當然如果你會其他方式例如使用 express 或者架設 apache 等也可以 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;jspm sample&lt;/title&gt; &lt;script src=\"jspm_packages/system.js\"&gt;&lt;/script&gt; &lt;script src=\"config.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=\"animal\"&gt;&lt;/span&gt; &lt;script&gt; System.import('assets/js/main'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 開啟瀏覽器輸入 http://localhost:8000/ 第一階段我們驗證了 ES6 語法和 jQuery 運作相當正常，接著我們要來試著寫一個 React Component 試試。首先要注意的是 jspm 預設只會載入 .js 副檔名，而且只處理純 js 即使我們知道 Babel 能處理 JSX 但如果你直接照著寫是會出錯誤的。要解決這個問題我們需要 jsx loader plugin 因此我們需要先安裝 jsx 和 react 1$ jspm install jsx react 在 assets/js/components/ 建立一個 Dog.jsx 123456789101112131415import React from 'react';class Dog extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt;&#123;this.props.name&#125;: bark!!!&lt;/div&gt; ); &#125;&#125;export default Dog; 回到 main.js 要注意上面說過 jspm 預設不處理 jsx ，而且就算你把副檔名換成 .js 還是會出錯，正確的用法是只要有用到 jsx 語法的檔案副檔名都應該是 .jsx接著在 import 的時候要記得副檔名和 ! 如下面範例 import Dog from &#39;./components/Dog.jsx!&#39;。 對了！因為 main.js 也要用 jsx 語法所以記得將其副檔名也換掉喔，index.html 裡面的 System.import 也要加入特殊語法。 1234567891011121314import $ from 'jquery';import React from 'react';import Cat from './lib/Cat';import Dog from './components/Dog.jsx!'var cat = new Cat(\"Mily\");$(function() &#123; $(\".animal\").text(cat.yell());&#125;);React.render(&lt;Dog name=\"Wally\"/&gt;, document.getElementById(\"dog\"));/* 警告: Warning: `require(\"react\").render` is deprecated. Please use `require(\"react-dom\").render` instead.*/ 修改 index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;jspm sample&lt;/title&gt; &lt;script src=\"jspm_packages/system.js\"&gt;&lt;/script&gt; &lt;script src=\"config.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=\"animal\"&gt;&lt;/span&gt; &lt;span id=\"dog\"&gt;&lt;/span&gt; &lt;script&gt; System.import('assets/js/main.jsx!'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 至此我們已經玩完一輪基本的使用方式了 - 完整範例上面示範的方式是在 html 頁面加上 SystemJS loader 和 config.js 基本上我們需要啟動一個 server 才能存取，不過您也可以透過下面這種方式直接存取檔案 Mac 的 Chrome 使用者可以執行 /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --allow-file-access-from-files &amp;&gt; /dev/null &amp; Firefox 先切換到 about:config, 搜尋 security.fileuri.strict_origin_policy 把值改成 false 這個時候 config.js 的 baseURL 就要設成 . 這樣才能正常運作 最佳化12345$ jspm bundle assets/js/main --inject# 一般 JS$ jspm bundle assets/js/main.jsx! --inject# JSX 的指令格式 之後 system.js 就會自動取得這個 bundle.js 另外還可以使用 jspm bundle-sfx assets/js/main 來建立一個獨立的 bundle script 如此一來就不用在 html 中使用 config.js 和 system.js 結論總結來說 jspm 試圖從安裝函式庫到封裝全部一起處理，且盡可能不需要你去設定。整體用起來到還是蠻簡潔的。要用類似 webpack-dev-server 的可以參考 jspm-server。似乎 webpack 有的東西都在慢慢補齊中。不過以 React 的立場來看 webpack 的資源和參考還是多一點。 因為前端工具更新的速度實在太快了這邊想對目前用過的東西做點簡單的總結 Grunt gulp 本質上是任務管理工具 所以我們可以組織打包，測試，任何想做的事等於幫我們建立一堆指令 webpack, browserify, RequireJs 處理模組與相依性管理 所以只要在設定檔設定哪個檔案類型該怎麼處理(封裝編譯)，它就會幫你處理編譯模組以及模組載入 Grunt, gulp 和 webpack 這類工具處理問題的角度不同，一個是讓你組織各種任務，一個是針對檔案類型處理如何編譯，壓縮，封裝，載入 npm 本質上為模組(函式庫)的管理工具 + 簡易的任務工具 安裝，移除，顯示資訊。 透過 package.json 執行寫在裡面的 script jspm 概念上為 npm + webpack(但目前沒有 webpack 功能那麼全面) 因為除了是一個模組(函式庫)的管理工具外還使用 System.js 處理模組載入的部分 資源 jspm React with JSPM","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"//andyyou.github.io/tags/nodejs/"},{"name":"package manager","slug":"package-manager","permalink":"//andyyou.github.io/tags/package-manager/"},{"name":"bundler","slug":"bundler","permalink":"//andyyou.github.io/tags/bundler/"},{"name":"jspm","slug":"jspm","permalink":"//andyyou.github.io/tags/jspm/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"參透 OOCSS","slug":"understand-oocss","date":"2015-08-10T21:40:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/08/11/understand-oocss/","link":"","permalink":"//andyyou.github.io/2015/08/11/understand-oocss/","excerpt":"OOCSS 的兩個核心觀念 分離結構(html tag 結構)與樣式(ui 的樣式) Separate structure and skin 分離容器(layout 佈局)與內容(直接包 content 的 tag) Separate container and content最後達到重複使用樣式的最高原則","text":"OOCSS 的兩個核心觀念 分離結構(html tag 結構)與樣式(ui 的樣式) Separate structure and skin 分離容器(layout 佈局)與內容(直接包 content 的 tag) Separate container and content最後達到重複使用樣式的最高原則 搭配 BEM 的歸納邏輯如果套上 BEM 的規則那就是 123structure -&gt; container (block) -&gt; content (block | element)skin -&gt; modifier 先找出相同結構的 html tag structure 以 blog 系統為例 列表頁有文章的 meta-data, 文章頁也有 meta-data, html 的結構一樣但視覺 ui 長的不同。這些結構就可以定義一個 object 按照 OOP 的觀念但實際上只是 html 和 css 的組成 這邊有一點要強調不管是 BEM 或 OOCSS 甚至其他方法都提到不要讓樣式相依於結構。舉例如下 123&lt;div class=\"navbar\"&gt; &lt;span class=\"navbar-button\"&gt;Logo&lt;/button&gt;&lt;/div&gt; 1234.navbar &gt; span &#123; /.../ &#125; // 錯誤：這樣樣式就會相依於結構，一定要 .navbar 搭配子項目 span 才會成立/* 另外也不要直接用 tag 選擇器，會導致對元素依賴，實際的例子即 bootstrap 的 .btn 可以套用到 a, button 上 */.navbar-button &#123; /.../ &#125; // 此時應該獨立出一個 class name 針對該元素 第一步驟的重點在於找出可重複使用的 html 結構，概念上我們認為這個東西可以抽象化為一個物件 找出結構後，再來分析誰是容器, 誰是內容，透過這樣的明確的定義與分類讓我們的 css 容易維護與增加新功能而不會影響舊有的程式碼。舉上面 meta-data 的例子，這是開發時很常見的狀況 123456789101112131415161718/*post中的meta-data*/&lt;div class=\"post\"&gt; &lt;p class=”metadata”&gt; &lt;a&gt;Author name&lt;/a&gt;commented on&lt;a&gt;21-02-2010&lt;/a&gt;@ &lt;/p&gt;&lt;/div&gt;/*comment中的meta-data*/&lt;div class=\"comment\"&gt; &lt;p class=”metadata”&gt; &lt;a&gt;Author name&lt;/a&gt;commented on&lt;a&gt;21-02-2010&lt;/a&gt;@ &lt;/p&gt;&lt;/div&gt;/*userinfo中的meta-data*/&lt;div class=\"user-info\"&gt; &lt;p class=”metadata”&gt; &lt;a&gt;Author name&lt;/a&gt;commented on&lt;a&gt;21-02-2010&lt;/a&gt;@ &lt;/p&gt;&lt;/div&gt; 接著我們就會直覺得這樣做 123.post .metadata &#123;css code&#125;.comment .metadata &#123;css code&#125;.userInfo .metadata &#123;css code&#125; 一旦這麼做 meta-data 就會相依於容器，我們應該使用擴展的方式來做，結構只下基礎通用的樣式，而同樣結構不同樣式的部分我們透過擴展 class name 來做。這個時候就會建議使用 BEM 的命名原則 - 所以我們可以總結容器和內容在 OOCSS 裡都是屬於一種物件 123.metadata--post &#123;css code&#125;.metadata--comment &#123;css code&#125;.metadata--user-info &#123;css code&#125; 在使用 OOCSS 的過程中很容易掉入表面外觀語意的陷阱，例如 col-left, col-middle, bg-gray, text-border 這樣的命名。記得保持一種重點堅持以邏輯和語意來給元素命名，不要因為懶惰而隨意命名，例如 bg-red 應該用 bg-danger 從 code 方面著手，對 code 重構，找出重複的 css rules, 通常會是像設定 background 等針對外觀，也就是說把 skin 抽出來。 重點回顧與注意事項 Separate structure and skin 分離結構(html tag 結構)與樣式(ui 的樣式) Separate container and content 分離容器(layout 佈局)與內容(直接包 content 的 tag) 讓 css 不要具有相依性也是程式中所謂的低耦合的概念，透過 BEM + OOCSS 的拆分與命名原則可以達到 注意不要掉入表面外觀語意的陷阱，堅持以邏輯和語意來給元素命名 總結簡單的來說，OOCSS 即透過兩個主要的原則將我們的 css 分類與抽象化成物件，兩個原則分別為 Separate structure and skin 和 Separate container and content，接著實作的第一步先找出重複的結構就是 html ，再依據其周遭元素的關係分類成容器 container和內容 content 再依據不同頁面或者同結構不同長相的部分來做 skin。我們定義好的這一些 class name 就好比是一個一個的物件。 過程中低耦合，即減少選擇器的相依性是主要的重點。如此才能達到重複使用也不會產生改一個爆一個的狀況。低耦合的重點: 單純用 class name 選擇器，不要使用 tag, id 等，也不要從物件定義的外部來影響樣式。不使用 tag 意味著也不會限制使用的元素，class name 應盡可能讓所有元素都能套用。 堅持以邏輯和語意來給元素命名，搭配使用 BEM 實作起來更有規則 先下通用的基礎樣式，再使用擴展的方式來增加不同的 skin(modifier) 最後搭配 BEM 的圖示讓我們快速記住關係 123structure -&gt; container (block) -&gt; content (block | element)skin -&gt; modifier 參考資源OOCSS觀念篇","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"//andyyou.github.io/tags/oocss/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"再讀一遍 BEM","slug":"understand-bem-again","date":"2015-08-10T21:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/08/11/understand-bem-again/","link":"","permalink":"//andyyou.github.io/2015/08/11/understand-bem-again/","excerpt":"前言BEM 不是什麼新東西了，會有這一篇純粹是因為之前都只是依樣畫葫蘆的去使用 BEM 看了幾篇 slider 就上沒有認真理解過。當然寫起來就滿頭包。這一篇花了一點時間歸納總結這個看似簡單卻實用的 css 組織的方法","text":"前言BEM 不是什麼新東西了，會有這一篇純粹是因為之前都只是依樣畫葫蘆的去使用 BEM 看了幾篇 slider 就上沒有認真理解過。當然寫起來就滿頭包。這一篇花了一點時間歸納總結這個看似簡單卻實用的 css 組織的方法 介紹在那些比較小型的網站中，如何組織樣式 css 並不是很大的問題，就是進到該專案的目錄直接撰寫一些 css 或者是 sass。接著透過 sass 的 production 設定編譯它變成一個單一的 css 檔案然後從模組中整理取得 css 變成一個整潔的 package 然而當這個專案變得越來越大越來越複雜，如何組織這些程式碼就變成效能的關鍵。重點不只在花多少時間，還包括寫了多少程式碼，以及瀏覽器要載入多少檔案。當你處於團隊工作的狀況或需要高效能時這些尤其重要 對於那些長時間的專案或者前人留下來的程式碼當然也是很重要 方法其實有很多方法目的都在處理簡化 css 程式碼和組織這些 css 讓協同開發者可以維護。很顯然的在像是 Twitter Facebook 和 Github 這種專案會需要不過其他專案通常隨著需求增加其實很快的也會變成大量的 css OOCSS Object Oriented CSS - 透過 css 物件來分離容器和內容 SMACSS Scalable and Modular Architecture for CSS - 透過樣式指南或說規則來寫 css ，通常真對 css 樣式定義成 5 種分類 SUITCSS - 結構化 class 名稱和有意義的 - 連字號 ACSS Atomic CSS - 打破樣式組織的方式變成比較瑣碎的規則，像原子的概念一樣用多個 class 組出樣式，這些 class 通常具有不可分割性。 為什麼 BEM 超過其他不管你在專案中選擇哪中方式您都能得到結構化 css 和 ui 的好處。其中一些東西並沒有很嚴格的限制並且具有彈性。那些方法通常非常容易理解而且適用於團隊工作。與其我們自己提出 BEM 的優點，我們決定讓你看看其他人的看法 我選擇 BEM 的理由可以歸納成一點，比起其他方法它比較不會令人產生疑惑，還為我們想用的架構即 OOCSS 提供一個容易識別的術語 我很高興開始使用它，最終我得到了一個有秩序的東西。我得到了一個整潔的系統來命名元素。它釋放了在我腦袋中佔據的大量資源，因為即使像是替元素 class 命名這種微不足道的小事卻意外地佔據大量的大腦資源。 不像 OOCSS 它並不是為了處理關於 css 全部的模組化，反倒是像是命名空間的概念，透過 class 名稱建立各自獨立的 css 模組，並且不會互相干擾 BEM 是一個非常有幫助，強大且簡單的命名慣例，讓我們前端的程式碼更好閱讀，好理解，容易維護，容易擴展，更強健也更明確 BEM Blocks, Elements and Modifiers你不會感到太意外，BEM 就是這些關鍵處理原則的縮寫 - Block, Element, 和 Modifier。一套嚴格的命名規則可以在另一篇命名的文章找到 舉下面 Github 網站為例來說明 Block - 一個獨立的區塊具備自己特有的意義，例如: header, container, menu, checkbox, input Element - Block 的一部分並且不具有獨立自己特有的意義，這些元素依賴 Block 的意義。例如: menu item, list item, checkbox caption, header title Modifier - Block 或 Element 上的特殊標記，用來改變原來行為或外觀例如: disabled, highlighted, checked, fixed, size big, color yellow 運作的機制與原理讓我們來看看在頁面上的一個特定元素怎麼透過 BEM 來實作。我們將從 Github 的樣式指南中取出 button 通常我們需要一個普通的按鈕針對大多數的出現在界面上的狀況然後其他兩種不同的狀態。因為 BEM 透過 class 選擇器來套用樣式，所以我們可以將樣式套用在任何元素上(例如按鈕的樣式套用到 button, a 甚至 div)。這個時候重點就是採用下面這種規格來命名 block--modifier--value 1234567&lt;button class=\"button\"&gt; Normal button&lt;/button&gt;&lt;button class=\"button button--state-success\"&gt;Success button&lt;/button&gt;&lt;button class=\"button button--state-danger\"&gt;Danger button&lt;/button&gt; 123456789101112131415161718.button &#123; display: inline-block; border-radius: 3px; padding: 7px 12px; border: 1px solid #D5D5D5; background-image: linear-gradient(#EEE, #DDD); font: 700 13px/18px Helvetica, arial;&#125;.button--state-success &#123; color: #FFF; background: #569E3D linear-gradient(#79D858, #569E3D) repeat-x; border-color: #4A993E;&#125;.button--state-danger &#123; color: #900;&#125; 延伸閱讀想知道更多範例可以閱讀Building My Health Skills - Part 3 優點 模組化 - Block 的樣式不應該相依於頁面中其他任何元素，亦為一個 Block 不管放在哪裡都要長得一致，因此永遠不會因為濫用 css 繼承規則的部分就是因為不斷堆疊樣式產生肥大的樣式而降低效能。同時這樣做也具備了讓我們可以輕鬆把一個已經做好的樣式轉換到另外一個專案 重複使用性 - 可以用不同的方式來組合各自獨立的 Block 達到重複使用性也減少 code 的數量，也比較好維護。如果你已經有設計指南或公司內部的一些規則那麼它就能協助你有效率的區分，建立，定義 Block 結構化 - BEM 讓我們的 css 具有容易理解的特性與結構，簡單易維護，不用再一直記著樣式之間的耦合關係。 命名Phil Karlton 說過在電腦科學的領域只有兩個困難的問題: cache invalidation 和命名 cache invalidation 快取無效化背後的意義就是什麼時候該把暫存刪掉 這是已知的事實，而正確的樣式指南可以明顯的增加開發的速度，debug 和在既有的程式中實作新功能的速度。很不幸的大部份的 css 沒有任何架構和命名規則。這導致 css 長久以來都是處於異常難以維護的狀態。 這個 BEM 的方法確保每一個開發者使用相同的慣例，正確的命名讓我們未來在修改維護時相對輕鬆 block 封裝一個獨立的區塊，上面說過這個區塊需要具備自己的意義。而 block 可以被嵌入其他 block 之中並與其互動，同時維持一致的語意。注意這裡並沒有優先順序或者繼承的概念。也不要使用 DOM 來表示整個區塊 命名：block 的名字可以由英文，數字和連字號組成，目的是將 css class 的命名格式化，當然也可以加入一些簡短的前綴來達到命名空間的效果例如 .block HTML：不要讓侷限 block 套用的元素標籤，任何 DOM 元素只要使用該 class 就能套用 block 的樣式 css： 只使用 class name 選擇器 不能直接用 tag 或 id 來選元素 在頁面上不能相依其他 blocks 或 元素 element 為 block 的一部分並且相依於 block 的意義，舉例來說就像是 list 中的 item 即為一個 element 命名：element 的命名可由英文，數字，連字號(破折號)或底線組成，css class 的格式為 block 的名字加上兩個底線 __ 再加上 element 名稱 舉例來說 .block__elem HTML：任何在 block 內的 DOM node 就可以是一個 element，在給定的 block 內所有的 element 都具有相等的語意 css： 同樣只用 class name 選擇器 不用 tag 或 id 在頁面上不能相依於其他 block 或元素 .block_elem { color: #042 }; 正確 .block .block__elem { color: #042; } 錯誤 modifier 是 block 或 element 上的特殊註記，用來改變外觀，行為，或狀態舉例來說就是一個 button 可以有正常可點擊的狀態和 disabled 停止使用的狀態，要注意的是這是附加的樣式不能單獨存在一定要搭配原來的 block/element 才行 命名：同樣的 modifier 名稱可以由英文，數字，連字號(破折號)和底線所組成，css class 格式為 block 或 element 名稱加上兩個 dash .block--mod, .block__mod--mod .block--color-black HTML：modifier 是額外的類別名稱讓我們可以加在 block 或 element 來使用，一個 modifier 只能被用在 block 或 element 並且要保留原來的 class，不能用 modifier 取代掉原來的 block / element &lt;div class=&quot;block block--mod&quot;&gt;正確&lt;/div&gt; &lt;div class=&quot;block block--size-big block--shadow-yes&quot;&gt;正確&lt;/div&gt; &lt;div class=&quot;block--mod&quot;&gt;錯誤，取代了原來的類別&lt;/div&gt; css：直接使用 class name 選擇器 .block--hidden { display: none; } 基於 block 層來調整底下的元素 .block--mod .block__elem element 的 modifier .block__elem--mod 備註 sass 用法123456.block &#123; &amp;__element &#123; &#125; &amp;--modifier &#123; &#125;&#125; 總結簡單說來所謂的 B.E.M 就是用 block, element, modifier 三種分類針對 UI 去分析區分歸納，最後協助我們替 class name 命名的一組嚴格規則block 為一個具有獨立意義的區塊，獨立的意思就是在每個頁面甚至在別的 block 裡面行為外觀都要一致。element 則是相依於 block 就是 block 的子項目，沒有自己獨立的意義，其意義與使用時要依附在 block 底下modifier 是一種特殊的註記用來調整改變 block/element 的外觀(樣板)，行為，狀態明白這三種定義讓我們可以去歸納介面上的 css 該怎麼組織分類進而管理 因為一個 block 不能相依於其他標籤，獨立不相依真正的意義就是在任何頁面甚至是嵌入其他 block 外觀行為都要一致，不綁定不限制只能在特定元素使用。舉例來說就像 bootstrap 的 .btn 可以在 a, button 甚至 div 都能套用。當 block 之間不會互相污染或被連動影響那麼我們在撰寫修改上就不怕有太多不預期的行為 最後就是該怎麼用：block/element/modifier 都只用 class name 選擇器，不依賴 css 的繼承或是像 .nav &gt; h1 這樣的方式。好處是可以大幅減少過度被覆寫或不斷被繼承而沒有實際效果的 css，只有單一階 css selector 就能選到元素效能也相對提升第一個是 block 就用一般英文數字命名，實際上三者都是英數加上 _ - 來完成命名如果是 element 則用 __ 加在 block 和 element 中間例如：block__elem最後一個 modifier 則是 -- 例如：block--mod 或 block__elem--mod如果名字較複雜有兩個英文單字則中間用一個 - 連結 如 block__nav-item--disabled 撰寫的流程為先分析 ui 再照規則寫 css 就好了，再透過下面範例快速掌握 123456&lt;form class=\"form form--theme-xmas form--simple\"&gt; &lt;input class=\"form__input\" type=\"text\" /&gt; &lt;input class=\"form__submit form__submit--disabled\" type=\"submit\" /&gt;&lt;/form&gt; 123456.form &#123; /* ... */ &#125;.form--theme-xmas &#123; /* ... */ &#125;.form--simple &#123; /* ... */ &#125;.form__input &#123; /* ... */ &#125;.form__submit &#123; /* ... */ &#125;.form__submit--disabled &#123; /* ... */ &#125; 參考資源BEM 101getbem","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Webpack 筆記","slug":"webpack","date":"2015-07-23T00:30:00.000Z","updated":"2016-10-10T13:22:25.000Z","comments":true,"path":"2015/07/23/webpack/","link":"","permalink":"//andyyou.github.io/2015/07/23/webpack/","excerpt":"動機今時今日所謂的網站正進化成網路應用程式，它不再只是單純的顯示圖片文字資訊，而包含著更多互動與操作行為，同時也意味著一個網站: 具有更多的 Javascript 可以在現代的瀏覽器上做更多事 較少全頁重新載入的行為 ➞ 甚至更多程式碼在單一頁面","text":"動機今時今日所謂的網站正進化成網路應用程式，它不再只是單純的顯示圖片文字資訊，而包含著更多互動與操作行為，同時也意味著一個網站: 具有更多的 Javascript 可以在現代的瀏覽器上做更多事 較少全頁重新載入的行為 ➞ 甚至更多程式碼在單一頁面 其結果就是有更多程式碼出現在客戶端(Client side)有大量的程式碼需要被組織化。模組化系統提供一種方式讓我們可以切割我們的程式碼使其變成個別的模組。 如果您是實作派的可以直接看 跟著官方文件實作一遍 下面除了官方入門，同時也搭配 Pete Hunt 的 webpack-how-to 實作一遍常用的功能 模組化系統的風格針對如何定義模組之間的相依性，在 JS 世界中有很多不同的標準: &lt;script&gt; 標籤(不具備模組化系統) CommonJS AMD 以及其衍伸的標準 ES6 模組 其他 &lt;script&gt; 標籤當你不使用任何其他模組化系統，這是你在網頁中處理模組或說切割 JS 檔案的方法。 1234&lt;script src=\"module1.js\"&gt;&lt;/script&gt;&lt;script src=\"module2.js\"&gt;&lt;/script&gt;&lt;script src=\"libraryA.js\"&gt;&lt;/script&gt;&lt;script src=\"module3.js\"&gt;&lt;/script&gt; 這種方式通常一個模組會匯出介面到全域物件，即 window 物件，模組可以透過全域物件存取相依的介面或叫方法。常見的問題 在全域物件中產生衝突 載入的順序非常重要，錯了其他需要相依的函式庫就不能用 開發者必須要自己解決模組和函式庫之間相依性的問題 在大型專案中這一串載入的列表可能非常長，難以維護 CommonJS 同步 require這種方式採用同步風格的 require 方法，類似我們 C# 的 using, Ruby 的 require 或 load，透過這個方法載入相依的函式庫並匯出一系列介面一個模組可以透過在 exports 加上屬性(Property)或 module.exports 的值來設定其介面，這段話有點抽象換成白話一點的解釋: 根據 CommonJS 標準，一個檔案即一個模組。載入模組使用 require 方法，這個方法會讀取檔案並執行，最後回傳檔案內部 exports 的物件。 1234567891011121314151617181920212223// 基礎的用法require('module');require('../file.js');exports.doStuff = function () &#123;&#125;;module.exports = someValue;// 簡易的範例/*** car.js ***/function Car() &#123; this.run = function () &#123; console.log(\"Car run...\"); &#125; this.stop = function () &#123; console.log(\"Car stop!!\"); &#125;&#125;var car = new Car();module.exports = car;/*** main.js ***/var Car = require(\"./car\");Car.run(); // Car run... 明白了一點點用法後我們知道 CommonJS 載入模組是同步的。 優點 伺服器端模組可以被重複使用 已經有許多 npm 的模組採用這種風格 因為其語法和用起來簡單易懂 缺點 阻塞式的調用並不適合網路環境，因為網路溝通的 request 是非同步的 沒有支援多模組的平行載入實作 node.js browserify modules-webmake wreq AMD 非同步載入因為瀏覽器的需求以及同步 require 的問題，所以引進了一個非同步的版本 12345require(['module', '../file'], function(module, file) &#123; /* code here */&#125;);define('mymodule', [\"dep1\", \"dep2\"], function(d1, d2) &#123; return someExportedValue;&#125;); 優點 符合網路非同步載入的需求 可多模組平行載入 缺點 需撰寫比較多的程式碼，比較難讀寫(對開發者來說)和維護 看起來像是某種取巧的解法實作 require.js curl ES6 模組ECMAScript6 內建的用法 123import \"jquery\";export function doStuff() &#123;&#125;module \"localModule\" &#123;&#125; 優點 靜態解析非常容易 未來將會是標準缺點 瀏覽器全面支援需要花些時間 非常少模組已採用此種方式 兼容的解決方案讓開發者選擇模組化的標準，讓已存在的程式碼可以運作，使其可以輕鬆的加入其他模組標準。 關於傳輸模組通常會在客戶端執行，所以必須從伺服器端傳輸到瀏覽器。 這邊有兩種關於傳輸模組的極端例子: 每一個模組一個請求 所有模組整合成一個請求 兩者都被廣泛的使用，但也都不是最佳的做法 關於一個模組一個請求 優點: 只有需要的模組會被傳輸，不會傳一堆不相關的東西 缺點: 太多 request 缺點: 因為 request 太多導致可能害應用程式初始化或者第一次載入時很慢 所有模組整合成一個請求 優點: 較少的請求數，程式開始的時候比較快 缺點: 不需要的模組也會被一併傳輸 分組傳輸一種比較彈性的傳輸，在上面兩種極端的方法中取得平衡的折中作法。在編譯所有模組時: 將系列模組區分成多個較小的區塊(程式碼片段)如此一來就不用在初始化的時候一口氣全部載入，只要根據需求載入即可 為什麼不僅僅只載入 Javascript?我們應該反問為什麼模組化系統只協助開發者處理 Javascript? 還有其他靜態資源檔案需要被處理: stylesheets images webfonts html for templating 還有其他 coffeescript ➞ javascript less stylesheet ➞ css jade ➞ html i18n ➞ something 1234require(\"./style.css\");require(\"./style.less\");require(\"./template.jade\");require(\"./image.png\"); 因為上面這些動機，所以您找到了 webpack。 Webpack 是什麼?webpack 簡單說就是一個模組的封裝工具(module bundler)，由德國的 Tobias Koppers 所開發。webpack 會將模組與其相依性的模組, 函式庫, 其他需要預先編譯的檔案等整合產生此模組的靜態資源檔嫌太饒舌，那我們直接看官方的圖片，就是把我們常用的 .less, .scss, .jade .jsx 等等的檔案編譯成單純的 js + 圖片(圖片有時候也可以被編譯成 base64 格式的 dataUrl)。第一次接觸 Webpack 的人可能會忽略這個重點(小弟就是其一)，那就是編譯後的靜態資源檔真的就如圖上所示，只有 js + 圖片。css也會被編譯到 js 中，也就不需要在額外匯入。達到真正的模組化。看看下圖一隻編譯完成的檔案 為什麼不用其他 bundler?已存在的 bundler 針對大型專案並不是真的那麼適合，這裡指的是大型的 SPA。為什麼要創造 webpack 最重要的動機就是需要 Code Splitting 拆分程式碼，同時像是 css, 圖片等等靜態資源檔需要無縫整合。這邊的拆分程式碼指的是依照需求，功能來區分模組達到關注點分離。如果您曾經試過其他 bundler 他們並無法達到這個目的。大部份都只是個別組織 JS 檔案和靜態資源檔案。因此 webpack 為了滿足這個動機而誕生。 目標 能夠拆分相依性的關係結構變成程式碼片段，然後依據需求載入 盡可能減少初始化載入的時間 每一個靜態資源檔也應該要能被模組化 有能力整合其他第三方函式庫為模組 bundler 絕大部份能夠依照需求自訂修改 適合大型專案 Webpack 有哪些不同?Code Splitting 拆分程式碼webpack 在其相依性結構(Dependency tree)中有兩種相依的類型: sync 和 async。以非同步相依作為分割點，形成一個新的片段。當 chunk tree 程式碼片段之間的結構被優化之後，就會透過一個檔案整合發佈每一個 chunk 即每個片段程式碼。 loaders 載入器載入器當然是翻得不好，一般來說其意義就是負責載入安裝程式的角色，所以這邊我們還是稱其為 loader。雖然 webpack 本身只能夠處理 Javascript，不過因為有 loaders，可以被用來轉換其他資源為 Javascript ，透過這種方式每一個資源檔都可以被轉換成模組形式。換個方式來比喻其實 html 的 &lt;link rel=&quot;stylesheet&quot; /&gt; 就是一個 css 載入器的角色，又或者有用過 browserify 的人所熟悉的 transforms。其功能為轉換解析 ➞ 載入 ➞ 使用。 智慧型解析webpack 擁有更聰明的解析工具可以處理幾乎所有的第三方函式庫。甚至允許在相依性設定上使用表達式，例如: require(&quot;./templates/&quot; + name + &quot;.jade&quot;)。這幾乎能處理大部份的模組化標準(CommonJS, AMD) 擴充套件系統webpack 擁有豐富的擴充套件。大部份內部的功能都是架構在擴充套件之上。這使得我們能夠自訂客製 webpack 來滿足我們的需求，並且可以發佈成通用套件為 Open Source至此我們對於 webpack 有了一點概念性的了解。 安裝 webpacknode.js使用 webpack 之前我們需要安裝 node.js 以及其內建的套件管理工具 npm webpack接著就可以透過 npm 直接安裝 webpack 1$ npm install webpack -g 透過 -g 參數 webpack 會被安裝在系統全域環境同時具備 webpack 指令 在專案中使用 webpack在專案中使用 webpack 最好也讓專案相依於 webpack，即透過 npm 為專案安裝 webpack。透過這個方式我們可以選擇調整 webpack 的版本，而不必被強迫使用全域的版本。建立專案的步驟首先需要建立一個 package.json 設定檔或者直接使用 npm 指令來產生 1$ npm init 關於 npm init 會用互動的方式在指令介面問你的問題，如果專案不會公開出去的話其實也不是太重要接著一樣透過 npm 指令安裝 webpack 1$ npm install webpack --save-dev 版本一般來說 webpack 同時間會有兩個版本。穩定版以及 Beta 版本。Beta 版會加後綴 -beta 在版號後面。Beta 版本可能會部分實驗性或較不穩定缺少足夠測試的功能，對於需要較嚴謹的東西應該使用穩定版較佳。您可以透過指令來指定安裝的版本 1$ npm install webpack@1.2.x --save-dev 接著我們就可以來看看該如何使用 指令介面安裝全域指令1$ npm install webpack -g 單純編譯指令1$ webpack &lt;entry&gt; &lt;output&gt; entry傳入一個檔案或者路徑字串。您可以傳入多個程式進入點檔案(每一個檔案將會在啟動期間被載入)，entry 用實作的行為來說明就是那隻用來 require 其他模組的檔案。另外如果你使用 &lt;name&gt;=&lt;filename/request&gt; 的格式您可以替 entry point 建立一個別名。用法如下 12$ webpack bar=./entry.js \"[name].js\"&gt;&gt; output a bar.js file. 同時這個名稱也會被對應到設定檔 entry，太難懂！！沒關係我們換個實際例子來證明這段說明，首先我們建立一個 webpack.config.js 123456// webpack.config.jsmodule.exports = &#123; output: &#123; filename: \"[name].bundle.js\" &#125;&#125; 接著執行指令 12$ webpack FooBar=./entry.js&gt;&gt; Output a file that is named FooBar.bundle.js output參數: 表示欲輸出的路徑，其會被映射到設定檔中的 output.path 以及 output.filename 設定參數webpack 有很多參數能夠直接從指令去設定然後對應到設定檔，即 --debug 對應到 debug: true，--output-library-target 對應到 output.libraryTarget 套件有些套件被映射到指令的參數選項，即 --define &lt;string&gt;=&lt;string&gt; 會對應到 DefinePlugin Development 縮寫 -d等同於 --debug --devtool source-map --output-pathinfo，產生 source maps 檔案 Production 縮寫 -p等同於 --optimize-minimize --optimize-occurence-order，建置壓縮的程式碼 監視模式 –watch會一直監視所有的相依檔案當其改變時自動重新編譯，適用於開發模式持續性的更新編譯 指定設定檔 –config設定不同於預設的設定檔。如果您希望採用不同於預設 webpack.config.js 的設定檔可以採用 --config 來指定 顯示參數--progress: 顯示編譯的進度和訊息--json: 產生 JSON 格式的 stdout--color: 彩色模式--sort-modules-by, --sort-chunks-by, --sort-assets-by: 排序--display-chunks: 顯示模組區分的資訊--display-error-details: 顯示更多關於錯誤訊息 跟著官方文件實作一遍首先是您當然需要安裝 node.js 接著安裝 webpack。 1$ npm install webpack -g 開始組織專案建立一個空目錄來置放我們的檔案，在該目錄底下建立 entry.js 12// File: entry.jsdocument.write(\"It works.\"); 123456789&lt;!-- File: index.html --&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"bundle.js\" charset=\"utf-8\" /&gt; &lt;/body&gt;&lt;/html&gt; 執行 1$ webpack ./entry.js bundle.js 就會將我們的 entry.js 編譯成 bundle.js如果編譯成功，就會輸出類似下面的資訊 123456Hash: e97678c23acf8ee01956Version: webpack 1.9.10Time: 62ms Asset Size Chunks Chunk Namesbundle.js 1.44 kB 0 [emitted] main [0] ./entry.js 29 bytes &#123;0&#125; [built] 接著開啟 index.html 如下圖 第二個資源檔案接著我們模擬實際專案的狀況，匯入另外一個檔案 content.js 12// content.jsmodule.exports = \"It works from content.js\"; 然後編輯 entry.js 加入 require 12// File: entry.jsdocument.write(require(\"./content.js\")); 更新瀏覽器得到如下圖 Webpack 會分析進入點檔案並取得相依的其他檔案。這些檔案(被稱為模組)也會被加入到 bundle.js。Webpack 會給每一個模組唯一的 ID 然後透過 ID 存取這些模組，這些模組都會被整合到 bundle.js 裡面。只有進入點的模組會在程式啟動時被執行。這個小範例示範了 require 以及當相依模組被 require 載入後執行的用法。 第一個 loader現在我們遇到一個問題，我們想要加入 css 到該應用程式中，Webpack 預設只能夠處理 JS 檔案，所以我們需要 css-loader 來處理 css 檔案。接著透過 style-loader 來把樣式套用到 DOM 上。 建立一個空的 node_modules 目錄(或者您要使用 npm init)，事實上直接使用 npm install 也是會自動建立 node_module 目錄。執行 1$ npm install css-loader style-loader 加入 style.css 123body &#123; background: yellow;&#125; 再次編輯 entry.js 12require(\"!style!css!./style.css\");document.write(require(\"./content.js\")); 重新編譯並重整瀏覽器得到 透過在匯入模組(在這邊就只是一隻檔案)前加上 ! 和 loader 的前綴字，該模組將會逐步透過每一個 loader 處理，一個 pipeline 的概念，一個處理完交棒給下一個處理，這些 loader 會將檔案中的內容根據特定需求轉換。在經過這些轉換的過程之後最終的結果就是一個 javascript 模組。 綁定 loaders實務上，我們並不希望一直重複撰寫這種長長的 pipe 方式，即 require(&quot;!style!css!./style.css&quot;);我們可以根據副檔名綁定或說設定其 loaders，如此一來我們就只要寫 require(&quot;./style.css&quot;) 改寫 entry.js 123// entry.jsrequire(\"./style.css\");document.write(require(\"./content.js\")); 透過指令的方式繫結 1234$ webpack ./entry.js bundle.js --module-bind 'css=style!css'# 有一點要注意的是因為 ! 在 bash 裡面有特殊意義所以當您想用 \" 替代 ' 請記得跳脫$ webpack ./entry.js bundle.js --module-bind \"css=style\\!css\" 您應該會看到跟上面黃色底一樣的結果 設定檔除非你是下指令狂，不然您應該不會希望每次指令都這麼長，這時我們可以把這些參數移到一個設定檔裡 webpack.config.js 123456789101112module.exports = &#123; entry: \"./entry.js\", output: &#123; path: __dirname, // 此設定檔案所在的目錄 filename: \"bundle.js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: \"style!css\" &#125; ] &#125;&#125; 一旦您有了設定檔，現在你只需要執行 1$ webpack webpack 指令會試圖去載入當前目錄下的 webpack.config.js 整潔易看的輸出隨著我們的專案增長，編譯的時間可能會稍微長一點點。所以我們希望在編譯的時候有進度表以及我們希望輸出的資訊可以有顏色以便我們好觀察這個時候我們可以透過下面參數達成 1$ webpack --progress --colors 監視模式 watch又或許在開發時期我們不希望一直手動輸入指令 1$ webpack --progress --colors --watch Webpack 可以快取沒有改變的模組。 當使用監視模式，webpack 會觀察專案底下所有在編譯時會用到的檔案，如果這些檔案發生改變，馬上會重新編譯當快取被啟動的時候 webpack 會將所有模組存在記憶體中，如果模組沒有改變就會繼續沿用。 開發時期伺服器更好用的開發時期的伺服器 webpack-dev-server 1234# 安裝$ npm install webpack-dev-server -g# 啟動$ webpack-dev-server --progress --colors 提供一個 localhost:8080 的 express server ，讓我們在開發時期可以更快速的觀察結果，當然會自動編譯，同時自動更新頁面(socket.io)這個工具使用 webpack 的監視模式所以編譯的結果 這個開發伺服器使用了 webpack 的監視模式。同時他也會阻止 webpack 持續把編譯結果存到硬碟上，取而代之的這個結果會被保留在記憶體。不要誤會！這邊說的是如果你單純使用 webpack 監視模式，上例中的 bundle.js 檔案是會被產生的，但如果是 webpack-dev-server 則不會產生 bundle.js 那隻檔案。 webpack-how 跟著 Pete hunt 的文件再跑一輪這個段落我們會在翻譯以及實作 webpack-howto 來加深我們對 webpack 的理解，老實說因為官方的文件並不是非常完整。 1. 為什麼使用 webpack (Pete hunt 版) 它很像 browserify，但是他可以分割程式為多個檔案。例如您在一個單一頁面應用程式(SPA)中有數個頁面，那麼使用者只需要下載正在閱讀的那一頁，如果他切換到另個頁面，也不會重新下載共用部分的程式碼 大多數的情況下可以取代 grunt 或 gulp 因為他也可以封裝 css, 預先編譯的 css 語言, 預先編譯的 js 語言, 圖片以及其他東西 同時它支援 AMD 和 CommonJS 以及其他模組標準。如果您不知道該使用什麼，就用 CommonJS 2. 對於會用 Browerify 的開發者下面兩個指令是等價的 123$ browserify main.js &gt; bundle.js$ webpack main.js bundle.js 然而 webpack 比起 Browserify 更加強大，也因為支援許多功能，所以一般來說我們會將設定存放在 webpack.config.js 這隻設定檔。讓我們再來多練習一次，建立一個 webpack_sandbox 目錄，裡面自己放一些簡單的 main.js 主要的進入點程式，index.html 測試載入 bundle.js 是否正常運作，以及最重要的 webpack.config.js 如下 123456module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125; 這個 webpack.config.js 就只是 Javascript ，所以就像你平常寫 js 一樣修改它即可。 3. 如何執行 webpack一般來說我們常用的編譯指令如下，記住先切換到 webpack.config.js 所在的目錄底下然後執行 webpack 建置編譯開發版的檔案，只會運行一次 webpack -p 執行一次建置的任務，產生正式版(具有壓縮) webpack --watch 持續性編譯，即開發時期，每次一變更檔案就重新編譯(快速) webpack -d 包含產出 source maps，即 .js.map 檔案 4. 預先編譯的 JS 語言在 webpack 中有個跟 browserify 的 transforms 以及 RequireJS plugin 功能相等的東西，就是 loader。下面示範如何讓 webpack 載入 CoffeeScript 和 Facebook 的 JSX + ES6 支援(您必須要安裝 babel-loader coffee-loader)，因為 babel 內建搭載支援 JSX 所以您不需要再增加額外的 jsx-loader。 為了要實際測試，我們需要再目錄中建立一個 coffee, React 元件(JSX + ES6 支援)首先先測試 coffee 所以我們新增一隻測試的 coffee 123# File: audi.coffeevalue = \"It's from audi.coffee\" if true # it's coffeescript syntax.module.exports = value; 安裝 coffee-loader 12$ npm init$ npm install coffee-loader --save-dev 調整 webpack.config.js 123456789101112// File: webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, ] &#125;&#125; 測試，在 main.js 中使用 1234567// File: main.jsdocument.write(\"Hey from main.js\");document.write(\"&lt;br/&gt;\");var audi = require(\"./audi.coffee\");document.write(audi);document.write(\"&lt;br/&gt;\"); 接著我們來測試 jsx 與 React，記得先安裝 babel-loader 1$ npm install babel-loader --save-dev 調整 webpack.config.js 為 123456789101112module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader'&#125;, ] &#125;&#125; 新增一隻 React 元件檔案 toyota.js 12345678910111213// File: toyota.jsexport default class Totota extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt; It's from toyota.js &lt;/div&gt; ); &#125;&#125; 最後 main.js(記得在 index.html 補上 React 的 JS) 12345678910111213// File: main.jsdocument.write(\"Hey from main.js\");document.write(\"&lt;br/&gt;\");var audi = require(\"./audi.coffee\");document.write(audi);document.write(\"&lt;br/&gt;\");document.write(\"&lt;div id='toyota'&gt;&lt;/div&gt;\");var Toyota = require(\"./toyota.js\");// 另外一種模組標準的寫法// import Toyota from \"./toyota.js\";React.render(&lt;Toyota /&gt;, document.getElementById(\"toyota\")); 每次在 require 的時候都要輸入附檔名也是挺麻煩的，所以 webpack 也提供您 require 不加副檔名的機制，為了開啟這個功能，我們必須要加入 resolve.extensions參數告訴 webpack 該處理哪些副檔名。 12345678910111213141516module.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader' &#125; ] &#125;, resolve: &#123; // 現在您可以把那些 require 中的副檔名去掉了 extensions: ['', '.js', '.json', '.coffee'] &#125;&#125;; 如果您是採用 webpack-dev-server 在修改 config 之後請記得重啟 如果檔名一樣會怎樣，在正常的專案底下不同類型的資源檔通常會用不同的目錄區隔，不過在這個簡單的範例中的確是有可能會重複的。webpack 其實會照上面 resolve 設定的陣列依序搜尋，找到了就不往下了。也就是如果有同名的 js 和 coffee 會處理 [檔名].js 而不管 coffee。 5. 樣式與圖片接著我們要來實作在模組中透過 require() 使用那些靜態資源檔。先示範在程式中我們會改成這樣參考資源檔，像 css, 圖片等等 123456require(\"./bootstrap.css\");require(\"./app.scss\");var img = document.createElement(\"img\");img.src = require(\"./images/pretty.jpg\");document.body.appendChild(img); 當我們 require css 或者 scss, less 等等的時候，webpack 會把 css 轉換一行的字串並封裝在 JS 中，然後當我們執行 require() 會幫我們插入 &lt;stype&gt; 標籤到該頁面而當我們 require 圖片的時候，webpack 則會把圖片轉換成 dataURI 或帶入連結。 當然這些都不是預設有的功能，你必須透過 loaders 告訴 webpack 該怎麼做，我們需要的 loaders，css-loader 和 style-loader 處理樣式，sass-loader 當然是處理 scss，url-loader 則負責處理圖片(檔案)類似。您也可以使用 file-laoder 不過 url-loader 可以設定限制檔案大小回傳 dataURI 或路徑。 這邊我們額外提一下上面說的流程中 css-loader 才是真正在解析 css 檔案，並且他會解析 css 中的 url(...) 轉換成 require(...) ，如此一來所有的資源都會依照 webpack 的處理方式載入，而 style-loader 收到這個輸出之後會把這些轉換完的結果注入 DOM 。 安裝 loaders 1$ npm install css-loader style-loader sass-loader url-loader --save-dev 設定 webpack.config.js 1234567891011121314151617181920212223// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; path: './build', publicPath: 'http://andyyou.github.io/', // 圖片等需要路徑引用的資源檔加上網址 // 注意: 尾巴的 / 要記得加否則會產出類似 http://andyyou.github.io600e2b78b83128cc2be868b3971d0999.jpg 的路徑 filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader'&#125;, &#123; test: /\\.css$/, loader: 'style!css' &#125;, &#123; test: /\\.scss$/, loader: 'style!css!sass'&#125;, // =&gt; 透過 css-laoder 不只處理編譯好的 css, imports 同時包含 url(...) // &#123; test: /\\.css$/, loader: 'raw!sass' &#125;, // =&gt; 回傳編譯好的 css 程式碼單純只解析 imports 但不處理 url(...) &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' &#125; // 當檔案小於 8K 的時候會產生 base64 格式的 dataURI 超過的話則直接帶連結 ] &#125;, resolve: &#123; extensions: ['', '.js', '.json', '.coffee', '.scss', '.css'] &#125;&#125; 6. 功能標籤我們想要某些程式碼只在特定環境下才執行，例如顯示偵錯訊息，又或者只在內部伺服器才開啟這個功能。因為我們是使用 webpack 來封裝編譯整個專案，所以很合理的可以加上一些 flag 讓 webpack 去替我們處理。我們可以直接在剛剛 main.js 中示範 12345678// main.jsif (__DEV__) &#123; console.warn(\"It's dev environments\")&#125;if (__PRERELEASE__) &#123; console.log(\"requre and show secret feature.\")&#125; 不過我們不是直接就可以使用魔術般的全域變數。我們還是需要告訴 webpack 才行下面這邊示範在 webpack 官方提到的 plugins 用法 123456789101112131415161718192021222324252627282930var webpack = require(\"webpack\");var definePlugin = new webpack.DefinePlugin(&#123; __DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV || 'true')), __PRERELEASE__: JSON.stringify(JSON.parse(process.env.BUILD_PRERELEASE || 'false'))&#125;);module.exports = &#123; entry: './main.js', output: &#123; path: './build', // 編譯後的檔案放在這個目錄 // publicPath: 'http://andyyou.github.io/', // 圖片等需要路徑引用的資源檔加上網址 // 注意: 尾巴的 / 要記得加否則會產出類似 http://andyyou.github.io600e2b78b83128cc2be868b3971d0999.jpg 的路徑 filename: 'bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader'&#125;, &#123; test: /\\.css$/, loader: 'style!css' &#125;, &#123; test: /\\.scss$/, loader: 'style!css!sass'&#125;, // =&gt; 透過 css-laoder 不只處理編譯好的 css, imports 同時包含 url(...) // &#123; test: /\\.css$/, loader: 'raw!sass' &#125;, // =&gt; 回傳編譯好的 css 程式碼單純只解析 imports 但不處理 url(...) &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' &#125; // 當檔案小於 8K 的時候會產生 base64 格式的 dataURI 超過的話則直接帶連結 ] &#125;, resolve: &#123; extensions: ['', '.js', '.json', '.coffee', '.scss', '.css'] &#125;, plugins: [definePlugin],&#125; 接著我們就能夠用 BUILD_DEV=0 BUILD_PRERELEASE=1 webpack, 或者 BUILD_DEV=0 BUILD_PRERELEASE=1 webpack-dev-server --progress --colors來帶入參數，注意到 webpack -p 壓縮程式碼的時候會把不會執行的程式碼區塊給移除，所以我們不需要擔心洩露機密的程式碼到最後產出的檔案中。 7. 多個檔案(進入點程式, entrypoints)截至目前為止我們都只有一個 entry 即 main.js ，假設我們需要替個人資料頁和訂閱頁面各自加入自己擁有的 JS，因為我們不希望讓使用者在查閱個人資料時載入訂閱頁面需要的程式碼。所以我們需要打包成兩隻檔案，也就是這兩個頁面各自有自己的 entrypoint此時我們只需要修改設定檔 123456789101112131415161718192021222324252627282930313233343536// webpack.config.jsvar webpack = require(\"webpack\");var definePlugin = new webpack.DefinePlugin(&#123; __DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV || 'true')), __PRERELEASE__: JSON.stringify(JSON.parse(process.env.BUILD_PRERELEASE || 'false'))&#125;);module.exports = &#123; entry: &#123; Main: './main.js', Profile: './profile.js', Feed: './feed.js' &#125;, output: &#123; path: './build', // publicPath: 'http://andyyou.github.io/', // 圖片等需要路徑引用的資源檔加上網址或路徑 publicPath: '/build/', // 因為有設定目錄，所以記得要補路徑，否則 require() 會取錯路徑。 // 注意: 尾巴的 / 要記得加否則會產出類似 http://andyyou.github.io600e2b78b83128cc2be868b3971d0999.jpg 的路徑 filename: '[name].bundle.js' // [name] 會使用 key 也就是上面大寫的 Main, Feed, Profile 等 &#125;, module: &#123; loaders: [ &#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader'&#125;, &#123; test: /\\.css$/, loader: 'style!css' &#125;, &#123; test: /\\.scss$/, loader: 'style!css!sass'&#125;, // =&gt; 透過 css-laoder 不只處理編譯好的 css, imports 同時包含 url(...) // &#123; test: /\\.css$/, loader: 'raw!sass' &#125;, // =&gt; 回傳編譯好的 css 程式碼單純只解析 imports 但不處理 url(...) &#123; test: /\\.(png|jpg)$/, loader: 'url?limit=8192' &#125; // 當檔案小於 8K 的時候會產生 base64 格式的 dataURI 超過的話則直接帶連結 ] &#125;, resolve: &#123; extensions: ['', '.js', '.json', '.coffee', '.scss', '.css'] &#125;, plugins: [definePlugin],&#125; 設好之後，接著我們就可以透過 &lt;script src=&quot;build/Profile.bundle.js&quot;&gt;&lt;/script&gt; 針對個別頁面載入 8. 優化通用的程式碼假設上面的 Feed 和 Profile 有很多通用的部分(比如說 React 元件和通用的樣式)webpack 會分析他們哪些是共用的部分，如此一來共享的部分就會直接被快取，不用再重新載入一次。透過使用 new webpack.optimize.CommonsChunkPlugin 如下 123456789101112131415161718192021222324252627282930313233343536373839// File: webpack.config.jsvar webpack = require(\"webpack\");var definePlugin = new webpack.DefinePlugin(&#123; __DEV__: JSON.stringify(JSON.parse(process.env.BUILD_DEV || 'true')), __PRERELEASE__: JSON.stringify(JSON.parse(process.env.BUILD_PRERELEASE || 'false'))&#125;);var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');// =&gt; 注意到這邊的參數會轉換成檔名輸出所以請記得加副檔名module.exports = &#123; entry: &#123; Main: './main.js', Profile: './profile.js', Feed: './feed.js' &#125;, output: &#123; path: './build', // publicPath: 'http://andyyou.github.io/', // 圖片等需要路徑引用的資源檔加上網址或路徑 publicPath: '/build/', // 因為有設定目錄，所以記得要補路徑，否則 require() 會取錯路徑 // 注意: 尾巴的 / 要記得加否則會產出類似 http://andyyou.github.io600e2b78b83128cc2be868b3971d0999.jpg 的路徑 filename: '[name].bundle.js' &#125;, module: &#123; loaders: [ &#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader'&#125;, &#123; test: /\\.css$/, loader: 'style!css' &#125;, &#123; test: /\\.scss$/, loader: 'style!css!sass'&#125;, // =&gt; 透過 css-laoder 不只處理編譯好的 css, imports 同時包含 url(...) // &#123; test: /\\.css$/, loader: 'raw!sass' &#125;, // =&gt; 回傳編譯好的 css 程式碼單純只解析 imports 但不處理 url(...) &#123; test: /\\.(png|jpg)$/, loader: 'url?limit=8192' &#125; // 當檔案小於 8K 的時候會產生 base64 格式的 dataURI 超過的話則直接帶連結 ] &#125;, resolve: &#123; extensions: ['', '.js', '.json', '.coffee', '.scss', '.css'] &#125;, plugins: [definePlugin, commonsPlugin],&#125; 事實上 webpack 檢查的就只是重複 require 的部分，當多個 entrypoint 都有使用到某個模組，就可以透過上面的方式提出。如此一來在 html 則要加入 &lt;script src=&quot;build/common.js&quot;&gt; 否則會爆。這麼做就可以享受瀏覽器為我們快取檔案的優點。 9. 非同步載入CommonJS 標準屬於同步的處理方式但是 webpack 提供了一種方式來達到非同步處理相依性載入這通常對於 client 端有使用路由的狀況非常實用，假設您透過路由來取得的每個頁面，但是您不希望直接就下載所有程式碼直到程式運行真的需要該部分程式碼的時候才下載。這個時候我們就可以使用 require.ensure() 的方式來載入模組 下面是範例的程式碼，ensure 的第一個參數是相依的模組，類似於 RequireJS 的 define() 12345678910111213if (window.location.pathname === '/feed') &#123; showLoadingState(); require.ensure([], function() &#123; hideLoadingState(); require('./feed').show(); // 當這個函式被呼叫，模組保證被同步載入可以使用 &#125;);&#125; else if (window.location.pathname === '/profile') &#123; showLoadingState(); require.ensure([], function() &#123; hideLoadingState(); require('./profile').show(); &#125;);&#125; webpack 會幫您處理剩下的事情，產生因為非同步設定而需要額外 chunk 檔案有點難懂，沒關係我們現在先新增另外一個模組 benz.js 1module.exports = \"It's from module Benz\"; 然後在我們的 main.js 放入 123456if (window.location.pathname === '/profile.html') &#123; require.ensure([], function () &#123; console.log(require(\"./benz\")); document.write(require(\"./benz\")); &#125;)&#125; 編譯之後會看到如下圖，官方文件提到的 chunk 實際上就是 webpack 處理過後依照需求區分的程式碼片段 webpack-dev-serverwebpack-dev-server 是一個小型的 node.js Express 伺服器，其使用 webpack-dev-middleware 來取得 webpack 封裝的結果。在運行時也有使用 socket.io 使其可以即時發送編譯後的資訊到客戶端同時這個開發伺服器也可以根據不同需求使用不同的模式，假設我們採用下面這組設定檔 12345678910module.exports = &#123; entry: &#123; app: [\"./app/main.js\"] &#125;, output: &#123; path: './build', publicPath: \"/assets/\", filename: \"bundle.js\" &#125;&#125; 上面這組設定的意思您現在應該很請楚了，即我們有一隻進入點的程式(檔案)在 app/main.js ，webpack 將會打包 entrypoint 成 bundle.js 檔案到 bundle 目錄。同時我們也回顧一下光 entry 的設定就多種組合 1234567891011121314module.exports = &#123; // 1 entry: &#123; app: [\"./app/main.js\"] &#125;, // 2 entry: \"./app/main.js\", // 3 entry: &#123; app: \"./app/main.js\" &#125;, // 4 entry: [\"./a.js\", \"./b.js\"],&#125; 如果使用陣列的方式設定，所有的模組會在啟動時被載入，而最後一個檔案會被匯出。另外注意到如果適用第四種方式然後在 output 也使用了 [name] 那這個 name 預設是 main而想要多個 entrypoint 檔案的話則透過物件的格式，webpack 就會產生多個 entrypoint bundle。 預設一般模式(Inline mode)剛剛我們提到 webpack-dev-server 有不同的模式，現在我們就來瞭解一下其中一個 inline 模式。一般情況下 webpack-dev-server 會處理當前目錄的檔案(就是你下指令時的那個目錄)，除非您有指定 content-base 1$ webpack-dev-server --content-base build/ 使用了這個設定，webpack-dev-server 就會處理你指定的那個目錄，預設 webpack-dev-server 就會自動監視該目錄下的檔案，當發生改變就會自動重新編譯。不過這些編譯只會放到記憶體並和 publicPath 的路徑關聯，而不會產生實體檔案。當 bundle 已經存在在相同路徑時也就是已經產生檔案，記憶體中的會優先使用。舉上面一開始的設定檔為例，這個 bundle 封裝結果可以透過 localhost:8080/assets/bundle.js 存取 為了測試這個結果我們需要建立一個 html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 當啟動 webpack-dev-server 之後，預設我們就可以透過 localhost:8080 來存取網站，而上面的設定檔加上了 publicPath 所以結果網址會是 localhost:8080/assets/ 即時更新模式(Hot mode)透過把專用的 script 加到 index.html，您的專案就會得到 live reload 的功能。 12345678910111213&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- It is important that you point to the full url --&gt; &lt;script src=\"http://localhost:8080/webpack-dev-server.js\"&gt;&lt;/script&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 對了，這個功能當然也需要修改一點點設定 123456789module.exports = &#123; entry: &#123; app: [\"webpack/hot/dev-server\", \"./app/main.js\"] &#125;, output: &#123; path: \"./build\", filename: \"bundle.js\" &#125;&#125;; 然後執行指令時要加入 --hot 參數 1$ webpack-dev-server --content-base build/ --hot 即時更新模式 + 訊息顯示當您啟動了 webpack-dev-server 您也可以瀏覽 localhost:8080/webpack-dev-server/ 透過這個連結您不只會看到您的內容，同時上方會有一些訊息提示。並且如果您採用這個連結，檔案並不需要加入剛剛那支特殊的 webpack-dev-server script所以一般建議的開發流程我們的 html 不用特地加入 script 然後使用 localhost:8080/webpack-dev-server/ 來觀察其結果。 因為 index.html 大多數的時候不會需要靠 webpack 編譯(除非您改用 jade 或 slim)，所以當然不會被列在 watch 的檔案中。 webpack-dev-server 指令與參數一般來說所有的 webpack 參數同等於 webpack-dev-server 參數，不過 output 除外。當然您也可以透過 --config 來指定設定檔。下面是一些額外的參數 --content-base: 指定專案目錄 --quiet: 不要輸出任何資訊到 console --colors: 彩色的輸出資訊 --no-info: 去除一些不太必要的資訊 --host: 設定 hostname 或 IP --port &lt;number&gt;: 設定 port --inline: 內嵌一個 webpack-dev-server 到封裝裡 --hot: 加入 HotModuleReplacementPlugin 並切換到即時更新模式 hot mode ，注意不能加入該 plugins 兩次 --https: 啟用 https 協定 上面這些參數都可以加入 webpack.config.js 123456789module.exports = &#123; // ... webpack.config.js stuff ... devServer: &#123; contentBase: \"./build\", noInfo: true, // --no-info option hot: true, inline: true &#125;&#125; 深入 loaders何謂 loaders ?loaders 就是轉換工具，用來把資源檔也就是我們的 js, css 等等這些模組轉換套用到程式上。它們是 node.js 中執行的函式，將資源檔當作參數取得其中的程式碼，轉換並傳回新的程式碼。舉例來說您可以使用 loaders 來告訴 webpack 如何處理並載入 CoffeeScript 或 JSX 功能 loader 可以被串連使用，即把一個資源檔從 A loader 交付給 B loader。講的太難懂，那我們先舉個在 Linux 底下所謂的 pipeline 的例子 ls | grep filename 在 Linux 底下我們可以透過 | 來做 pipeline，其行為就是先執行 ls 指令再把 ls 處理完的結果交給下一個指令。在上面的例子中 require(&quot;!style!css!./style.css&quot;); 就是一樣的意思把 style.css 交給 css-loader 先處理，處理完的結果再交給 style-loader。最終 loader 被預期傳回 Javascript，其他過程中的 loader 則可以傳回任意格式。 loader 可以套用同步或者非同步的行為 loader 運行在 node.js 環境中，且應該可以做到任何您想要的功能 loader 允許加入參數，其格式就像 HTTP 的 querystring 一樣，所以我們可以在設定檔或指令中帶入參數 loader 可以針對副檔名或正規表示式來設定要處理的檔案 loader 可以透過 npm 來發佈或安裝 除了正常 package.json 的 main，一般模組就我們在寫 JS 的 module.exports 也可以匯出 loader loader 可以存取設定檔 擴充套件可以賦予 loader 更多功能 loader 可以散播額外的任意檔案 其他 如果您對其他 loader 範例有興趣可以參考列表 解析 loaderloader 被解析的方式類似於模組。一個 loader 模組一般來說會需要輸出一個 function，且與 node.js 相容的 Javascript。在大部份的情況下我們透過 npm 來管理 loader不過您也可以將 loader 當作程式中的檔案來處理 參考(匯入) loader雖然這不是強制的，但依照慣例 loader 通常命名微 xxx-loader，而 xxx 就是其功能與描述的名稱也是我們在 pipeline 使用的名稱。例如 json-loader您也許會用完整名稱來引用該 loader(json-loader) 或者透過縮寫即 json關於 loader 命名慣例和搜尋的優先順序被定義在 webpack 設定檔的 resolveLoader.moduleTemplates 安裝如果 loader 存在，通常我們會直接透過 npm 安裝 12$ npm install xxx-loader --save$ npm install xxx-loader --save-dev 使用方式在您的專案中可以使用不同的方式來使用 loader 明確的寫在 require 中 在設定檔指定 直接透過指令參數設定 明確的寫在 require 中注意: 盡量避免使用這種方式，而採用設定檔的慣例來設定 loader這種方式是透過在 require 語句(或者 define, require.ensure) 中指定會採用的 loaders。透過 ! 將 loader 區隔。此時會相對於當前目錄去解析路徑 12345678require(\"./loader!./dir/file.txt\");// =&gt; 使用在該目錄下的 loader.js 檔案來轉換 dir/file.txt 檔案require(\"jade!./template.jade\");// =&gt; 使用 jade-loader (npm 安裝的模組) 來轉換 template.jaderequire(\"!style!css!less!bootstrap/less/bootstrap.less\");// =&gt; 將 bootstrap/less/bootstrap.less 檔案透過 less-loader 先轉換成 css 再將結果傳給 css-loader 最後傳給 style-loader 在設定檔中指定您也可以透過正規表示式 RegExp 來設定123456789101112&#123; module: &#123; loaders: [ &#123; test: /\\.jade$/, loader: \"jade\" &#125;, // =&gt; jade loader 被用來處理 .jade 檔案 &#123; test: /\\.css$/, loader: \"style!css\" &#125;, // =&gt; style-loader 和 css-loader 被用來處理 .css 檔案 // =&gt; 下面是等價另一種格式的寫法 &#123; test: /\\.css$/, loader: [\"style\", \"css\"] &#125;, ] &#125;&#125; 指令當然您也可以透過指令參數來設定對應的 loaders 1$ webpack --module-bind jade --module-bind 'css=style!css' 上面的指令會讓 jade-loader 對應處理 .jade 檔案，然後 style-loader 和 css-loader 針對 css 檔案 loader 參數(Query parameters)loader 可以透過在設定傳入參數，格式類似網址的 query string。這個參數只要在該 loader 後面加上 ? 舉例來說 url-loader?mimetype=image/png 注意: 至於 query string 的格式則是由 loader 來決定。通常會在該 loader 的文件上說明。大部份的 loader 參數的格式會是 ?key=value&amp;hey=hi 或者 ?{&quot;key&quot;: &quot;value&quot;, &quot;key2&quot;: &quot;value2&quot;}整個設定寫起來會如下 1require(\"url-loader?mimetype=image/png!./file.png\"); 用在設定檔中 1&#123; test: /\\.png$/, loader: \"url-loader?mimetype=image/png\" &#125; 或者 12345&#123; test: /\\.png$/, loader: \"url-loader\", query: &#123; mimetype: \"image/png\" &#125;&#125; 使用擴充套件擴充套件就是文件上說的 plugins，它是透過 webpack.config.js 的 plugins 屬性來載入模組之中，如下面設定 123456789var webpack = require(\"webpack\");module.exports = &#123; plugins: [ new webpack.ResolverPlugin([ new webpack.ResolverPlugin.DirectoryDescriptionFilePlugin(\"bower.json\", [\"main\"]) ], [\"normal\", \"loader\"]) ]&#125;; 其他擴充套件如果不是內建的 plugins 則通常需要透過 npm 來安裝，裝完之後照下面這樣使用即可 123456var ComponentPlugin = require(\"component-webpack-plugin\");module.exports = &#123; plugins: [ new ComponentPlugin() ]&#125; 總結經過一輪練習之後，如果您要使用 webpack-dev-server 在設定上路徑會是比較需要注意的地方，然後就是記得 webpack-dev-server 的輸出會放在記憶體。雖然現在官方文件比較沒有詳細的範例，不過您還是可以找到其他。希望在這篇之後各位能夠對這個起手式有些認識也應該都具有使用 webpack 的基礎能力。 示範多檔編譯Webpack + React 中文Webpack with Railsreact-hot-loader深入了解 webpack plugins","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"//andyyou.github.io/tags/webpack/"},{"name":"bundler","slug":"bundler","permalink":"//andyyou.github.io/tags/bundler/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"Javascript Unicode","slug":"js-unicode-issue","date":"2015-05-21T04:50:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/05/21/js-unicode-issue/","link":"","permalink":"//andyyou.github.io/2015/05/21/js-unicode-issue/","excerpt":"為了理解 ES6 到底對於 Unicode 萬國碼有哪些新的支援。我們得從原因理解起。","text":"為了理解 ES6 到底對於 Unicode 萬國碼有哪些新的支援。我們得從原因理解起。 Javascript 在處理 Unicode 時很有多問題關於 Javascript 處理 Unicode 的方式…至少可以說是很奇怪。這篇文章闡述在 Javascript 中存取 Unicode 的痛點以及 ES6 如何改善這個問題。 Unicode 基礎在我們深入探討 Javascript 之前，讓我們先確認當我們談到 Unicode 的時候說的是相同的事情。 有關 Unicode 的觀念其實非常簡單，把它想成一個資料庫，存取著您能想到的所有文字符號，且每一個文字符號都對應著一組數字。這個數字就叫編碼位置(Code point)，也有人稱碼點 代碼點。這個編碼位置是唯一的。透過這種方式可以簡單的存取特定文字符號而不用直接輸入符號本身。 例如: A = U+0041 a = U+0061 © = U+00A9 ☃ = U+2603 💩 = U+1F4A9 編碼位置通常使用 16 進制的格式，位元左邊捕 0 到至少 4 位，使用 U+ 當作前綴字。編碼可能的範圍從 U+0000 到 U+10FFFF 超過 110 萬個符號。為了確保其組織性，Unicode 把這個範圍的編碼區分成 17 個區段，各自由 65536 個編碼組成。如果你曾經看過 Wiki 百科上的翻譯，他翻成平面，由 17 個平面組成。 第一個平面稱作基本多文種平面 Basic Multilingual Plane, 簡稱BMP。這大概是最重要的一個。它包含了大部份常用的字符。一般使用英文的情況下您不會需要 BMP 以外的編碼來編輯文件。 BMP 以外剩下大概 1 百萬個符號屬於補充平面(Supplementary planes or Astral planes)補充平面的字非常好辨別: 如果某個字符需要超過 4 位元的 16 進制來表示那它就屬於補充平面。 現在我們有了對 Unicode 的基本認識了。來看看如何應用到 Javascript 的字串。 跳脫序列(Escape sequence)12345console.log('\\x41\\x42\\x43');// 'ABC'console.log('\\x61\\x62\\x63');// 'abc' 這個東西術語叫做 16 進制的跳脫序列(字元)。由 16 進制格式的 2 個位元組成代表一個編碼位置。舉例來說 \\x41 代表 U+0041。跳脫序列可以被用來表示編碼位置從 U+0000 到 U+00FF。 另外一種常見的跳脫序列的表示類型如下 12345console.log('\\u0041\\u0042\\u0043');// 'ABC'console.log('I \\u2661 JavaScript');// 'I ♡ JavaScript' 這種格式被稱作萬國碼跳脫序列，算了！還是記英文吧！Unicode escape squences 由16 進制格式 4 個位元組成精準的表達編碼位置，舉例來說: \\u2661 表示 U+2661 這種跳脫序列可以用來表示 U+0000 到 U+FFFF 範圍的萬國碼 Unicode 等於是整個基本多文種平面(BMP) 那麼..其他平面呢? 我們需要大於 4 位元來表示其他編碼位置啊! 我們要如何使用跳脫序列呈現它們? ES6 引進了新類型的跳脫序列: Unicode code point escapes 讓事情變得比較簡單 舉例來說: 12345console.log('\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;');// 'ABC'console.log('\\u&#123;1F4A9&#125;');// '💩' U+1F4A9 在大括號之間您可以使用 6 位元的 16 進制，這麼一來就足夠表示所有的 Unicode 編碼。所以透過這種類型的跳脫序列您可以輕易的輸出任何您想用的符號 為了兼容 ES5 和舊有的環境，一個不是很好的解決方案出現了，就是使用成對編碼來代理 12console.log('\\uD83D\\uDCA9');// '💩' U+1F4A9 在這種情況下每一個跳脫字元(跳脫序列)代表一半的編碼位置，2 個代理編碼組成一個字符的 Code point。 注意到這個編碼沒辦法很直覺的看出其規則，這是有一套公式的 例如一個 C 字符大於 0xFFFF 就得對應到 &lt;H, L&gt; 成對的代理編碼 12H = Math.floor((C - 0x10000) / 0x400) + 0xD800L = (C - 0x10000) % 0x400 + 0xDC00 之後我們提到代理編碼指的就是兩個編碼其中之一 第一個的是 H, 第二個是 L 要反轉回來則是 1C = (H - 0xD800) * 0x400 + L - 0xDC00 + 0x10000 透過這種代理編碼的機制所有補充平面的編碼位置(U+010000 - U+10FFFF) 都可以使用。不過使用單一跳脫字元來表示 BMP 裡面的字，兩個跳脫字元(代理編碼)來處理剩下補充平面的字很容易讓人搞混，造成很多惱人的後果。 計算 JavaScript 字串的文字(符號)假設您想計算一個字串的文字有幾個，您會怎麼處理呢? 直覺的想法大概是使用 length 12345console.log('A'.length);// 1console.log('A' == '\\u0041');// true 上面這個例子 length 剛好是字元的數量，說有 1 個文字這很合理。很顯然的我們每一個文字只需要一個跳脫字元，但實際上卻不是這樣。例如: 1234567891011121314151617console.log('𝐀'.length); // U+1D400 注意這不只是全形Ａ// 2console.log('𝐀' == '\\uD835\\uDC00');// trueconsole.log('𝐁'.length) // U+1D401// 2console.log('𝐁' == '\\uD835\\uDC01');// trueconsole.log('💩'.length);// 2console.log('💩' == '\\uD83D\\uDCA9');// true 在內部 JavaScript 把補充平面的字符視為兩個跳脫字元(代理編碼)表示一個字。如果您在 ES5 兼容的瀏覽器輸出您會看到他把他視為兩個跳脫字元 length 為 2 ，人們對於字面上只顯示一個字但是 length 卻為 2 會產生困惑。 計算補充平面裡的文字回到剛剛的問題，那我們如何計算 JS 字串中有幾個字?這個小技巧針對代理編碼做處理，當我們認出這兩個跳脫字元會組成一個字的時候只計算一次 12345var regexAstralSymbols = /[\\uD800-\\uD8FF][\\uDC00-\\uDCFF]/g;function countSymbols(string) &#123; return string.replace(regexAstralSymbols, '_').length;&#125; 或者您也可以使用 Punycode.js，punycode.ucs2.decode 方法可以取得一個字串並回傳一個包含 Unicode 編碼位置的陣列。如此一來您就可以計算幾個字了。 在 ES6 您可以透過 Array.from 做類似的事情，透過使用字串的 iterator 來切割字串成為一個陣列 1234var astral = Array.from(\"𝐀𝐁💩\");console.log(astral);console.log(astral.length);// 3 或者使用 ... 12console.log([...\"𝐀𝐁💩\"].length)// 3 使用上面提到的這些方法，我們可以解決計算幾個字的問題。 看起來一樣，但卻不一樣但是如果我們開始去賣弄我們從文章中學到的知識，計算文字的數量甚至更多複雜的操作例如下面這段程式碼 12console.log('mañana' == 'mañana');// false JavaScript 會告訴我們這兩個字串不一樣，但看起來明明就一樣。試著到這個網址看看 Javascript escapes 工具告訴我們其中的不同 12345678console.log('ma\\xF1ana' == 'man\\u0303ana');// falseconsole.log('ma\\xF1ana'.length);// 6console.log('man\\u0303ana'.length);// 7 第一個字串包含的是 U+00F1 是一個拉丁字小寫 N 加上波浪號。而第二個字串裡面的是 U+006E 拉丁字小寫 N 加上 U+0303 波浪號，兩個編碼合體成一個字。這樣你明白了為什麼他們不一樣了吧。 然而如果我們希望兩個字串計算結果都會是 6 個字呢?在 ES6 也相當直覺 123456var normalized = \"mañana\".normalize('NFC'); // 把字串標準化console.log(Array.from(normalized).length);// 6console.log([...normalized].length);// 6 這個標準化 normalize 方法是內建 String.prototype 的方法，他會根據Unicode normalization的規則執行，找出那些字的差異，如果找到那種由兩個代理編碼組成的字卻長得跟另一單一編碼位置一樣的字，它會把它轉成單一的那種編碼。 123456789[...'mañana'].lenght // U+00F1// 6[...'mañana'].length // U+006E + U+0303// 6// 透過程式碼驗證var normalized = \"mañana\".normalize('NFC');console.log(normalized[2] + \" = \" + normalized.charCodeAt(2))// ñ = 241, 241 轉成 16 進制 F1 為了向下相容 ES5 和舊環境可以使用這個Polyfill 事情還很複雜 - 計算其他組合式的代理編碼光上面這些還不夠完美，編碼位置可以有多種組合方式其結果看起來是一個字，但是卻沒有標準化的格式(或者說沒有相同樣子的字取代)。這種時後 normalization 就幫不上忙了。 大部份開發者應該很少遇到這類問題吧??? 12345678var q = 'q\\u0307\\u0323'.normalize('NFC') // q̣̇// 經過 normalize 還是 q\\u0307\\u0323console.log([...q].length);// 是 3 不是 1console.log([...'Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞'].length);// 是 74 不是 6 此時您可以使用正規式來移除那些組合的符號 1234567var sample = \"Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞\";var pattern = /([\\0-\\u02FF\\u0370-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uDC00-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF])([\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;var stripped = sample.replace(pattern, function(ele, symbol, marks) &#123; return symbol;&#125;);console.log(stripped.length);// 6 這種做法可以移除其他用來組合的符號，只留下那些我們要的字。這種解決方案甚至連 ES3 都能使用。 計算其他類型的字形集合(語素簇) Grapheme Cluster對於像 நி(U+0BA8 + U+0BBF = \\u0ba8\\u0bbf) 這種字集或者像韓文是由一堆母音和子音組成的例如 깍(ᄁ + ᅡ + ᆨ) 上面的邏輯仍然是相對粗糙。 Unicode 標準附件 #29 提供一個演算法用來判斷字形的邊界，就是怎麼樣算是人看的一個字。如果是為了給所有 Unicode 絕對精準的解決方案那麼時做這個邏輯可能是比較正解的方法。 反轉字串你可能覺得在 JavaScript 中反轉一個字串很簡單。對嗎?通常你會這麼做 123function reverse(string) &#123; return string.split('').reverse().join('');&#125; 看起似乎可行 12345reverse('abc');// 'cba'reverse('mañana'); // U+00F1// 'anañam' 然而當字串混雜著一些代理編碼即兩個編碼位置組合成的一個字或者補充字面裡的字時全部就都亂了套。 1234567reverse('mañana'); // U+006E + U+0303// 'anãnam'// 看吧！ `~` 跑到 `a` 上面了reverse('💩') // U+1F4A9// '��' =&gt; `'\\uDCA9\\uD83D'`// `💩` 大便符號完全錯誤因為兩個編碼位置反了 在 ES6 裡面修正了這個問題 1234console.log(Array.from(\"𝐀𝐁💩\").reverse().join(''));// \"💩𝐁𝐀\"console.log([...\"𝐀𝐁💩\"].reverse().join(''));// \"💩𝐁𝐀\" 但仍然沒有解決涉及多個編碼組合成看起來像一個字的問題。 幸運的是有人解決了反轉字串遇到怪字這個問題，只要透過Esrever 1234567// 使用 Esrever (https://mths.be/esrever)esrever.reverse('mañana') // U+006E + U+0303// 'anañam'esrever.reverse('💩') // U+1F4A9// '💩' U+1F4A9 在字串方法中使用 Unicode 的問題除了陣列 reverse() 的行為外，這種問題也影響到字串的方法。 轉換編碼位置成文字(符號)String.fromCharCode 讓我們可以用 Unicode 編碼位置來建立一個字串，不過呢只有在基本多文種平面(BMP)範圍內是正常的(U+0000 到 U+FFFF)，如果我們用了在補充平面的字將會得到非預期的結果: 12345String.fromCharCode(0x0041); // U+0041// 'A' U+0041String.fromCharCode(0x1F4A9) // U+1F4A9// '' 是 U+F4A9, 而不是 U+1F4A9 而解決方法就是用上面提到的公式自己計算，並且把拆開的兩個編碼當作參數帶入 12String.fromCharCode(0xD83D, 0xDCA9);// '💩' U+1F4A9 16 進制在 C語言、Shell、Python、Java語言及其他相近的語言使用字首「0x」，例如「0x5A3」。 而在HTML，十六進制可以用「x」，例如 &amp;#x0041; 會等於 「A」。 如果你不想要自己處理這些麻煩的計算您可以使用 Punycode.js 提供的工具 12punycode.ucs2.encode([0x1F4A9]);// '💩' U+1F4A9 除了上面這些方法，幸運的是 ES6 也引入了新的方法 String.fromCodePoint() 就可以直接用來轉換補充平面裡面的字了 12String.fromCodePoint(0x1F4A9);// '💩' U+1F4A9 同時呢為了向下相容舊環境您可以使用 Polyfill。 從字串中取出一個字如果您想用 String.prototype.charAt(index) 來擷取第一個字符，遇上大便符號💩這種代理編碼類型的字，這個方法只能夠抓出第一個編碼。 123'💩'.charAt(0) // U+1F4A9// '\\uD83D'// U+1F4A9 代理編碼的兩個編碼中第一個是 U+D83D 在 ES7 的建議中已經有提出 String.prototype.at(index) 來處理這個問題了。 12'💩'.at(0) // U+1F4A9// '💩' U+1F4A9 同樣的在 ES5 和舊環境中還是可以找到 Polyfill 來處理。 從字串取得字的編碼位置類似於上面的狀況，如果您使用 Strint.prototype.charCodeAt(index) 來檢索字串中第一個字的編碼位置，您一樣會取得代理編碼 2 個編碼中的第一個編碼(就是上面提到的 H) 123'💩'.charCodeAt(0);// 0xD83D// 瀏覽器會給 10 進制 55357 換算之後的確是 D83D 再一次感謝 ES6，一樣提供了 String.prototype.codePointAt(index) 方法來解決這個問題。 12'💩'.codePointAt(0)// 0x1F4A9 遍歷字串中的每個字假設您想要用迴圈遍歷(就是一個字一個字取出)一個字串，分別對每個字做點處理。 在 ES5 裡我們可能要先處理成陣列 123456789101112131415161718192021function getSymbols(string) &#123; var length = string.length; var index = -1; var output = []; var character; var charCode; while (++index &lt; length) &#123; character = string.charAt(index); charCode = character.charCodeAt(0); if (charCode &gt;= 0xD800 &amp;&amp; charCode &lt;= 0xD8FF) &#123; // 這邊我們假設不會出現那種只有一半的代理編碼 output.push(character + string.charAt(++index)); &#125; else &#123; output.push(character); &#125; &#125; return output;&#125;var symbols = getSymbols('💩');console.log(symbols); 不意外的 ES6 又出來拯救我們了，在 ES6 裡只要用 for...of 就可以準確的取出每一個字。 1234for (let symbol of '💩') &#123; console.log(symbol == '💩');&#125;// true 其他問題Unicode 的確影響了很多 String Method 的行為，包含我們在這裡沒提到的 substring, slice 所以實作時請小心。 Unicode 在正規式中的問題匹配代碼位置(Code Point)與 Unicode 標量值(Unicode Scalar Values). 句點在正規式中只會匹配一個字元即我們上面說的一個編碼(U+0041)，本來這都很合理，但因為 JavaScript 採用了代理編碼的機制，用了兩個實際的編碼組合成一個字。一旦我們要匹配補充平面的字時，永遠不會匹配成功。 12/foo.bar/.test('foo💩bar')// false 讓我們再想想…還有什麼正規式的寫法可以匹配 Unicode 字符 12console.log(/^[\\s\\S]$/.test('💩'));// false 還是 GG ，事實證明正規式要匹配一個 Unicode 編碼位置並不是那麼直覺。 12console.log(/[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/.test('💩'));// true 當然啦！在實際開發時我是絕對不想寫這些正規式，光寫就暈了更何況還要 debug。為了取得上面那堆正規式我們可以偷吃步使用 regenerate 函式庫。它可以很輕鬆地幫我們產出這些正規式 1regenerate().addRange(0x0, 0x10FFFF).toString() 這個正規式可以匹配基本多文種平面，補充平面的字，甚至只有一個代理編碼。 只寫一個代理編碼在技術上是可行的，但因為他們不會對應到任何實際的字，所以應該避免。Unicode 標量值(Unicode Scalar Values)指的是所有的編碼位置但扣掉那些代理編碼的編碼位置下面是如何產出符合 Unicode Scalar Values 規則的正規式 12345regenerate() .addRange(0x0, 0x10FFFF) // 所有 Unicode 編碼位置 .removeRange(0xD800, 0xDBFF) // 減去第一位的代理編碼 .removeRange(0xDC00, 0xDFFF) // 減去第二位的代理編碼 .toRegExp() regenerate 可以協助我們建立那些複雜的正規式，用相對語意化的方式讓我們比較好維護。 ES6 替正規式加入了 u 修飾符(flag) 就是在正規式尾巴那些用來設定比對方式的參數例如 /[\\w]/g g 全域比對 i 忽略大小寫 gi 全域比對 + 忽略大小寫 現在多了 u 讓正規式用 . 在匹配時可以正確的匹配到補充平面裡的字 12345/foo.bar/.test('foo💩bar');// false/foo.bar/u.test('foo💩bar');// true 注意: . 仍然不會匹配到換行字元，當設定了 u flag 之後在兼容環境中等於是使用下面的程式碼 12345678regenerate() .addRange(0x0, 0x10FFFF) .remove( 0x000A, // &lt;LF&gt; 0x000D, // &lt;CR&gt; 0x2028, // &lt;LS&gt; 0x2029, // &lt;PS&gt; ).toString(); 補充平面的範圍設定先想想這種狀況 /[a-c]/ 這樣寫可以比對 U+0061 到 U+0063 即 a 到 c 。那如果換成 /[💩-💫]/ 勒?理論上應該是要匹配 U+1F4A9 到 U+1F4AB。 但實際上卻是… 12console.log(/[💩-💫]/);// SyntaxError: invalid range in character class 原因是實際上這個正規式長成這樣 12var pattern = /[\\uD83D\\uDCA9-\\uD83D\\uDCAB]/;// SyntaxError: invalid range in character class 我們原本想要的是從 U+1F4A9 到 U+1F4AB 但現在正規式卻變成先來一個 \\uD830 然後從 \\uDCA9-\\uD83D 範圍就錯了。 ES6 的 u flag 和新版 Unicode 表示法又一次解決了我們的困難 1234567891011121314151617181920212223242526272829303132333435console.log(/[\\uD83D\\uDCA9-\\uD83D\\uDCAB]/u.test('\\uD83D\\uDCA9'));// true// 匹配 U+1F4A9console.log(/[\\u&#123;1F4A9&#125;-\\u&#123;1F4AB&#125;]/u.test('\\u&#123;1F4A9&#125;'));// true// 匹配 U+1F4A9console.log(/[💩-💫]/u.test('💩'));// true// 匹配 U+1F4A9console.log(/[\\uD83D\\uDCA9-\\uD83D\\uDCAB]/u.test('\\uD83D\\uDCAA'));// true// 匹配 U+1F4AAconsole.log(/[\\u&#123;1F4A9&#125;-\\u&#123;1F4AB&#125;]/u.test('\\u&#123;1F4AA&#125;'));// true// 匹配 U+1F4AAconsole.log(/[💩-💫]/u.test('💪'));// true// 匹配 U+1F4AAconsole.log(/[\\uD83D\\uDCA9-\\uD83D\\uDCAB]/u.test('\\uD83D\\uDCAB'));// true// 匹配 U+1F4ABconsole.log(/[\\u&#123;1F4A9&#125;-\\u&#123;1F4AB&#125;]/u.test('\\u&#123;1F4AB&#125;'));// true// 匹配 U+1F4ABconsole.log(/[💩-💫]/u.test('💫'));// true// 匹配 U+1F4AB 可惜的是這個方法不能兼容 ES5 和舊環境，如果您真的必須要兼容舊環境那麼您可能只能使用 regenerate, 或其他類似的函式庫 來產出那些正規式進行匹配了。 真實世界中的其他 Bug 及該如何避免看到了吧！Unicode 在 JavaScript 中奇怪的行為造成許多問題。許多開發者在處理字串時並沒有考慮到補充字面的問題(舉手; 我就是其一)，甚至包含知名的函式庫 Underscore.string 的 reverse 也沒有處理關於補充字面產生的問題。 畢竟處理這些問題的確很麻煩，而且好像沒必要??? 在測試中參一坨屎吧 XD無論您正在寫什麼樣功能的 JavaScript 試著在測試行為的字串中加入 💩 然後看看會不會炸掉。這有助於您發現 Unicode 的問題。 結論一般處理單一語系的開發者其實不太容易注意到這些問題。這也是在學習 Babel 的過程中為了理解為什麼要特別強調 Unicode 而做些研究寫的學習筆記。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"//andyyou.github.io/tags/es6/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"ES6 Generators 基礎","slug":"es6-generators","date":"2015-05-19T21:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/05/20/es6-generators/","link":"","permalink":"//andyyou.github.io/2015/05/20/es6-generators/","excerpt":"在 Javascript ES6 的新功能中，有一個新品種的 function 稱為 generator 這個名字有點奇怪，不過它的行為在第一次看到的時候似乎更加奇怪。這篇筆記目的在解釋關於 generator 基本的運作原理。","text":"在 Javascript ES6 的新功能中，有一個新品種的 function 稱為 generator 這個名字有點奇怪，不過它的行為在第一次看到的時候似乎更加奇怪。這篇筆記目的在解釋關於 generator 基本的運作原理。 執行到完成在我們談論關於 generator 時，第一件事情是對於標題下的 執行到完成， generator 是如何不同於普通函式。 不過您是否看懂上面這一小段，您一直都對於 function 有一個相當基本的認知那就是一旦函式開始執行，它就會一直執行到完成為止。 1234567891011121314setTimeout(function() &#123; console.log(\"Settimeout excuted\");&#125;, 1);function foo() &#123; for(var i=0; i&lt;1000; i++) &#123; console.log(i); &#125;&#125;foo();// 1 - 1000// Settimeout excuted// 即使只差 1ms 還是要等 foo 跑完。 這邊 for 迴圈如果數字再大一點那就需要點時間，至少大於 1ms，然後您就發現 setTimeout 明明說好是 1ms 後發動卻無法中斷 foo 所以 setTimeout 就被卡在 event-loop 等待直到輪到它為止。 那如果 foo() 可以被中斷呢? 不會破壞我們的程式嗎?那的確是個挑戰，當我們採取多執行緒來寫程式的時候，不過好佳在我們用 Javascript 所以我們不需要擔心那些，因為 Javascript 永遠是單執行緒，意思是在一個時間點永遠只有一個 function 或指令在執行。 注意: Web Worker 是讓你可以啟動另一個完全分離的執行緒，給一部分的 JS 在其中執行的機制，跟您主要的執行緒是平行的。不在我們的程式使用多執行並發是因為兩個執行緒只能透過非同步事件來互相溝通。雖然是兩個平行的執行緒一旦要溝通還是要遵守 event-loop 的規則，一次只有一個動作，且還是一旦執行就要執行到完成。 執行 - 暫停 - 執行透過 ES6 generator 我們可以有不同的函式，它可以在執行到一半暫停，然後再回復執行。讓其他程式可以在暫停這段期間先跑。 如果您曾經得讀過關於並發或者執行緒程式設計的文章，您也許看過 cooperative 這個術語，其基本的意思是一個進程(process)，在我們 JS 的範例是 function 會自己決定何時應該允許中斷暫停。因此可以和其他的程式碼協同合作。這個觀念的對比是 preemptive 指出一個進程可能會違反原本的設計而中斷。 ES6 generator function 在其並發行為裡是可以協同合作的。在 generator function 裡面您可以使用新的關鍵字 yield 來從內部暫停。沒有東西可以從外部暫停一個 generator ，必須要透過 yield 從內部暫停。 然而一旦 generator 用 yield 暫停了自己，它就不能靠自己回復。必須要有個外部的控制行為來使其回復執行。稍後會解釋該如何做。 所以基本上，一個 generator 函式可以被暫停，重啟，隨您高興開開關關幾次。事實上您可以用一個無限迴圈來搭配 generator ，在一般 JS 程式中出現無限迴圈通常是寫錯了，不過搭配 generator 卻是合理的而且有時候您的確就是想要這麼做。 更重要的是，這個暫停和重啟不只單單是控制 generator 的執行流程，而且還提供了兩種方式在執行過程中傳遞輸入和輸出的訊息 在一般函式中您可以傳入參數(Parameters)然後 return 一個結果。在 generator 您可以透過 yield 把資料丟出來，然後傳回其他資料再回復執行。 怎麼寫？這一小段讓我們來開始介紹關於這些新功能的語法(syntax) 首先是這個新的 generator function 的宣告 123function *foo() &#123; // ...&#125; 注意到 * 了嗎? 這個新語法看起來有點奇怪，在其他語言(C, Object-C)中看起來像是函式要回傳一個指標。不過不要搞混，這只是一個符號用來判斷這是一個特殊的函式 generator。 您可能看過其他文章使用 function* foo(){} 而不是 function *foo(){}，兩種宣告都正確。 generator function 大概就是一個普通的 function ，只是在內部多了一些新的語法可以使用。 而最主要的新玩具就是我們上面提到的 yield，直接來看點範例 1234function *foo() &#123; var a = 1 + (yield \"fooo\"); console.log(x);&#125; 當 generator 執行到 yield 時會暫停，這個時候會把右邊的 expression 把就是 fooo 字串送出來，當 generator 再次啟動的時候無論資料有沒有送進去 generator 就會取得另外一個 yield expression，把 1 + yield expression 計算的結果。 yield 的意思我喜歡用佔位的概念來形容，有點像 hook 的觀念。 剛剛我說的有點讓你混淆，讓我們再來釐清一次 yield 第一個功能是暫停，當函式走到 yield 的時候會先停止，然後把右邊的 expression 丟到外面。停一下！這個 expression 跟待會要接回來的資料沒有關係。把 yield 想成佔位符，意思是停在這邊等別人把值丟進來，同時在我停下來的時候也可以丟個東西出去。有點類似 HTTP 的運作概念，執行到 yield 的時候對外部發送個 request 然後等待外部把資料送回來。再停一下！什麼外部？就是 generator 的實體物件。他會負責把資料再丟回來。丟回來的時候記住就不會再被那個 “fooo” 混淆了， “fooo” 丟出去後就沒有他的事了。 這個例子太難懂? 讓我們看點更完整的基本用法 123456789101112function *gen() &#123; console.log('start'); var o = yield \"called\"; console.log(\"I am back and bring \" + o);&#125;var a = gen(); // 第一次呼叫時是返回一個 generator 物件var b = a.next(); // 開始執行，到 yield 時會暫停執行並返回，返回值是一個物件console.log(b.value); // 他的 value 屬性是 yield 右側的 expression 的執行結果console.log(b.done); // 是否完成var c = a.next(\"something from outside\"); // 帶個值回去console.log(c.done); // 完成a.next(); // 如果再呼叫 next()，就會拋出例外 現在您應該看懂了兩種溝通方式了吧 您可以在任何 expression 的位置單純使用 yield，將其置放在 expression/statement 之中，然後輸出的部分就會是 undefined。 一個片段程式碼產生一個值稱之為 expression，expression 類似語言中的片語，一個短句。 statement 則是一句完整的句子，在 JS 中用 ; 結束當作一個句子。 通常一個 statement 是獨立的，只會完成某項任務，不過如果它影響了整個程式例如: 異動了機器內部的狀態，或者影響後面的 statement，這些造成的改變我們就稱為 side effect (副作用) 12345678function foo(x) &#123; console.log(\"x: \" + x);&#125;function *bar() &#123; yield; // 只會暫停 foo(yield); // 暫停並等待傳入參數到 foo()&#125; Generator IteratorIterator 迭代器實際上是一種特殊的行為，也可以表示一個設計模式。這個行為指的是讓我們可以透過呼叫 next()在一個排序的集合中，特定時間點下一次只取得一個值。舉例來說我們在[1, 2, 3, 4, 5]這個陣列上使用 iterator。第一次呼叫 next() 時我們會取得 1，第二次 2 以此類推當所有元素值都被回傳過後，next() 將會回傳 null, false 或者其他通知我們已經跑完所有元素的訊號。 剛剛提到我們在外部用來控制 generator function 的那個實體物件就是 generator iterator ，聽起來好像挺複雜的不過讓我們來看看實際上的例子 12345678// 假設我們有一個 generator functionfunction *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5;&#125; 為了逐步從 *foo 這個 generator function 中取得 yield 傳出來的資料我們需要一個迭代器 1var it = foo(); // 再次強調，第一次呼叫 function 傳回一個迭代器 所以！！第一次像我們平常一樣呼叫 function 的時候並不會真的執行。 在我們的觀念裡這的確有點陌生。您可能也會好奇想知道為什麼不是用 var it = new foo() 因為剛剛不是說回傳一個 iterator 實體物件嗎? 好吧我真的不知道，等我知道了在告訴你。這邊暫時先不討論這個問題 XD 接著讓我們開始來使用 iterator 12var message = it.next();console.log(message); // #=&gt; &#123;value: 1, done: false&#125; 第一次迭代之後我們會拿到 yield 傳出來的資料。再次強調一遍不要把 yield 的觀念當作是 function ，把它分成兩次一次負責輸出，取得資料之後您可以修改操作然後再把您的值丟回去。留在 function yield 右邊的那個 expression 丟出來後就沒用了。不要被它干擾。 每一次我們呼叫 next() 都會取得一個物件這個物件有 value 和 done 兩個屬性。done 用來判斷迭代器是否執行完畢。 1234console.log( it.next() ); // &#123; value:2, done:false &#125;console.log( it.next() ); // &#123; value:3, done:false &#125;console.log( it.next() ); // &#123; value:4, done:false &#125;console.log( it.next() ); // &#123; value:5, done:false &#125; 執行到第五次我們發現 done 還是 false 那是因為技術上來說 generator 還沒有執行完成。yield 傳出資料了還在等待你傳回去繼續執行。所以我們仍然要呼叫最後一次。所以最後一次如下： 1console.log( it.next() ); // &#123; value:undefined, done:true &#125; 現在我們執行完全部的流程了但是我們最後一次並沒有拿到任何資料因為我們已經用盡了 yield ____ 在這個關鍵點，您也許想知道我可以從 generator 回傳值嗎？並且如果我這麼做那這個值會在 {value: , done: true} 這個物件的 value 嗎? 答案是 Yes 可以 12345678function *foo() &#123; yield 1; return 2;&#125;var it = foo();console.log( it.next() ); // &#123; value:1, done:false &#125;console.log( it.next() ); // &#123; value:2, done:true &#125; 等等…但也不可以 依賴 return 恐怕不是個好主意，因為當我們使用 for..of 的時候最後一個回傳的值會被捨棄 123456789101112function *foo() &#123; yield 1; yield 2; return 3;&#125;var it = foo();for(var i of it) &#123; console.log(\"使用 for of \" + i);&#125;// 使用 for of 1// 使用 for of 2 為了完整起見讓我們來看看完整的輸入和輸出是如何操作的 現在我要來回答您怎麼丟資料回去呢? 就是每個 next() 帶入的參數 12345678910111213141516171819202122function *foo(x) &#123; // you can use this to inspect // console.log(`x: $&#123;x&#125;, y: $&#123;y&#125;, z: $&#123;z&#125;`); var y = 2 * (yield (x + 1)); var z = yield (y / 3);; return (x + y + z);&#125;var it = foo(5); // 取得 iterator 物件，並不執行console.log( it.next() ); // &#123; value:6, done:false &#125;// 第一次呼叫 x: 5, y: undefined, z: undefined// 執行到 var y 那邊停住，傳出 yield(x+1) = 6console.log( it.next( 12 ) ); // &#123; value:8, done:false &#125;// 送 12 進去所以 y = 2 * 12 = 24，第二次呼叫 x:5, y: 24, z: undefined// 到 var z 那邊停住，輸出 8 等待輸入...console.log( it.next( 13 ) ); // &#123; value:42, done:true &#125;// 送 13 進去所以 z = 13 所以第三次呼叫 x: 5, y: 24, z: 13// 第三次完成並取得 return value 42 你可以看到我們仍然可以透過參數來初始化 x，第一次初始化並建立 iterator 順便讓 x 等於 5。 第一次 next() 我們沒有傳入任何值因為第一次還沒有任何 yield 在等你傳值進去。那如果我們傳值了呢? 沒什麼不行，因為這個值會被丟掉。ES6 表示 generator function 會忽略用不到的值。不過有些還沒完全實作 ES6 的瀏覽器可能會出錯。 yield (x + 1) 先往外丟出 6 ，然後等你第二次呼叫 next(12) 所以 y 會是 2 * 12 = 24 接著 yield (y / 3) 就是 yield (24 / 3) 丟出 8 一樣等你把 13 丟進去所以 z = 13 最後 return (x + y + z) 等於 42，看這邊可能會頭暈。多看幾次。 for..ofES6 也提供一種方便的迭代語法，for...of 123456789101112131415function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (var v of foo()) &#123; console.log( v );&#125;// 1 2 3 4 5console.log( v ); // still `5`, not `6` :( 如您所見，foo() 會先建立迭代器且 for..of 會自動去擷取它然後為您自動迭代取出每一個 yield express 吐回來的值。直到 done:true 出現。當 done 為 false 的時候他會自動擷取 value 屬性，注意不是物件。一旦 done: true 迴圈就停止，而且不會包含最後的 return 的值。 注意上面您可以看到 for..of 迴圈會忽略丟掉 return 6，而且因為沒有 next() 可以使用所以在這種情況下你就不能用 for..of 必須要自己操作。 結論OK! 現在您已經懂了 generator 的基本用法了。別擔心如果你現在有點混亂是正常的，我第一次看也是。很自然的您會想知道，這個新玩具可以在實際專案中做些什麼? 在您熟悉玩過上面這些範例程式碼之後您可能會問 如何把它用在錯誤處理方面? Generator 可以呼叫其他 Generator 嗎? 如何使用非同步的方式操作 Generator? 如果我有時間我會繼續翻譯系列文章 資源參考翻譯自The Basics Of ES6 Generators","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"//andyyou.github.io/tags/es6/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"IISExpress 使用 IP 連線","slug":"iisexpress-use-ip","date":"2015-05-13T21:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/05/14/iisexpress-use-ip/","link":"","permalink":"//andyyou.github.io/2015/05/14/iisexpress-use-ip/","excerpt":"這個需求是我在 OSX VM 底下用 Windows 開發 Web 時希望從 OSX 這邊或者給內網的其他使用者快速連到 Visual Studio 的 Development Server 而產生的。","text":"這個需求是我在 OSX VM 底下用 Windows 開發 Web 時希望從 OSX 這邊或者給內網的其他使用者快速連到 Visual Studio 的 Development Server 而產生的。因為 IIS Express 預設是綁定只能透過 localhost 網域名稱來連線，所以當您透過內網 IP 連線時會出現 HTTP Error 400. The request hostname is invalid. 錯誤。 此時只需要如下步驟設定，我們假設您 on 起來的 server port 是 9999 實際設定時請改成您的 port 號 用管理者權限使用指令1$ netsh http add urlacl url=http://*:9999/ user=\"NT AUTHORITY\\INTERACTIVE\" 修改 IISExpress 設定檔在 %USERPROFILE%\\Documents\\IISExpress\\config\\applicationhost.config 檔案中找到對應網站的設定，把這個屬性換成如下 bindingInformation=&quot;*:9999:*&quot; 123456&lt;site name=\"...\" id=\"...\"&gt; &lt;!-- application settings omitted for brevity --&gt; &lt;bindings&gt; &lt;binding protocol=\"http\" bindingInformation=\"*:5555:*\" /&gt; &lt;/bindings&gt;&lt;/site&gt; 搞定！！","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"windows","slug":"windows","permalink":"//andyyou.github.io/tags/windows/"},{"name":"iisexpress","slug":"iisexpress","permalink":"//andyyou.github.io/tags/iisexpress/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"XML 筆記","slug":"web-services","date":"2015-05-13T21:10:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/05/14/web-services/","link":"","permalink":"//andyyou.github.io/2015/05/14/web-services/","excerpt":"XML先從 XML 說起，XML 被設計用來描述資料。XML 看起來就像是 HTML，但他不是用來取代 HTML 的，HTML 設計的目的是用來呈現資料，而 XML 是紀錄資料。XML 本身並不會完成任何事情，他就是一種資料的紀錄結構","text":"XML先從 XML 說起，XML 被設計用來描述資料。XML 看起來就像是 HTML，但他不是用來取代 HTML 的，HTML 設計的目的是用來呈現資料，而 XML 是紀錄資料。XML 本身並不會完成任何事情，他就是一種資料的紀錄結構 123456&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; XML 不像 HTML 預先定義好所有標籤，在 XML 中標籤是由開發者定義的。XML 是一種簡單的資料分享格式。在真實世界中，電腦系統和資料庫儲存的資料使用不同的格式，彼此不相容。而 XML 透過純文字的格式儲存，提供一種跟不相依於任何軟硬體的方式儲存資料。 XML 從根節點出發，一份 XML 文件只會有一個 root一個標準的 XML 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; 每一個元素一定都要關閉，且元素名稱區分大小寫巢狀時一定要符合規則，屬性一定要用 &quot; 包起來。 一些特殊字元會有不一樣的意義，所以不能亂用這些字元共有 5 個 &lt; &gt; &amp; &#39; &quot; 但其中只有 &lt; 和 &amp; 是嚴格說起來被限制的。空白會保留不會跟 HTML 一樣標籤中連續多個空白會被縮到剩一個 註解 &lt;!----&gt; 元素的命名規則 區分大小寫 開頭必須要是英文或底線 不可以用 XML Xml 開頭 雖然可以用 英文，數字 -, _, . 但是 - 在某些系統會被當成減號，.則會當成連接屬性和物件的符號 名稱不能包含空白 可以用各種語言的字元，但要考慮系統是否支援 雖然沒有規則限制屬性和子元素該怎麼用，不過大原則是：屬性是用來放跟資料本身沒直接關係卻跟標籤元素有關係的資訊，例如 id 設計時的原則是只要資料有機會擴展就用子元素，因為屬性只能單純的放文字 namespace 提供一種方式避免元素衝突，透過 xmlns:ns=&quot;namespace URI&quot; 來定義，定義在起始的標籤。namespace 的 uri 並不會用來解析資訊，目的只是要給 namespace 定義一個唯一的名稱 三組 namespace 的放法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;root&gt;&lt;!--有設定 prefix 就要用 --&gt;&lt;h:table xmlns:h=\"http://www.w3.org/TR/html4/\"&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt;&lt;f:table xmlns:f=\"http://www.w3schools.com/furniture\"&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt;&lt;/root&gt;&lt;!--集中在 root 定義--&gt;&lt;root xmlns:h=\"http://www.w3.org/TR/html4/\"xmlns:f=\"http://www.w3schools.com/furniture\"&gt;&lt;h:table&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt;&lt;f:table&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt;&lt;/root&gt;&lt;!--直接在開始的標籤設定，但不用 prefix --&gt;&lt;table xmlns=\"http://www.w3.org/TR/html4/\"&gt; &lt;tr&gt; &lt;td&gt;Apples&lt;/td&gt; &lt;td&gt;Bananas&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;table xmlns=\"http://www.w3schools.com/furniture\"&gt; &lt;name&gt;African Coffee Table&lt;/name&gt; &lt;width&gt;80&lt;/width&gt; &lt;length&gt;120&lt;/length&gt;&lt;/table&gt; 因為 XML 支援不同的國際編碼，所以在一開始定義時要指定 encoding XML 的第一行定義又稱 prolog 這是可選的，通常會在這邊定義版本和編碼。預設是 UTF-8，XML 有提供 XML Validator 來驗證格式是否正確。一個通過驗證的 XML 跟格式正確的 XML 文件並不完全相同一個通過癌症的 XML 是格式正確加上符合文件類型定義的 XML 文件我們會用 Document Type Definitions(DTD)或者 XML Schemas 來替 XML 定義何謂合法的元素與屬性的規則。 驗證 XML 的文件格式分成兩種類型 DTD - 原生的文件類型定義 XML Schema - 一種 XML 格式的文件用來替代 DTD DTD文件型別定義(Document Type Definition)，DTD 的功能就是定義該類型文件所包含的元素(Element)，並定義每個元素的內容，包含子元素、文字內容與屬性規範各元素(Element)的排列組合方式，包含出現的順序與可出現的次數。順序性與重複性。 如果在 XML 裡面宣告 DTD 123456789101112131415161718&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt;&lt;!--引用外部 dtd--&gt;&lt;!DOCTYPE note SYSTEM \"http://mydtds.com/note.dtd\"&gt; 上面的 DTD 解釋如下 &lt;!DOCTYPE note 宣告這個 XML root 是 note 接著跟在 note 後面用陣列 [] 圈起來 &lt;!ELEMENT note (to, form, heading, body)&gt; 宣告 note 至少要有這些東西，一個 () 是一個表示式 &lt;!ELEMENT br EMPTY&gt; 定義 br 元素為空的 &lt;!ELEMENT span ANY&gt; 定義 span 為任意元素 &lt;!ELEMENT to (#PCDATA)&gt; 可被解析的文字資料 &lt;!ELEMENT div (foo+)&gt; 定義 div 裡面至少要有一個 foo 或多個 一個或多哥 零或多 ? 零或一 簡單介紹完 DTD 結論就是這會用在一種情況當開發者分別處於不同團隊或公司要互相交換分享資料時用來確保雙方給的 XML 是否正確。因為 W3C 明確的定義當解析 XML 出現異常時必須終止，不能像 HTML 一樣容錯。 XML Schema一個 XML Schema 描述一個 XML 的結構功能就像 DTD 一樣一個 XML 符合基本結構規範稱為 Well formed一個 XML 針對 XML Schema 規則檢查後才能保證是 Well Formed 和 Valid XML Schema 使用 XML 的格式實作 DTD 的功能 12345678910&lt;xs:element name=\"note\"&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=\"to\" type=\"xs:string\" /&gt; &lt;xs:element name=\"from\" type=\"xs:string\" /&gt; &lt;xs:element name=\"heading\" type=\"xs:string\" /&gt; &lt;xs:element name=\"body\" type=\"xs:string\" /&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 上面這段 XML Schema 解釋 &lt;xs:element name=&quot;note&quot;&gt; 定義一個叫做 note 的元素 &lt;xs:complexType&gt; 在 note 裡面定義 note 是一個複雜型別 &lt;xs:sequence&gt; 設定這個 complexType 是一個元素序列 &lt;xs:element name=&quot;to&quot; type=&quot;xs:string&quot;&gt; 定義元素序列裡面有一個 to 元素型別是字串 XML Schema 比起 DTD 功能更強大，可以用 XML 語法結構定義比較清楚，支援型別限制也支援 namespace透過 XML Schema 可以對 XML 檔案附加其他描述的資訊同時可以驗證資料。 因為 XML Schema 也是一種 XML 所以也可以使用 XSLT XMLHttpRequest ObjectXMLHttpRequest 物件被用來和伺服器交換資料您可以透過 XMLHttpRequest 執行 更新網頁而不需要重新載入整個頁面 在頁面載入完成後對伺服器請求資料 從伺服器取得其他資料 在背後送資料給伺服器 如何建立一個 XMLHttpRequest 物件所有新的瀏覽器都支援此物件 1var xmlhttp = new XMLHttpRequest(); XML Parser所有新的瀏覽器都支援一個內建的 XML 解析器XML parser 可以轉換一個 XML 文件檔案成為一個 XML DOM 物件，意思是之後可以透過 JS 操作下面的簡易程式碼示範如何轉換 123456789101112131415xmlhttp = new XMLHttpRequest();xmlhttp.open(\"GET\", \"books.xml\", false); //open(method,url,async)xmlhttp.send();xmlDoc = xmlhttp.responseXML;txt = \"&lt;bookstore&gt;&lt;book&gt;&lt;title&gt;Hello Italian&lt;/title&gt;&lt;author&gt;ANDY&lt;/author&gt;&lt;/book&gt;&lt;/bookstore&gt;\";if (window.DOMParser) &#123; parser = new DOMParser(); xmlDoc = parser.parserFromString(txt, \"text/xml\");&#125; else &#123; xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\"); xmlDoc.async = false; xmlDoc.loadXML(txt);&#125; XPathXPath 是一種用來找到 XML 資訊的語法XPath 是根據 XML 需求而定義的局部語法XPath 使用路徑表示式來搜尋 XML 中的資訊XPath 包含著一組標準的函式庫XPath 是 XSLT 的主要元素之一XPath 也可以用在 XQuery XPointer 和 XLink XPath 使用路徑表示式來選取某個 XML 中的節點 Node 或符合規則的節點集合。這個表示式跟我們在電腦系統上面找檔案的路徑格式非常相似。目前 XPath 表示式可以被用在 Javascript, Java, XML Schema, PHP, Python, C, C++ 等等 XPaht 是 XSL 標準中的主要內容之一，如果沒有 XPath XSL 將無法建立 XSLT XPath 表達式 bookstore/book[1] 從 bookstore 子元素中選取第一個 book 元素，注意從 1 開始而不是 0 /bookstore/book[last()] 選最後一個 /bookstore/book[last()-1] 倒數第 2 個 /bookstore/book[position() &lt; 3] 前兩個 //title[@lang] 相對路徑比對到 title 標籤且有 attribute 名稱是 lang 的。注意在 [] 裡面通常指的是子元素的規則，加上 @ 就是元素本身的 attributes XLinkXLink 定義一種方式讓我們可以在 XML 文件中建立連結XLink 被用來在 XML 中建立超連結任何在 XML 中的元素都可以具有超連結的行為XLink 支援單純連結(類似 HTML) 以及擴展的連結(將多個資源連在一起)XLink 可以被定義在被聯結的外部檔案中 在 HTML 裡面 &lt;a&gt; 元素可以定義一個超連結，然後並沒有這樣的東西存在 XML 中，因為在 XML 是您定義元素。因此您不可能叫瀏覽器預測 XML 文件中什麼元素會有超連結的行為下面是 XLink 的範例 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;homepages xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;homepage xlink:type=\"simple\" xlink:href=\"http://www.w3schools.com\"&gt;Visit W3Schools&lt;/homepage&gt; &lt;homepage xlink:type=\"simple\" xlink:href=\"http://www.w3.org\"&gt;Visit w3c&lt;/homepage&gt;&lt;/homepages&gt; 為了能夠取得 XLink 的功能我們必須宣告 XLink 命名空間。而這個 namespace 是 http://www.w3.org/1999/xlink XML 相關技術整理 XML Extensible Markup Language一種簡單的資料結構格式類似 HTML XSL Extensible Style sheet Language XSL 由三個部分組成： XSLT 用來轉換 XML 的語言，用來把一個 XML 轉換成另外一種格式如 XHTML 的樣式結構與法 XPath 在 XML 中用來巡覽的語言，類似 CSS 中的 Selector XSL-FO 格式化 XML 的語言 XSLT 一種 XSL 用來把一個 XML 轉換成另外一種格式如 XHTML 的樣式結構與法 XML Schema 用 XML 取代 DTD 的功能 XLink 建立超連結的行為 XPointer 類似 HTML 中的錨點 CDATACDATA 在 XML 解析的時候會被忽略PCDATA 格式的文字會被解析會區分 PCDATA 的原因是因為元素裡面還能夠包含子元素不管是元素或者是元素內一般的內容文字都被歸類為 PCDATA 而 CDATA 就是不被解析的文字部分&lt; 和 &amp; 在 XML 元素中都是非法字元&lt; 字元被認定為非法字元的原因是因為解析器會認為這是一個元素的開始&amp; 不行則是因為這是一個 character entity 就是例如 &amp;amp; 或 &amp;gt; 這種格式編碼的開頭 一些文字像是 Javascript 包含很多的 &lt; &amp; 字元，為了避免錯誤 script 可以被定義成 CDATA 這樣一來就會被忽略，任何在 CDATA 段落裡面的只會被 XML Parser 忽略。 問題：您可以能想說那 CDATA 跟一般註解有什麼差別？ CDATA 仍然是文件的一部分，而註解不是。意思是告訴 Parser 就不要幫我解析了直接把全部的東西當作內容輸出在某些時候內容中含有 HTML 標籤或者是一些特殊字元﹙如﹕&lt;、&gt;、&amp;﹚，當這些字元出現在內容裡，通常都會出現 XML 分析錯誤的情況，這時候就必須將這些字元作些轉換的工作（如︰&lt; / &lt;、&gt; / &gt;、&amp; / &amp;）。 其實並不需要如此，CDATA 區段提供了一種通知剖析器的方法，說明 CDATA 區段所包含的字元沒有標記。 當 XML 剖析器遇到開頭的『&lt;![CDATA[』，會將接下來的內容報告成字元，而不會嘗試將其解譯成項目或實體標籤。字元參考不能在 CDATA 區段內運作。當它遇到結尾的『]]&gt;』時，剖析器會停止報告並回到正常的剖析 定義 CDATA&lt;![CDATA[ 資料在這邊 像是 &lt; 這時就合法了]]&gt; 注意裡面不可以再放 ]]&gt; XSLXSL 代表的是 Extensible Stylesheet LanguageW3C 發展 XSL 主要是因為有 XML Stylesheet Language 的需求。 HTML 的樣式表是 CSSHTML 使用預先定義好的標籤，而這些標籤的意義在使用前就知道用途&lt;table&gt; 標籤在 HTML 裡面定義一個表格，接著瀏覽器就知道該怎麼呈現他。特元素加入樣式在 HTML 非常簡單，只需要在 CSS 中告訴瀏覽器哪個元素該使用什麼背景色或字體即可。 XML 的樣式表是 XSLXML 並沒有預先定義好的標籤，因此我們並不知道每個標籤是在做什麼的。一個 &lt;table&gt; 標籤可能跟在 HTML 一樣或者代表一個傢俱，或其他的東西，瀏覽器並不知道該怎麼呈現XSL 會描述該如何呈現 XML XSL 不只是單純的樣式表語言XSL 由三個部分組成： XSLT 用來轉換 XML 的語言 XPath 在 XML 中用來巡覽的語言，類似 CSS 中的 Selector XSL-FO 格式化 XML 的語言 XSLT 是用來把 XML 文件轉成 XHTML 文件或者其他 XML 文件的語言。 過程是 XML -&gt; XSLT -&gt; XHTML(another xml doc)並且大部份的瀏覽器都支援。 撰寫 XSL 一開始需要定義格式 1234&lt;xsl:stylesheet version=\"1.0\"xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;&lt;xsl:transform version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt; 為了能夠使用 XSLT 的元素，屬性和功能必須要先定義 XSLT 的 namespace 在文件最上面。 xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; 指向 W3C XSLT 的命名空間，如果您使用這個命名空間那就必須要加入 version=&quot;1.0&quot; 的屬性 就跟 HTML 搭配 CSS 一樣，一個 XML 可以引入一個 XSL透過 &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;cdcatalog.xsl&quot;?&gt; 一個 XSL 樣式由一個或一些規則組成，這些規則稱之為樣板 &lt;xsl:template&gt; ，首先我們透過樣板來建立規則，然後 &lt;xsl:template&gt; 標籤會有一個屬性 match ，我們用 match 來關聯到 xml 的 element。這個 match 可以關聯定義整個 XML，而這個 match 的值是用 XPath 表示式，例如 / 就是根，指的是整份文件 我們可以想成一個 template 從 match 的元素取資料並套用到裡面的樣板。 因為 XSL 也是一種 XML 所以第一行宣告還是 XML接下來會用 &lt;xsl:stylesheet&gt; 定義這份文件是一個 XSLT 當然要加上 xmlns 和 version 瀏覽器執行時起始點是 XML 然後 XML 載入 XSL ，XSL 取得 XML 中的資料並且呈現。 &lt;xsl:value-of&gt; 標籤是用來取得 XML 資料用的。透過 select 屬性來取得 XML Tag 中的資料 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsl:stylesheet version=\"1.0\"xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;&lt;xsl:template match=\"/\"&gt; &lt;html&gt; &lt;body&gt; &lt;h2&gt;My CD Collection&lt;/h2&gt; &lt;table border=\"1\"&gt; &lt;tr bgcolor=\"#9acd32\"&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Artist&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;xsl:value-of select=\"catalog/cd/title\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=\"catalog/cd/artist\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; select 屬性的值一樣是使用 XPath Expression，XPath 運作的原理類似檔案系統路徑，從 root / 開始透過斜線一層一層對應 &lt;xsl:value-of&gt; 只會取得單一標籤，如果要迭代或者選取一整組則用 &lt;xsl:for-each&gt; 使用 for-each 可以把符合 select 規則的元素全部都取得然後全部一個一個套用內部的樣式。 另外要注意的是 select 的 XPath Expression 運作模式既然類似檔案系統，也就是說你可以使用相對路徑或者絕對路徑的方式。父元素已經取得的標籤，如果要繼續往內部取就像上面例子一樣就可以 123&lt;xsl:for-each select=\"catalog/cd\"&gt; &lt;xsl:value-of select=\"title\" /&gt;&lt;/xsl:for-each&gt; 除了選取之後 XPath Express 也可以像 CSS Selector 過濾一樣加上屬性過濾例如 &lt;xsl:for-each select=&quot;catalog/cd[artist=&#39;andy&#39;]&quot;&gt;但判斷邏輯就不像 CSS 這麼多種，只有4種，而且要注意 [] 並不是同層元素的屬性，而是子元素的值。如果要指定屬性則是&lt;xsl:for-each select=&quot;Factory/Car[@price&gt;=1100]&quot;&gt; 完整範例參考下面 = != &lt; &gt; 123456789101112131415161718192021222324252627282930313233&lt;!-- XML --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;?xml-stylesheet type=\"text/xsl\" href=\"car.xsl\"?&gt;&lt;Factory&gt; &lt;Car price=\"1000\"&gt; &lt;Brand&gt;Honda&lt;/Brand&gt; &lt;Type&gt;Civic&lt;/Type&gt; &lt;Displacement&gt;2000&lt;/Displacement&gt; &lt;/Car&gt; &lt;Car price=\"2000\"&gt; &lt;Brand&gt;Toyota&lt;/Brand&gt; &lt;Type&gt;Viso&lt;/Type&gt; &lt;Displacement&gt;1800&lt;/Displacement&gt; &lt;/Car&gt;&lt;/Factory&gt;&lt;!-- XSL --&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt; &lt;xsl:template match=\"/\"&gt; &lt;html&gt; &lt;body&gt; &lt;h2&gt;CAR&lt;/h2&gt; &lt;ul&gt; &lt;xsl:for-each select=\"Factory/Car[@price&gt;=1100]\"&gt; &lt;li&gt;&lt;xsl:value-of select=\"Brand\" /&gt;&lt;/li&gt; &lt;/xsl:for-each&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; 如果要排序則使用 &lt;xsl:sort&gt; 元素，如下用法 1234567&lt;xsl:for-each select=\"catalog/cd\"&gt; &lt;xsl:sort select=\"artist\"/&gt; &lt;tr&gt; &lt;td&gt;&lt;xsl:value-of select=\"title\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=\"artist\"/&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/xsl:for-each&gt; &lt;xsl:if&gt; 跟 filter 有點類似，但是是針對內部的元素 123456789&lt;xsl:for-each select=\"catalog/cd\"&gt; &lt;xsl:if test=\"price &amp;gt; 10\"&gt; &lt;tr&gt; &lt;td&gt;&lt;xsl:value-of select=\"title\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=\"artist\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;xsl:value-of select=\"price\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/xsl:if&gt;&lt;/xsl:for-each&gt; &lt;xsl:choose&gt; 類似其他語言中的 switch 123456789&lt;xsl:choose&gt; &lt;xsl:when test=\"expression\"&gt; ... some output ... &lt;/xsl:when&gt; &lt;xsl:otherwise&gt; ... some output .... &lt;/xsl:otherwise&gt;&lt;/xsl:choose&gt; Web ServicesWeb Services 是網頁應用程式元件。Web Services 可以被網站發佈，搜尋與使用。這份筆記會說明 WSDL, SOAP, UDDI, RDF WSDL 意思是 Web Services Description LanguageWSDL 是一種基於 XML 的語言用來描述 Web Services SOAP 意思為 Simple Object Access ProtocolSOAP 是一種基於 XML 存取 Web Services 的協議SOPA 架構在 XML 之上 UDDI 代表的是 Universal Description Discovery and Integration 統一描述、發現和集成UDDI 是一個目錄服務讓公司可以搜尋 Web ServiceUDDI 被描述在 WSDL 裡面UDDI 透過 SOAP 溝通 RDF 代表的是 Resource Description FrameworkRDF 是一個框架，目的是在 Web 上描述資源RDF 一樣透過 XML 來撰寫 Web Services 是應用程式的組件Web Services 透過開放式協定Web Services 可以透過 UDDI 來找到Web Services 可以被其他應用程式使用HTTP 和 XML 是組成 Web Services 的基礎 因為所有主流平台可以透過瀏覽器存取網頁，但不同平台無法互相溝通。為了使這些平台能夠一起工作，而發展了網頁應用程式。網頁應用程式可以簡單地在網頁上執行，而這些都圍繞在瀏覽器標準上且可以被用在任何平台的任何瀏覽器上 Web Services 帶領網頁應用程式到了另一個境界透過使用 Web Services 您的應用程式可以發布自己的函式或訊息給其他人使用Web Service 使用 XML 來編譯，解譯資料。然後用 SOAP 來傳輸。透過 Web Services 您部門的 Win 2k 的帳單系統可以和 IT 部門的 Unix Server 溝通 Web Services 有兩種使用方式 可重複使用的應用程序的組件 連結已存在的軟體 Postman 基本操作Postman 介面被區分成兩個區塊，左邊的 sidebar 和右邊的 request builder。request builder 可以讓我們建立幾乎所有種類的 request。HTTP request 分成 4 個部分 URL, method, header, body URLURL 是我們首先要設定的東西，對某個網址發送請求，這個欄位有 autocomplete 的功能會記錄之前發送的紀錄URL 欄位旁邊讓我們可以選擇 method(GET, POST…)，接著點擊URL params 按鈕可以在下方開啟參數表單這些參數通常會直接帶到網址列(GET的時候)，這些參數並不會自動 URL-encoded 對著欄位點右鍵可以 EncodeURIComponent您可以分開輸入每一組 key/value 然後 Postman 會自動整合。如果您把這些參數直接帶入 URL 欄位 Postman 會自動幫你切割帶入 params Headers點擊 headers 按鈕可以顯示另外一個鍵值編輯器，您可以設定 header 資料。常用共通的 HTTP 規格的 header 屬性都可以透過 autocomplete 來找到，另外像是 Content-Type 的值也有列表。 被限制的 headers 和 cookies很不幸的一些 headers 被 Chrome 和 XMLHttpRequest 規格所限制，下面這些 headers 是被禁止發送的 Accept-Charset Accept-Encoding Access-Control-Request-Headers Access-Control-Request-Method Connection Content-Length Cookie Cookie 2 Content-Transfer-Encoding Date Expect Host Keep-Alive Origin Referer TE Trailer Transfer-Encoding Upgrade User-Agent _ Via 新版的 Postman 可以安裝 Postman interceptor 就可以使用這些禁止的 headers Cookies當您使用新版的 packaged postman app 他會執行在一個沙箱裡跟瀏覽器是分開的，如此是不能存取瀏覽器中的 cookie，這個限制仍然可以透過 interceptor 來克服。Postman 透過 interceptor 掌管了所有 request 的路由資訊。透過在 Header 中加入 “Cookie” 然後在 value 欄位使用 name=123 可以設定 cookie 或者讀取 Request body 和 parameter當我們要建構一個 request 的時候通常都需要處理 request body(就是 form post 出去的那些資料)，Postman 讓我們幾乎可以發送任何種類的 HTTP Request，body 編輯區分成 4 個區塊 form-data這種格式採用 multipart/form-data Content-Type 預設會編碼一個 web form 用來傳輸資料。這就類似在網頁上的 form 輸入完資料送出，不過根據 W3C 規範 form post 預設是採用 x-www-form-urlencoded multipart/form-data application/x-www-form-urlencoded 差異第二篇 使用 Postman 發送 SOAP教學 WSDLWSDL 代表的是 Web Services Description LanguageWSDL 使用 XML 寫成WSDL 就是一份 XML 文件WSDL 用來描述 Web ServiceWSDL 也被用來找尋對應的 Web ServicesWSDL 就是一份 XML 文件用來描述某個 Web Service 的 XML 文件，這份文件會紀錄 Web Service 的位置和 Method 怎麼操作，Service 會透露什麼訊息 WSDL 的文件結構12345678910111213141516&lt;definitions&gt; &lt;types&gt; Web services 資料格式定義 一個容器 &lt;/types&gt; &lt;message&gt; 用來溝通的資料定義 &lt;/message&gt; &lt;portType&gt; 支援的操作 &lt;/portType&gt; &lt;binding&gt; 針對特定 portType 的協定和資料格式 &lt;/binding&gt;&lt;/definitions&gt; 一份 WSDL 文件可以包含其他元素，例如擴展元素和 Service 元素，讓其可以把一些 WebService 的定義彙整到一份 WSDL WSDL Ports&lt;portType&gt; 元素幾乎是最重要的元素，用來描述一個 Web Service 關於其可以被執行的操作及包含的訊息，用程式語言來比喻一個 &lt;portType&gt; 元素可以被當成一個 function 函式庫或者一個 class WSDL Message&lt;message&gt; 定義關於一個操作的資料元素，每一個 message 可以由一個或多個 parts 組成，parts 可以想成是參數 WSDL Types&lt;types&gt; 元素用來定義資料類型，給 Web Service 使用。 WSDL Bindings&lt;binding&gt; 元素用來給不同的 prot 定義資料格式 簡易的範例1234567891011121314&lt;message name=\"getTermRequest\"&gt; &lt;part name=\"term\" type=\"xs:string\" /&gt;&lt;/message&gt;&lt;message name=\"getTermResponse\"&gt; &lt;part name=\"value\" type=\"xs:string\"/&gt;&lt;/message&gt;&lt;portType name=\"glossaryTerms\"&gt; &lt;operation name=\"getTerm\"&gt; &lt;input message=\"getTermRequest\" /&gt; &lt;output message=\"getTermResponse\" /&gt; &lt;/operation&gt;&lt;/portType&gt; &lt;portType&gt; 元素幾乎是 WSDL 最重要的元素，一個 portType 定義一個 Web Service 有哪些操作可以被執行，還有對應的 message。&lt;portType&gt; 定義 Web Service 的一個連接點，portType 就是一個函式庫然後呼叫的時候有一個對應執行 functionreturn 回傳值的時候有另外一個 function 就是 messagemessage 裡面的 part 就是參數 &lt;operations&gt; 又區分四種類型 只收資料 收資料，回傳資料 主動發送 request 然後等待 response 只送資料 123456789101112131415161718192021222324252627&lt;!-- 只收資料範例 --&gt;&lt;message name=\"newTermValues\"&gt; &lt;part name=\"term\" type=\"xs:string\"/&gt; &lt;part name=\"value\" type=\"xs:string\"/&gt;&lt;/message&gt;&lt;portType name=\"glossaryTerms\"&gt; &lt;operation name=\"setTerm\"&gt; &lt;!--實際 call 的 method name --&gt; &lt;input name=\"newTerm\" message=\"newTermValues\" /&gt; &lt;!-- 其實只負責關聯函式的參數部分 message 很重要，name 不重要 ，另一個角度思考就是一個要傳入或 return 的 object 格式 - 訊息格式。--&gt; &lt;/operation&gt;&lt;/portType&gt;&lt;!-- 一般發收資料 --&gt;&lt;message name=\"getTermRequest\"&gt; &lt;part name=\"term\" type=\"xs:string\" /&gt;&lt;/message&gt;&lt;message name=\"getTermResponse\"&gt; &lt;part name=\"value\" type=\"xs:string\" /&gt;&lt;/message&gt;&lt;portType name=\"glossaryTerms\"&gt; &lt;operation name=\"getTerm\"&gt; &lt;input message=\"getTermRequest\" /&gt; &lt;input message=\"getTermResponse\" /&gt; &lt;/operation&gt;&lt;/portType&gt; WSDL bindings 定義一個 Web Service 的 message 格式和協定的細節例如 123456789101112131415161718192021222324&lt;message name=\"getTermRequest\"&gt; &lt;part name=\"term\" type=\"xs:string\" /&gt;&lt;/message&gt;&lt;message name=\"getTermResponse\"&gt; &lt;part name=\"value\" type=\"xs:string\" /&gt;&lt;/message&gt;&lt;portType name=\"glossaryTerms\"&gt; &lt;operation name=\"getTerm\"&gt; &lt;input message=\"getTermRequest\" /&gt; &lt;output message=\"getTermResponse\" /&gt; &lt;/operation&gt;&lt;/portType&gt;&lt;binding type=\"glosaryTerms\" name=\"b1\"&gt; &lt;soap:binding style=\"document\" transport=\"http://schemas.xmlsoap.org/soap/http\" /&gt; &lt;operation&gt; &lt;soap:operation soapAction=\"http://example.com/getTerm\" /&gt; &lt;input&gt;&lt;soap:body use=\"literal\" /&gt;&lt;/input&gt; &lt;output&gt;&lt;soap:body use=\"literal\" /&gt;&lt;/output&gt; &lt;/operation&gt;&lt;/binding&gt; binding 元素有兩個屬性 name typename 您可以隨意定義一個 binding 的名稱，type 指向該綁定誰 portTypesoap:binding 有兩個屬性 style transportstype 可以是 rpc 或者 documenttransport 定義 soap 協定裡面的 operation 定義 portType 裡面的每個 operation 該揭露哪些訊息soapAction 指向該 method 的 url 對該網址 post WSDL 和 UDDIUDDI 是一個目錄服務，讓公司可以註冊或搜尋 Web ServiceUDDI 代表 Universal Description, Discovery IntegrationUDDI 是一個目錄用來儲存關於 Web Service 的資訊UDDI 是 Web Service 介面的一個目錄，這個介面透過 WSDL 描述UDDI 透過 SOAP 溝通 SOAPSOAP 代表 Simple Object Access ProtocolSOAP 是一種協定，用來存取 Web ServiceSOAP 架構在 XML 之上SOAP 是用來讓應用程式之間溝通的SOAP 透過網路溝通 一個 SOAP 訊息就只是一個普通的 XML 不過包含下面的訊息一個 Envelope 元素定義一個 XML 為 SOAP 訊息一個 Header 元素包含表頭資訊一個 Body 包含要回應的訊息一個 Fault 包含錯誤和狀態訊息 在 Header 裡面加上 mustUnderstand 屬性表示這個標籤一定要給 12345&lt;soap:Header&gt; &lt;m:Trans xmlns:m=\"http://www.w3schools.com/transaction/\" soap:mustUnderstand=\"1\"&gt;234 &lt;/m:Trans&gt;&lt;/soap:Header&gt; TODO 問題 用 .NET 實作 WebServices 然後用 OSX Post 取得資料？ ANS: 在 Window 8 底下 PostMan 對 localhost 開發伺服器發送 Post 成功 為什麼用 HTML Form 可以直接對 W3C http://www.w3schools.com/webservices/tempconvert.asmx?op=FahrenheitToCelsius丟資料會成功，但是 PostMan 失敗哪邊搞錯了 ANS: 用 PostMan 要在 x-www-form-urlencoded 放資料就會成功了 對自己的 Web Services(NET 版)測試用 Form 和 PostMan 丟資料 from-data, x-www-form-urlencoded, raw 的差異？ ANS: 在傳輸表單資料時候(Form) ，W3C 針對 Form 的內容定義了不同的類型，如果您希望傳送的是簡單的文字資料那麼 x-www-form-urlencoded 就能夠運作，這是預設的格式。不過如果您要傳送非 ASCII 文字或者 Binary 資料，那麼就要改用 form-data 模擬對 Sails 發送 SOAP 接到 XML 資料 6-1-1. 定義一個簡單的 WSDL(手刻)6-1-2. 從 Sails 發出一份 WSDL，用 SOAP UI 檢查6-2. 根據這份定義 User 要知道怎麼寫 SOAP Request6-3. 開發者也要知道會收到什麼資料，回傳什麼資料","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"xml","slug":"xml","permalink":"//andyyou.github.io/tags/xml/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Heroku 無法 fetch gem","slug":"heroku-push-fail","date":"2015-04-30T21:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/05/01/heroku-push-fail/","link":"","permalink":"//andyyou.github.io/2015/05/01/heroku-push-fail/","excerpt":"","text":"當我們在本機設定 gem 的時候有時候會採用直接從 github 下載的方式 1gem 'datetimepicker-rails', github: 'zpaulovics/datetimepicker-rails', branch: 'master', submodules: true 不過當我們要把程式碼部署到雲上的主機時，有些時候會碰上該機器無法去 fetch repo 的狀況 這個時候請參考這邊改變設定即可","categories":[{"name":"Cloud","slug":"Cloud","permalink":"//andyyou.github.io/categories/Cloud/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"},{"name":"heroku","slug":"heroku","permalink":"//andyyou.github.io/tags/heroku/"}],"keywords":[{"name":"Cloud","slug":"Cloud","permalink":"//andyyou.github.io/categories/Cloud/"}]},{"title":"快速 JS 筆記","slug":"my-js-notes","date":"2015-04-27T21:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/28/my-js-notes/","link":"","permalink":"//andyyou.github.io/2015/04/28/my-js-notes/","excerpt":"基本的 Javascript 型別定義有 6 個 Number String Boolean Function Object Undefined","text":"基本的 Javascript 型別定義有 6 個 Number String Boolean Function Object Undefined 如果把比較特殊一點的做歸納整理則如下 Number （數字） String （字串） Boolean （布林） Object （物件） Function （函式） Array （陣列） Date （日期） RegExp Null （空） Undefined （未定義） 字串可以用 + 串接，然後比較特別的是 backslash \\ 跳脫字元。 不是所有的 operator 操作子都是符號，例如 typeof 就不是，他是一元的操作子 Javascript 中只有 NaN 不會等於 NaN 1NaN == NaN // #=&gt; false NaN 表示不合理的計算 Not a Number || 處理優先權最小，再來是 &amp;&amp; 然後則是比較子 &gt;, ==, &lt; 等等 Javascript 討厭的地方在於自動轉型常常會導致誤會 12345678910111213141516171819console.log(8 * numm);// 0console.log(\"5\" - 1);// 4console.log(\"5\" + 1);// 51console.log(\"five\" * 2);// NaNconsole.log(false == 0);// trueconsole.log(null == undefined);// trueconsole.log(0 == null); 如果要測試一個值是否存在可以簡單的直接拿該值跟 null 或 undefined 比較即可 125 == null// false 此外 JS 還對一些值轉換成 Boolean 有自己的規則 0, NaN, &quot;&quot; 空字串 123456789101112130 == false// true\"\" == false// trueNaN == false// falseif (!NaN) &#123; console.log(\"In this caes NaN equal to false\")&#125;// In this caes NaN equal to false 總結在單純 if expression 中 0, NaN, &quot;&quot;, undefined, null 會等於 false 其他值都是 true。不過注意 &quot; &quot; == false, 0 == false 會是 true，如果不想自動轉型請用=== 和 !== &amp;&amp; 和 || 的行為是會先將兩側的操作元轉成 Boolean (true, false)，不過奇特的是當比完時結果會從兩側來取。 舉例來說 || 當他能夠先將左側的值轉成 true 時他就先回傳左側的值，否則就傳右邊的值。 12345678null || undefined// undefined\"foo\" || \"bar\"// fooInfinity || true// Infinity 這個功能讓我們能夠透過 || 來實現預設值的功能，當左邊沒值的時候採用右邊的預設值。 &amp;&amp; 功能也類似，當左邊的值能被轉成 false 的時候，就回傳左邊的值，否則就傳回右邊。 另外 &amp;&amp; 和 || 有一個重點行為是只有當需要時才評估右邊的值，舉例如果 true || X 此時就不需要評估 X 直接回傳 true。 小結判斷規則0, 空字串, NaN, undefined, null 在遇上自動轉型成 Boolean 時都是 false 不管您是使用一般 if 表示式或者 &amp;&amp;, || ，不過如果遇到 == false 操作子時只有 0 和 空字串成立 一個片段程式碼產生一個值稱之為 expressionexpression 類似語言中的片語，一個短句。statement 則是一句完整的句子，在 JS 中用 ; 結束當作一個句子。 通常一個 statement 是獨立的，只會完成某項任務，不過如果它影響了整個程式例如: 異動了機器內部的狀態，或者影響後面的 statement，這些造成的改變我們就稱為 side effect (副作用) 關鍵字123456break case catch class const continue debuggerdefault delete do else enum export extends falsefinally for function if implements import ininstanceof interface let new null package privateprotected public return static super switch thisthrow true try typeof var void while with yield in 的用法在 JS 中如果要檢查一個物件有沒有 property 我們可以使用 in 來檢查 123456789101112131415var car = &#123; name: 'Toyota'&#125;console.log(\"name\" in car);// trueconsole.log(\"brand\" in car);// false// 也可以在 for 裡面遍歷所有的屬性for (var property in object) &#123; console.log(property);&#125; 屬性一般來說物件的屬性名稱必須要是合法的變數名稱。使用 object.property . 的方式取得。不過 JS 有特殊的取法可以用 [] 來取，因為陣列也是一種特殊的物件，同時語法允許我們透過索引和不符合變數命名規則的方式來取得 12345678910var person = &#123; \"first name\": \"You\", 1: 2&#125;console.log(person[\"first name\"]);// Youconsole.log(person[1]);// 2 function 中的 argumentsarguments 是一個類陣列物件，它並不是陣列，只是類似但並不包含陣列的 methods 除了 length 外 123456789101112131415161718// 如果要用陣列的 methodsArray.prototype.slice.call(arguments);function func() &#123;&#125;func.apply(context, array);func.call(context, 1, 2, 3, 4);// 判斷物件是不是陣列Object.prototype.toString.call( anObject )// [object Array]// [object Arguments][].concat( anObject );Array.isArray( [] )// Check an object is array apply 要丟陣列，丟物件會無法取得 arguments，因為 arguments 是一個類 array 的物件，可以想成它是從 array 轉型而來，砍掉一些 methods 1234567891011function Call() &#123; console.log(\"arguments type: \", Object.prototype.toString.call(arguments)); for(var i = 0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125; console.log(\"name: \", arguments[\"name\"]); console.log(arguments.toString());&#125;// Call.apply(null, &#123;name: \"andy\", age: 28&#125;);// Call.apply(null, [1, 2, 3]); 高階 function 總結筆記一個大型的程式是昂貴的，不只是因為需要花比較多的時間來建置大小永遠牽扯到複雜度，越複雜越容易造成開發者困惑，反過來說也就容易產生 bug，越大的程式越容易躲藏 bug 且不好找。 123456789var total = 0, count = 1;while(count &lt;= 10) &#123; total += count; count += 1;&#125;console.log(total);// 抽象化後console.log(sum(range(1, 10))); 抽象化一詞代表將瑣碎的程式片段包裝成有語意的 function 或 method 讓開發者可以更清楚其代表的意義。 在程式的執行環境裡這些有意義的單字詞彙通常就稱為抽象化。抽象化把實際執行的細節隱藏起來，讓我們能夠用比較高階的方式直接處理問題 JSON.stringify() // -&gt; 轉成文字JSON.parse() // -&gt; 轉成物件 forEach 直接把陣列元素傳入另外一個 functionfilter map 都會產生新的陣列reduce 合併一個新值bind 會產生另外一個 function 1234567891011121314151617181920212223242526272829var arrays = [1, 2, 3, 4];arrays.reduce(處理函式(結果, 每次帶入的元素), 結果變數的初始值)arrays.reduce(function(total, num)&#123; total += num;&#125;, 10);[1, 2, 3].reduce(function(total, num)&#123;return total += num&#125;, 10);// 16// 常用的示範function average(array) &#123; function plus(a, b) &#123; return a + b; &#125; return array.reduce(plus) / array.length;&#125;var byName = &#123;&#125;;ancestry.forEach(function(person) &#123; byName[person.name] = person;&#125;);var ageOfMothers = ancestry.filter(function(person) &#123; return byName[person.mother] != null&#125;).map(function(person) &#123; return person.born - byName[person.mother].born;&#125;);console.log(average(ageOfMothers)); Methods 單純就是一個屬性其 value 是一個 function當一個 function 被當成 method 且被呼叫調用時 object.method() 會產生一個特殊的變數 this 在該 function 的 block 中(Javascript 沒有 block 的概念，應該說是 context) 這個 this 會指向該物件。 12345678function speak(line) &#123; console.log(\"The\" + this.type + \" rabbit says: \" + line );&#125;var whiteRabbit = &#123;type: 'white', speak: speak&#125;;var fatRabbit = &#123;type: 'fat', speak: speak &#125;;whiteRabbit.speak(\"Oh my ears and whiskers\"); bind apply call 的第一個參數可以簡單地想成設定 this 物件值 在 JS 中物件搜尋屬性會先從物件本身開始，如果找不到則找物件的祖先，就是物件的 prototype 123456789101112console.log(Object.getPrototypeOf(&#123;&#125;) == Object.prototype);// trueconsole.log(Object.getPrototypeOf(Object.prototype));// → nullconsole.log(Object.getPrototypeOf(isNaN) == Function.prototype);// → trueconsole.log(Object.getPrototypeOf([]) == Array.prototype);// → true 所有 JS 中物件繼承的根 root 就是 Object.prototype它提供了一些方法給所有的物件使用，例如 toString Obejct.create 可以建立物件並指定繼承的對象 123456789var protoRabbit = &#123; speak: function(line) &#123; console.log(\"The \" + this.type + \" rabbit says '\" + line + \"'\"); &#125;&#125;;var killerRabbit = Object.create(protoRabbit);killerRabbit.type = \"killer\";killerRabbit.speak(\"SKREEEE!\"); 另外一個建立物件更方便方式是使用 constructor 因為目前 JS 沒有 class 的概念。在 JS 使用 new 搭配 Function 會產生類似 constructor 的效果。建構子會將該物件綁定 this 變數上。當我們使用 new Function() 時會回傳一個新的物件。其意義為請根據建構子回傳一個物件實例。 1234567function Rabbit(type) &#123; this.type = type;&#125;var blackRabbit = new Rabbit(\"black\");blackRabbit.type;// black 建構子(在 JS 中也就是所有 function) 會自動取得一個 prototype 屬性且預設會帶一個單純的空物件，繼承自 Object.prototype 這個物件(即複製一個一樣結構的新物件到 prototype)然後每一個透過該建構子產生的物件實例(instance)都會有上面說的 prototype 物件，也就是會共享同一個物件來完成繼承這件事之後修改 prototype 每個用該 function 產生的物件實例都可以取用該物件的屬性 toString 用在一般物件上會顯示 [object Object] 的字串資訊但是用在 Array 上則會像使用 join(&#39;,&#39;) 的效果。 因為覆寫的關係所以 Array 的 toString 和 Object 的不同我們可以用 12345console.log(Object.prototype.toString.call([1, 2]));// -&gt; [object Array][1, 2].toString();// 1,2 我們現在可以透過 function 的建構子機制來建立物件，然後透過 prototype 來分享一些方法。但是這有一個問題，在上面我們曾經透過下面這種方式把資料存進物件中 1234567var map = &#123;&#125;;function storePhi(event, phi) &#123; map[event] = phi;&#125;storePhi(\"pizza\", 0.069);storePhi(\"touched tree\", -0.081); 會發生一種問題是在 prototype 裡面加入的 methods 也會被輸出 12345678910111213Object.prototype.nonsense = \"hi\";for (var name in map) console.log(name);// → pizza// → touched tree// → nonsenseconsole.log(\"nonsense\" in map);// → trueconsole.log(\"toString\" in map);// → true// Delete the problematic property againdelete Object.prototype.nonsense; 但是我們發現 toString 並沒有被 for in 輸出這是因為 JS 會區分 enumerable 和 nonenumerable 屬性，我們自己透過 prototype 加進去的屬性會被迭代屬於 enumerable 但是預設在 Object.prototype 裡面的不會，屬於 nonenumerable 要定義 nonenumerable 的屬性 1Object.defineProperty(Object.prototype,\"hiddenNonsense\",&#123;enumerable: false, value: \"hi\"&#125;); 透過這種方式屬性被加進去了，但是不會被 for/in 取得。不過當我們用 &quot;hiddenNonsense&quot; in object 時還是會出現 true 為了區分屬性是物件自己的還是 prototype 的，我們有 hasOwnProperty(name) 這個方法來判斷。 當我們覺得問題都解決的時候，事實上還有一種狀況，就是開發者覆寫了 hasOwnProperty，在上面這種情況我們只想單純取得物件本身的屬性而不要 prototype 的東西，此時我們可以透過 Object.create(null) 這樣一來就沒有任何 prototype 的屬性了 或者 Object.hasOwnProperty.call(obj, &quot;property&quot;) 123456789101112var map = Object.create(null);map[\"pizza\"] = 0.069;console.log(\"toString\" in map);// → falseconsole.log(\"pizza\" in map);// → true// 除了上面這種方式，當 hasOwnProperty 被 override 之後我們仍可以用這種方式確保方法Object.hasOwnProperty.call(map, \"pizza\");// trueObject.hasOwnProperty.call(map, \"toString\");// false 當您呼叫 String() 函式時他會把傳進去的值轉成字串，透過 toString 這個方法，注意之前有提到有些物件的 toString 方法和預設並不相同，如 Array 我將透過稍微複雜的範例試圖解釋關於 polymorphism 以及一般物件導向的觀念。在下面這個專案我們將會寫一段程式透過表格中表示欄位(Table cell)陣列中的陣列資料，建立一個字串。這個字串包含著一個表格格式。意思是透過欄和列來呈現，列同時也會對齊。看起來就像下面這樣 name height country Kilimanjaro 5895 TanzaniaEverest 8848 NepalMount Fuji 3776 JapanMont Blanc 4808 Italy/FranceVaalserberg 323 NetherlandsDenali 6168 United StatesPopocatepetl 5465 Mexico 表格系統建立的方式將會透過建置函式取得每一個 cell 的寬高透過偵測一欄的寬度以及列的高度來畫出正確的尺寸接著組合它們變成一個字串 layout 程式會透過我們已經定義好的介面跟 cell 物件溝通進一步說透過這種方式 cell 將會是動態的，後續我們將會再加入一些樣式例如 header 的底線，同時我們也不用再修改 layout 部分的程式碼 下面是我們定義的介面minHeight() 傳回 cell 最小需要的高度(文字行數)minWidth() 傳回 cell 最少需要的寬度(文字字數)draw() 回傳一個 height 長度的陣列其中包含一系列的文字，這些文字也是代表 width 的字元寬。這是用來表示 cell 的內容 這邊將會大量使用高階的陣列方法，因為這也是比較好的方式 首先第一個部分是計算最小欄位寬的陣列組和列高的陣列組rows 變數會保存一個二維陣列組，內部的陣列代表一列rows 是一個陣列 裡面的 row 也是陣列[ row, row, row, [// It’s a row] ] 123456789101112131415161718// 從 rows 裡面計算出每一個 row 的高度function rowHeights(rows) &#123; return rows.map(function(row)&#123; return row.reduce(function(max, cell) &#123; return Math.max(max, cell.minHeight); &#125;, 0); &#125;);&#125;function colWidths(rows) &#123; return rows[0].map(function(_, index) &#123; return rows.reduce(function(max, row)&#123; // 一次先比每一個 row 的 col-inex 比出誰比較寬 // 最少需要多寬，就是取最大的寬 return Math.max(max, row[index]); &#125;, 0); &#125;);&#125; 當我們對變數名稱使用 _ 開頭或者整個變數都是由 _ 組成是讓我們人看到的時候可以直接知道這個變數將不會使用 rowHeights 應該不難理解，透過使用 reduce 方法去找出每一 row 陣列中最大的高，再透過 map 把這些高及合成一個陣列 heights colWidths 函式比較起來稍微難一點，因為最外層是使用一個 row 的陣列來取得欄位的數量，並不是直接用。剛剛忘記提到 map forEach filter 和其他類似的陣列方法都可以再傳入第二個參數，這個參數會取得當前元素的索引。如此一來我們就可以只透過 index 表示目前到了第幾個欄位 colWidths 類似 rowHeights 目的是要取得所有欄位最寬的值 12345678910111213141516171819202122function drawTable(rows)&#123; var heights = rowHeights(rows); var widths = colWidths(rows); function drawLine(blocks, lineNo) &#123; return blocks.map(function(block) &#123; return block[lineNo]; &#125;).join(\" \"); &#125; function drawRow(row, rowNum) &#123; var blocks = row.map(function(cell, colNum) &#123; return cell.draw(widths[colNum], heights[rowNum]); &#125;); return blocks[0].map(function(_, lineNo) &#123; return drawLine(blocks, lineNo); &#125;).join(\"\\n\"); &#125; return rows.map(drawRow).join(\"\\n\");&#125; drawTable 函式使用內部輔助函式 drawRow 來畫出所有列然後把這些 rows 串在一起每一列之間隔一個 \\n drawRow 函式先把 row 陣列中的 cell 物件轉成 blocks一 row = 一 blocks 現在 blocks 使用字串的陣列來表示 cell 的內容，一個 row 對應一個 blocks 陣列。而裡面原本的單一 cell 例如本來是 cell.height 的值是 3776 現在就會換成 [“3776”] 來呈現，如果要加上底線則可能會像這樣 [“name”, “—-“] 一列的 blocks 擁有一樣的高，應該會彼此相連直到最後 接著在 drawRow 中呼叫 map （這邊看不懂） 123456789101112131415161718192021222324252627282930313233function repeat(string, times) &#123; var result = \"\"; for(var i = 0; i &lt; times; i++) &#123; result += string; &#125; return result;&#125;function TextCell(text) &#123; this.text = text.split(\"\\n\");&#125;TextCell.prototype.minWidth = function() &#123; // 格子內的文字會先用 `\\n` 拆成一個陣列，一行一個 element return this.text.reduce(function(width, line) &#123; return Math.max(width, line.length); &#125;, 0);&#125;;TextCell.prototype.minHeight = function() &#123; return this.text.length; // 幾行&#125;TextCell.prototype.draw = function(width, height) &#123; var result = []; for (var i = 0; i &lt; height; i++) &#123; var line = this.text[i] || \"\"; result.push(line + repeat(\" \", width - line.length)); &#125; return result;&#125; Object.keys 會把屬性輸出成一個陣列，當然這跟上面提到的一致 nonenumerable 的屬性不會出現。 blocks -&gt; [[“name”, “—–”], [“height”, “——“]] rows Array[5][ TextCell, TextCell, TextCell, TextCell, TextCell] TextCell.text (Array) Array 常用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 複製一份新的陣列var clone = array.slice(0);// 長度array.length// 排序 小-&gt;大array.sort(); // 有副作用，NO-COPY// 排序 大-&gt;小array.reverse(); // 有副作用，NO-COPY// 串連，合併陣列array.concat(another_array); // COPY// 搜尋陣列中的元素array.indexOf(\"1\"); // return index 找不到回傳 -1// 把陣列的元素串成一個字串array.join();// 從尾巴搜尋回來array.lastIndexOf(\"b\");// 從尾巴移除元素array.pop();// 從尾巴加入元素array.push(ele);// 從頭移除元素array.shift();// 從頭加入元素array.unshift(ele);// 回傳陣列的參考，意為賦予的新變數記憶體是同一個位址array.valueOf();// 選擇部分元素，並回傳一個新的陣列array.slice(1, 3); // COPYarray.slice(從 index 元素開始, 到這個 index 之前一位)array..slice(-3, -1); // 可以用負數，最後一位是 -1 往回算// 刪除陣列中的元素，副作用 NO-COPYvar o = [1, 2, 3, 4];delete o[2];// #=&gt; [ 1, 2, &lt;1 empty slot&gt;, 4 ]// 刪除並且新增元素array.splice(1, 0, ele1, ele2 );array.splice(index, 刪除幾個, 加入元素1, 加入元素2); // 可用負數，回傳的是被刪掉的值的陣列，會從 index 開始塞資料// mapvar numbers = [1, 4, 9];var doubles = numbers.map(function(num) &#123; return num * 2;&#125;);// #=&gt; doubles is now [2, 8, 18]. numbers is still [1, 4, 9]// 是否是陣列Array.isArray()// 如果陣列中所有元素都滿足就回傳 true 否則 false[1, 2, 3].every(function(element, index, array)&#123;&#125;)// #=&gt; true, false// element 當前元素, index 當前索引, array 整個陣列// 只要有一些符合就 truearray.some(function(element, index, array)&#123;&#125;);// 過濾並回傳新元素array.filter(function(element, index, array)&#123; return &#125;)// 陣列遍歷array.forEach(function(element, index, array) &#123;&#125;)// 元素一個一個濃縮合併[0, 1, 2, 3, 4].reduce(function(sum, current, index, array)&#123;&#125;, init);array.reduceRight(); // 從右邊到左邊// keys 陣列元素一個一個取var arr = [\"a\", \"b\", \"c\"];var iterator = arr.keys();console.log(iterator.next()); // &#123; value: 0, done: false &#125;console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125;// 搜尋元素array.includes(searchElement[, fromIndex])","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"參透Javascript閉包與Scope Chain","slug":"understand-closures-and-scope-chain","date":"2015-04-20T06:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/20/understand-closures-and-scope-chain/","link":"","permalink":"//andyyou.github.io/2015/04/20/understand-closures-and-scope-chain/","excerpt":"從上一篇文章中我們知道了每一個 function 有一個對應的執行環境 其中包含著一個由在該範圍內所有的變數，function 參考，參數定義所組成的 variable object(變數物件 VO)。","text":"從上一篇文章中我們知道了每一個 function 有一個對應的執行環境 其中包含著一個由在該範圍內所有的變數，function 參考，參數定義所組成的 variable object(變數物件 VO)。另外每一個執行環境中還定義了一個 scope chain 屬性，它就是一個記錄包含 自己的 VO + 所有上層執行環境的 VO 的集合。 如果我們用普通話的來說：一個環境的概念，可以想成是因為環境受到裡面變數記錄的影響，而這些實際影響環境的變數資料會被放在 variable object 裡面。 123scope = VO + 所有上層的 VO /* 範圍/環境 = 這些紀錄的總和 *//* 所以所謂的 scope chain */scope chain = [[VO] + [VO1] + [VO2] + [VO n+1]]; 確立一個 scope chain 的變數物件們現在我們知道 scope chain 就是用來保存這些變數物件，且我們的第一個變數物件就是當前執行環境物件自己的變數物件，剩下的 變數物件 就是上層執行環境或說父代執行環境的 1234567891011function one() &#123; two(); function two() &#123; three(); function three() &#123; alert(\"I am at function three\"); &#125; &#125;&#125; 這個範例很簡單的示範從 global context 我們呼叫的 one()，one() 呼叫 two()，接著在呼叫 three()，最後在 function three 發動一個 alert，下圖是當我們執行到 alert 時堆疊的概念圖 此時的 scope chain 就會是 three() scope chain = [[three() VO] + [two() VO] + [one() VO] + [Global VO]]; Lexical ScopeJS 中有一個挺重要的特性那就是直譯器採用 Lexical Scoping，它和 Dynamic Scoping 相反… 簡單的來說這個 Lexical Scoping 只不過是在說：函式內部定義的程式碼是根據定義時決定其值而不是動態決定。用上一篇的概念來解釋那就是變數 決定值 的時候是去哪個範圍(scope)找。 還是很難懂！好吧！會搞得這麼複雜呢我想應該是源自於對於 scope 翻譯翻的不好參考維基百科的定義 In computer programming, the scope of a name binding – an association of a name to an entity, such as a variable – is the part of a computer program where the binding is valid: where the name can be used to refer to the entity. OK 我們知道了英文說 scope 其實就只是在說明變數名稱該怎麼樣跟物件實例做關聯，關聯的範圍。至於這個 Lexical Scoping 讓我們來點實際範例看看什麼叫做 根據定義時決定 12345678910function start() &#123; alert(args);&#125;function server() &#123; var args = \"parameter here.\"; start();&#125;server(); // ReferenceError: args is not defined 如我我們照著上一篇執行環境的流程順序來看那麼 start() 的 VO 其實就只能夠去參考 start() 變數物件 和 Global 的變數物件 而已。 說明完 Lexical Scoping 我們回到上面的 one two three 的例子，不管呼叫的順序是怎樣，three() 永遠只能靜態的去參考 two() 層的定義，當然還有自己的，以此類推一層一層往上。 123456789(function a () &#123; var a = 1; function b() &#123; var b = 2; console.log(a); console.log(b); &#125; b();&#125;()); scope chain 的用途大概就是像上面這樣，就只是層層往上參考。而 Lexical Scoping 會這麼困難倒不是因為觀念，而是因為實作的時候，context 是在呼叫的時候才開始建立，配上靜態的 Lexical scoping 定義常常就會導致一些非預期的結果或行為。 最常見的例子就是 12345678910111213var alerts = [];for (var i = 0; i &lt; 5; i++) &#123; alerts.push(function inner()&#123; alert(i); &#125;)&#125;alerts[0](); // 5alerts[1](); // 5alerts[2](); // 5alerts[3](); // 5alerts[4](); // 5 第一次看這個範例碼通常都會覺得 alert(i); 會是輸出從 0 - 4這是最常發生對 function inner 混淆的地方。 inner 是在 global context 這邊被定義的，因為 for 沒有自己的 scopeOK 且該執行環境是在被呼叫的時候才建立，這個時候 i 早就是 5 了。 現在您明白其中的原由了。 解析變數的值下面這個範例輸出 a + b + c = 6 1234567891011121314function one() &#123; var a = 1; two(); function two() &#123; var b = 2; three(); function three() &#123; var c = 3; alert(a + b + c); // 6 &#125; &#125;&#125;one()​;​ 我們剛剛沒有認真的解釋關於 scope chain 的部分，現在先看看上面的例子，乍看之下我們知道 a b 並不在 function three 裡面，那麼這個範例是怎麼輸出 6 的 從 alert(a + b + c); 這行程式，當直譯器開始要找 a 的時候，它會不斷的到 scope chain 裡面去尋找，這個過程如下圖 一開始會到自己的 VO 去找，找不到換下一個一直到 Global 為止。如果都找不到則丟出 ReferenceError 的錯誤，所以上面這段小範例 a b c 都會找到值。 關於閉包在 Javascript 中，閉包常常被認為是種魔術，且只有進階的開發者才真的搞懂它，不過事實上對於閉包的了解其實源自於對於 scope chain 的了解， Crockford 說: An inner function always has access to the vars and parameters of its outer function, even after the outer function has returned… 簡單的說就是，位在內部的 function 永遠可以存取到外部的變數和參數，即使外部 function 已經執行完畢。再根據 MDN 說明，其實閉包就是一個特殊的物件，它有兩個含義： 它是一個 function。 它產生了一個 context 執行環境，配合上面的說明你就知道其實他只是幫你你記錄上一層有宣告的變數，沒錯就是那個 variable object。 Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure ‘remembers’ the environment in which it was created. 12345678910function factory() &#123; var brand = \"BMW\"; return function car() &#123; alert(\"I am a \" + brand + \" car\"); &#125;&#125;var carMaker = factory();carMaker(); // I am a BMW car global context 有一個稱為 factory() 的函式，接著有一個變數叫做 carMaker ，這個 carMaker 儲存了 facotry 回傳的值。通常開發者會感到困惑的地方是為什麼 brand 還會存在，不是說 function 一旦執行結束就後就會不見嗎？那為什麼 brand 還會在。 然而如果我們來仔細看看關於執行環境的部分我們會看到 123456789101112131415161718// Global Contextglobal.VO = &#123; factory: pointer to factory(), carMaker: 是 global.VO.factory 的回傳值 scopeChain: [global.VO]&#125;// Factory 執行環境factory.VO = &#123; car: pointer to car(), brand: 'BMW', scopeChain: [factory.VO, global.VO]&#125;// car 執行環境car.VO = &#123; scopeChain = [car.VO, factory.VO, global.VO]&#125; 現在我們先看到當呼叫 carMaker() 的時候，實際上我們拿到 factory 回傳的值，這個回傳值回傳一個指向 car() 的指標，接著當我們進入 car 內部執行的時候這個 scope chain 是 [car.VO, factory.VO, global.VO] 現在呢需要 brand 這個變數的值所以會先找自己的 car.VO 找不到再往下找 factory.VO 就可以找到了。 從另一個角度來看其實就是雖然 function factory 本身的實例執行完後就消失了，可是因為 VO 還被參考，所以 GC 不會將其回收。 說到這邊我們已經深入的解釋完關於 scope chain ，lexical scoping 以及關於 colsures 和變數之間是如何運作的了。剩下的文章我們將來看看一些牽扯到上面議題的有趣情況 prototype chain 如何影響變數解析Javascript 幾乎所有東西都使用 prototype 的方式來實作繼承，除了 null, undefined。當我們試圖存取一個物件的屬性時，直譯器會試著解析在物件實例中的屬性，那如果找不到他就會繼續找 prototype chain，直到找到屬性或者檢索完畢整個 chain 所記錄的關聯。 那麼第一個有趣的問題來了，直譯器在解析一個屬性的時候到底是用 scope chain 還是 prototype chain？ 答案是都會用。當試著解析一個屬性或者識別的時候，scope chain 會先被用來找尋物件的所在，當物件被找到的時候接著就用該物件的 prototype chain 來找屬性名稱。 下面我們用兩段程式碼來解釋整個流程 12345678910var bar = &#123;&#125;function foo() &#123; bar.a = \"Set from foo()\"; return function inner() &#123; alert(bar.a); &#125;&#125;foo()(); // 'Set from foo()' 首先是 bar.a = &quot;Set from foo()&quot;; 這一行建立全域物件 bar 的 a 屬性。直譯器會到 scope chain 找尋 bar.a 並預期會在 global context 找到它。 現在換另外一個範例 1234567891011var bar = &#123;&#125;;function foo() &#123; Object.prototype.a = \"Set from prototype\"; return function inner() &#123; alert(bar.a); &#125;&#125;foo()(); // 'Set from prototype()' 在執行時期，當 inner() 被呼叫的時候會先試圖在 scope chain 裡面解析 bar.a，而 bar 的實例，會在 global context 被找到 bar 然後搜尋 bar 裡面的屬性 a，然而 a 並沒有被設定在 bar 裡面，所以直譯器的下一步會檢索物件的 prototype chain 然後在 Object.prototype 裡面找到 a 上面的過程就是整個識別解析的流程，先在 scope chain 找到物件然後查看 prototype chain 直到屬性被找到為止否則就回傳 undefined 何時該使用閉包閉包是一個非常強大的概念，通常我們會在某些情況下使用 封裝這讓我們可以將一些不想外露的細節封裝在執行環境中，只露出想要 public 的部分。例如： 1234567891011121314151617var classicModulePattern = function()&#123; var privateVariable = 1; function privateFunction()&#123; alert('private'); &#125; return &#123; publicVariable:2, publicFunction:function()&#123; classicModulePattern.anotherPublicFunction(); &#125;, anotherPublicFunction:function()&#123; privateFunction(); &#125; &#125;&#125;();classicModulePattern.publicFunction(); Callbacks 回呼callback 可能我們最常用的一種閉包，典型瀏覽器中通常是採用單執行緒的 Event Loop，正常情況下，一個事件完成才會執行下一個事件。callback 讓我們能夠延遲函式的調用，非同步風格的寫法，我們常常用在回應當一個事件完成的時候。舉例來說當你對伺服器呼叫一個 AJAX ，我們通常會使用 callback 來處理伺服器回應的部分。 閉包參數我們也可以把一個閉包當作參數傳進 function 中，舉個例子我們透過傳入不同的閉包參數就可以完成不同的排列處理 何時不該使用閉包？雖然閉包很好用但因為效能的因素您還是應該謹慎使用 過多的作用域多個巢狀 function 是一個典型的狀況。記住每一個當你需要取得一個變數時，scope chain 一定會一層一層檢索，直到找到該物件或值，所以越多層會導致找尋時間變長。 記憶體回收Javascript 具有記憶體回收(Garbage Collection)的機制，指的是開發者不需要處理關於記憶體的議題。不過通常有自動回收機制，因為無法直接控制記憶體的部分容易導致程式記憶體洩漏進而造成效能問題。不同的 JS 引擎實作 GC 的方式明顯有差異，ECMAScript 並沒有定義該如何實作回收記憶體的方式，但為了提高效能與盡可能降低記憶體洩漏的問題大部份的引擎都遵循一樣的宗旨。一般來說記憶體回收處理器會在當物件不再被參考的時候將其釋放 Memory Leak (中文翻成記憶體漏洩)。內部記憶體泄漏指由於疏忽或錯誤造成程式未能釋放已經不再使用的內部記憶體的情況。內部記憶體泄漏並非指內部記憶體在物理上的消失，而是應用程式分配某段內部記憶體後，由於設計錯誤，導致在釋放該段內部記憶體之前就失去了對該段內部記憶體的控制，從而造成了內部記憶體的浪費。更確切的說 Memory Leak 造成的原因是某個被配置(allocated)的記憶體無法再被參考(referenced)，也無法被釋放(released)。那塊被配置的記憶體就無法被系統再使用，所以要看一個程式有否Memory Leak，很簡單的方法就是去看作業系統的實體記憶體使用圖，如果隨著時間增加，記憶體的使用量呈現明顯增加的趨勢，這個程式就極有可能有潛在的Memory Leak問題。 循環引用循環引用是在描述一種狀況，當 A 物件參考到 B，但是 B 物件又參考回 A 物件。針對舊版的 IE 參照一個 DOM 元素常常會造成記憶體洩漏。為什麼？因為在 IE JScript 引擎和 DOM 分別各自有自己的記憶體回收器，所以當從 JS 中參考一個 DOM 元素時，JS 回收器認為這是 DOM 回收器的工作，而 DOM 回收器又把這個任務指給 JS 回收器。結果就是兩個回收器循環引用。上面扯遠了，那這跟閉包有什麼關係。原因是在閉包中很容易寫出循環引用，讓我們來看一個實際的例子 1234567function example() &#123; var el = document.getElementById('el'); el.onclick = function() &#123; this.style.backgroundColor = 'blue'; &#125; // el=null;&#125; 看起來沒有循環參考的問題，但實際上呢？el物件的屬性參考到了一個函式，這函式卻擁有存取el物件的能力。因此循環參考就此形成。要破壞這種記憶體洩漏其實不難，上例程式碼中的 el=null 就可以達成這目的，當然也可以在一開始就不使用 el 變數。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"理解 Javascript 執行環境","slug":"what-is-the-execution-context-in-javascript","date":"2015-04-17T21:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/18/what-is-the-execution-context-in-javascript/","link":"","permalink":"//andyyou.github.io/2015/04/18/what-is-the-execution-context-in-javascript/","excerpt":"Javascript 中的執行環境與堆疊在這篇筆記中我將會深入的探討 JS 底層中的一些觀念，其中最重要的就是執行環境(Execution Context)。當您閱讀完這篇文章後您可能會比較清楚關於直譯器的運作方式，明白為什麼有些 函式 變數 可以在他們被宣告之前就拿來使用，以及這些值是怎麼決定的。","text":"Javascript 中的執行環境與堆疊在這篇筆記中我將會深入的探討 JS 底層中的一些觀念，其中最重要的就是執行環境(Execution Context)。當您閱讀完這篇文章後您可能會比較清楚關於直譯器的運作方式，明白為什麼有些 函式 變數 可以在他們被宣告之前就拿來使用，以及這些值是怎麼決定的。 什麼是執行環境？我們說當 JS 開始執行的時候，這段程式碼必須被執行在下面三種環境之一。 全域 Global：預設當您程式開始執行時的環境 函式：當我們進入一個函式 function 時的環境，也就是開始跑函式內部程式碼的時候 Eval：把一串字串，當作指令來執行時的環境也就是說一段 JS 程式碼只能存在在上面這三種狀態或類型。 讓我們直接來看看程式碼 123456789101112131415161718192021// Global context, JS 最外層的程式碼部分屬於全域var greeting = \"Hi\";function person() &#123; // 從大括號開始到結束進入另外一個執行環境 var _firstName = \"andy\"; var _lastName = \"you\"; function firstName() &#123; // 另外一個執行環境 return _firstName; &#125; function lastName() &#123; // 執行環境 return _lastName; &#125; alert(greeting + firstName() + ' ' + lastName());&#125; 上面這段範例沒什麼特別的，我們就是有了一個全域的執行環境即 global context ，和 3 個 function context，唯一稍微要注意的是 global context只會有一個。其他執行環境都可以存取全域的東西。 當然您可以有多個 function context 每一個 function 執行的時候就會建立一個新的 context ，OK！不管講執行環境或者 context 都好抽象，那我們就先把他們當作是一個 context 物件，那這個 context 物件講白了就是表示一個環境，一個範圍，一個狀態。它會建立一個範圍一個自己特有的領域，任何在 function 裡面宣告的變數或其他東西都不能被外面直接存取。 如果這樣還不能理解，那我們換個角度來想這件事，你把 context 當成是一張記錄表格，當我開始在 global 執行程式碼的時候。任何變數，function 都會被記載 global 表 上，但是當執行到 function 內部的時候，此時會在開出另外一張 function 表 負責記錄 function 內部的變數等等。 不過我個人認為 執行環境 是最貼切的翻譯，當我在全域這個環境時我能夠取得的變數和進到另外一個 function 環境時可能會有不一樣的狀況。 因此在第一小節我們就下個小結論那就是每一段 JS 在運行的時候會根據片段程式碼所在的區塊有其特有的 環境 執行環境的堆疊對於執行環境有了初步的概念之後我們還得知道 - 瀏覽器的 JS 直譯器通常是單執行緒的，意味著一次只能夠做一件事。也就是說當一個事件被執行的時候其他的任務，事件等等就會被丟到執行佇列中。這個東西我們就叫做執行堆疊 我們已經知道當 JS 開始跑的時候一開始會進入 global 執行環境，如果您在 global 環境中呼叫了一個 function A (即： A();)，這個時候就會建立新的 執行環境 然後這個新的執行環境會被放到執行堆疊的最上面，同樣的如果你現在在 function A 裡面又叫了 function B 那麼就又會在建立一個執行環境一樣放到執行堆疊的最上方，瀏覽器永遠會先處理堆疊上最上面的執行環境，一旦執行環境裡面的任務都執行完了那它就會被移掉換下一個 OK 這邊交代得有點亂，我們看到的程式碼的時候通常最小的執行單位就是那一句一句的 statement 語句，一個語句交代了程式該做一件事。這些 statement 都會有自己的環境，也因此我們可以把環境在當作一個上層單位。一個 context 裡面勢必存在一些任務(語句)。就把一個 context 想像成某個任務好了。看看下面的範例可能比較有感覺 1234567(function foo(i) &#123; if (i === 3) &#123; return; &#125; else &#123; foo(++i); &#125;&#125;(0)); 這段程式碼簡單的呼叫自己三次每一次把參數加一，每當 foo 被呼叫的時候新的 執行環境 就被建立，然後當 執行環境 裡面的程式跑完的時候，就從堆疊中把 執行環境 拿掉，把控制權交還給上一個環境一直到回到 global 為止。 關於執行環境有 5 個重點要牢記在心 單執行緒 同步執行 只有一個 global context function context 沒有限制 就算是自己呼叫自己只要 call function 就會建立執行環境 詳解執行環境所以我們現在知道了每一次 call function 的時候就會建立一個新的執行環境，然而在 JS 直譯器內部每次調用一個執行環境都會有兩個階段 建立階段 當 function 被呼叫了但在開始執行內部程式碼之前 建立一個 scope chain 作用域鍊 建立變數，function，和參數 設定 this 的值 執行階段 賦值，設定 function 的參考和解譯執行程式碼 概念上我們可以把一個 執行環境 想像成一個物件，那麼這個物件大概會有三個屬性如下 12345executionContextObject = &#123; scopeChain: &#123; /* 變數物件 + 所有父代執行環境物件的變數物件*/&#125;, variableObject: &#123;/* 函式的參數/引數，內部的變數和函式*/ &#125;, this: &#123;&#125;&#125; Variable Object 變數物件：根據 ECMA-262 的說明，每一個執行環境會有一個與相關連的變數物件，這個物件負責記錄執行環境中定義的變數和函式。 Activation / Variable Object [AO/VO]這一個執行環境物件在 function 被調用的時候建立，不過在實際的 function 被執行之前，這就是上面提到的階段 1 - 建立階段。在這個階段直譯器會建立 executionObject ，透過掃描函式傳入的參數，內部的函式宣告，變數宣告。結果會被記錄在executionObject 的 變數物件 variableObject 中。 這裏我們大致模擬直譯器是如何執行的流程 尋找呼叫 function 的程式碼 在執行 function 之前建立 執行環境 進入 建立階段 初始化 scope chain 建立 variable object： 建立 arguments object 檢查執行環境的參數，初始化參數的名稱，值以及建立參考 掃描 function 的宣告 根據找到的每一個 function 在 variable object 建立，在這邊其實就是建立 function 名稱在記憶體中的參考指標 如果 function 名稱已經存在那麼指標就會被覆寫 掃描執行環境裡的變數 每一個變數的宣告都會被加入 variable object 的屬性中，並且初始化為 undefined，注意在這個階段並不會賦值 如果變數名稱存在就略過，繼續處理下一個變數 判斷決定 this 的值 執行階段 執行程式碼，賦值，一行一行跑 12345678910function foo(i) &#123; var a = 'hello'; var b = function B() &#123; &#125;; function c() &#123; &#125;&#125;foo(22); 此時在建立階段我們就會得到如下的範例 1234567891011121314fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, this: &#123; ... &#125;&#125; 如您所見，在建立階段處理關於定義宣告的部分，此時並不會賦值，所以 function b 並沒有被參考。不過參數是唯一的例外，此時參數的值已經被建立。一旦建立階段完成，剩下的流程就是開始執行階段，當執行階段完成的時候執行環境就會如下 1234567891011121314fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: 'hello', b: pointer to function B() &#125;, this: &#123; ... &#125;&#125; 變數宣告提升您可以找到很多關於定義 Javascript hoisting 的資料，他們通常會解釋這就是一種把宣告提升到其所在區域內頂端的行為，然而這樣並沒有解釋到細節，為什麼會發生這件事，不過呢剛剛您已經知道了關於整個直譯器解意的流程，現在您可以很清楚的明白為什麼會這樣了。 123456789101112(function () &#123; console.log(\"foo: \" + typeof foo); // function pointer console.log(\"bar: \" + typeof bar); // undefined var foo = 'hello', bar = function() &#123; return 'world'; &#125;; function foo() &#123; return 'hello'; &#125;&#125;()); 現在我們可以回答關於上面這段程式碼的一些問題 為什麼我們在宣告之前可以存取 foo 如果我們看看 建立階段 的流程我們可以知道變數在這個時期早就被建立了 Foo 被宣告 2 次，為什麼 foo 是 function 而不是 undefined 或 string？ 即使 foo 宣告了2次，我們知道在建立階段 function 會先被建立。因此變數已經存在了在這個階段 string 不會被賦予 foo 因此在真正執行 function 之前 foo 是會先被建立，等他真正跑完執行階段的時候 foo 才會被覆寫成 ‘hello’ 為什麼 bar 是 undefined ? bar 就只是一個變數，在這個階段並還沒賦值所以就是 undefined 總結下個收斂的結論就是 每一個片段程式碼都會屬於某個執行環境，或者說在開始執行程式碼之前會先建立 執行環境 執行環境比喻來說就像是一個物件負責紀錄這個 環境 下相關的事物 變數 function 等等 從上往下看這個執行環境物件最重要的是 scope chain, variable object, this 這三個屬性 variable object 才是實際上記錄變數，function，arguments 的地方 另外一個重要的點是 scope chain 他負責記錄每個環境之間切換的關聯，例如從 global -&gt; a() 每次開始建立執行環境的時候就會分成兩個階段 開始建立執行環境的時間點是在 function 被呼叫後，實際執行內部程式碼前 建立階段，初始化這個環境，除了 arguments 外其他都只是先定義變數，函式指標，並沒有賦值 執行階段，開始一行一行執行，賦值希望現在您可以更清楚關於 Javascript 如何運行您的程式碼，瞭解執行環境，堆疊可以讓您更清楚您的程式碼在不同狀態下取到的值，如此一來相信您在組織 JS 的時候會有更好的寫法。 參考012","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"CSS 背景圖片排版","slug":"a-primer-to-image","date":"2015-04-09T08:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/09/a-primer-to-image/","link":"","permalink":"//andyyou.github.io/2015/04/09/a-primer-to-image/","excerpt":"使用 CSS 套用背景圖片到元素中可能是您前端設計過程中最常用到的功能。background 有非常豐富的屬性，讓我們可以針對不同的需求做設定。","text":"使用 CSS 套用背景圖片到元素中可能是您前端設計過程中最常用到的功能。background 有非常豐富的屬性，讓我們可以針對不同的需求做設定。 同時一個元素可以具有多張背景圖片。如果您想要套用多張圖片您可以直接在 background-image 屬性值設定，不同圖片路徑之間只要用 , 分開即可。background-position 屬性則是用來指定背景圖片的位置，而這個屬性非常值得深入研究，不同的設定會造成不同的結果，有些效果對您來說可能是沒看過的。 為了確保本文的程式碼和概念清楚單純，我們將只用一張圖片的範例來驗證瞭解每個屬性，不過這些概念同樣適用於多張圖片的情況下。 一個背景圖片被放在一個我們稱之為 background position area 的地方，這個背景座標區域功能就如同其名稱一樣，其中有一個座標系統讓我們可以處理背景圖的定位。 在我們進一步開始探討放置圖片的概念之前，讓我們先快速的在看過一次 CSS box model 以及看看它如何影響元素中背景圖片的位置。 CSS Box Model 區域根據定義在 CSS 中一個元素通常有 3 個區塊，這幾個區塊我們統稱區塊模型，如果您常閱讀英文的文件那麼這邊就是 box ，這幾個區塊分別是 border 區塊, padding 區塊, content 區塊。首先是 border 區塊 這個區塊在元素的最外層包含整個內容加上邊框即 border 本身。 padding 區塊 則是扣除掉 border 後元素內容和內容外圍的空間，沒錯就是您透過 padding 屬性設定的間隙。 最後 content 區塊 就是把元素扣掉 border 和 padding ，實際內容部分。 圖示元素的區塊模型，圖片來源：參考 Codrops CSS 如果您已經知道如何使用 CSS 排版的樣式規則那您可能會問那 margin 呢？margin 在元素的最外圍，包含整個元素，它被用來設定各個元素之間的距離，定義上它不被算在元素內部。 好！當我們給元素設定了 background - 可以是圖片或顏色。背景預設會從 padding 區塊 開始畫，這個行為是可以被改變的，透過使用 background-origin 這個屬性就是用來設定背景從哪邊開始，預設是 padding-box。 為了準確的把背景圖片放到指定的區塊中，這個區塊需要一個座標系統，用來計算座標。接著讓我們更深入的看看座標系統。 注意：如果 background-attachment 屬性設定為 fixed 那麼 background-origin 就會無效。 1background-origin: padding-box|border-box|content-box|initial|inherit; 元素的座標系統預設情況下，CSS 區塊模型的特性是每一個元素都會透過自己的 height 和 width 來建立座標系統。這個座標系統被用來設定元素和其他元素之間的位置關係，同時影響內部子元素與自己的位置關係。 所以在 CSS 中一個 HTML 元素有一個座標系統，但如果是 svg 元素則沒有。這是因為 svg 本身並沒有區塊模型的概念。 在 CSS 裏通常一個元素的起始點會在元素的最左上角，而背景座標區域也同樣屬於區塊模型概念，並且使用這種觀念來擺放圖片，就是從圖片的左上角的點開始。 OK! 因為預設的座標區塊是 padding 區塊，因此我們的背景就會從 padding 區塊的最左上角開始。 意味著當您套用一張背景圖，瀏覽器會先從 padding 最左上角的點開始把圖放進去，然後重複擺放該圖。 例如：您套用了一張背景到元素中且設定了no-repeat，這樣圖片就只會顯示一次，如果您沒設定就會一直重複。 後面我們會繼續討論如何使用 background-position 屬性來調整預設最左上角這個行為。 不過在討論 background-position 之前我們先來驗證 background-origin 使用 background-origin 調整背景擺放的區域與座標系統background-origin 屬性主要是用來改變座標系統的原點藉此調整背景排版的位置，我們有三種值可以用 padding-box, content-box, border-box 直接來看看範例，要小心的是 border-box 其實是有變的不過呢如果您的 border 有設定顏色，那麼會把圖片蓋掉，您可以試著把 border 的 color 弄成半透明驗證。 接著我們就可以使用 background-position 指定背景的位置，我們剩下所有的範例都會採用 padding-box 的設定。 使用 background-position 來設定圖片位置我們已經看過上一節示範預設的圖片位置的起始點和排版的區域是如何運作的。也恩賜預設的 position 的值是 0% 0%。 預設的位置值是採用百分比當作單位。您可以直接設定不同的百分比或者根據 position area 範圍和距離來設定長度 上面圖表示的是設定和邊緣的距離，除了設定百分比和絕對長度之外還有 top, right, left, bottom, 和 center 五個關鍵字能用。就是區分成關鍵字和長度(px)和百分比這三大類。 一個位置的設定方式可以是一個偏移量值(關鍵字,百分比,長度), 兩個偏移量(可以是上面三種值混搭，不過要注意關鍵字的部分前面是橫向 x 軸的所以是 [left | center | right])，這邊要提醒您的是說 background-position: top 25%; 是不正確的，要 background-position: right 25%;，以及四個偏移量，四個偏移量的話就是關鍵字搭配長度。如果兩個值的部分都是關鍵字那順序可以不照語法指定，意思是您可以先放垂直 y 軸的屬性再放 x i.e background: bottom left;下面是語法和一些範例 12345678910111213141516// 語法background-position: 30% 15%, 40% 80%, 10px 10px /* 多張影像用逗號分開*/background-position: length lengthbackground-position: percentage percentagebackground-position: percentagebackground-position: bottom length right lengthbackground-position: left top// 範例background-position: top left;background-position: 50px 30%;background-position: right: 10px bottom 100px;background-position: center centerbackground-position: 10px 20px;background-position: 5em 2em;background-position: 75% 50%; 如果您提供一個值的時候那麼第二個值(偏移量) 123background-position: 10% 50%; /* 10% 是從容器左邊 10% 和圖片從左邊的10%重疊處 */background-position: top; /* 等於 `top center` */background-position: 50px; /* 等於 `50px center` */ 理解百分比的運作 設定上您可以混合任何合法的參數值，例如混搭百分比和長度或者關鍵字，不過要注意的是關鍵字的部分，除非全部都用關鍵字否則順序很重要，注意第一個參數對應水平的偏移量，第二個對應垂直的。 實際上關鍵字是百分比的縮寫，例如 top 等於 0%，bottom 等於 100% 以此類推。 好！接著讓我們開始看看每一種可能的值是如何運作的，這應該是這篇最重要部分，不同的參數類型會產生不同的效果。 絕對位置/長度如何運作當我們指定一個絕對位置的屬性單位(通常是 px)時，您執行的事讓背景圖片根據左上角原點來偏移，換句話說圖片就是根據左上角原點搭配您設定的值來偏移。 看下面的圖片比較容易理解 當然絕對位置的值可以是負數，負數的話就會往反方向移動 百分比是如何運作不同於絕對位置根據原點偏移的概念，百分比會對齊圖片的 X% 的點和容器 X% 的位置。舉例來說 0% 0% 會對其圖片的 0% 0% 位置和元素背景區域的 0% 0% 位置。 一樣我們透過下面圖片來理解 而百分比一樣也可以設定負值。 搭配使用關鍵字指定邊緣在上面的範例我們都是從左邊和上面來計算偏移，這是預設的行為。不過我們可以結合關鍵字來指定邊緣例如： 1background-position: top 1em right 3em; 注意關鍵字要在前面，另外如果指給定三個值 background-position: top 25px right ; 最後一個會變成 0 而設定了無效的值那麼就會使用預設值 0% 0% 例如 background-position: top 25% 尺寸，重複，裁切等等記住，您可以使用多張圖片，如果要對多張圖片設定位置只要使用逗號分隔每一組設定即可。其他如果要控制大小則用 background-size，總而言之有 9 個關於如何控制背景圖的屬性可以使用，一旦您能掌握 position 和 origin 剩下的觀念就相對單純許多。 最後補上一個比較新的屬性的教學 background-blend-mode","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"使用 Javascript 取得元素的座標","slug":"get-an-element-s-position-by-js","date":"2015-04-07T09:31:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/07/get-an-element-s-position-by-js/","link":"","permalink":"//andyyou.github.io/2015/04/07/get-an-element-s-position-by-js/","excerpt":"前言由於使用 Javasript 偵測元素尺寸的方式並不直覺，每個元素有 6 個 DOM 的尺寸的屬性 offsetWidth, offsetHight, clientWidth, clientHeight, scrollWidth, scrollHeight。再加上 offset[Top | Left], scroll[Top | Left], client[Top | Left] 等方向距離的屬性導致這件事變得異常複雜，外加它們都是整數因此在一些操作上會有些誤差。在開始之前對於那些急性子的人我先提供他們一些對於座標屬性的整理，您可以先大略看過這些整理，後面我們將針對一個實際的例子來練習，這些整理應該可以讓一些老手快速的回復記憶，其實就是因為這樣所以我才紀錄了這篇文章。","text":"前言由於使用 Javasript 偵測元素尺寸的方式並不直覺，每個元素有 6 個 DOM 的尺寸的屬性 offsetWidth, offsetHight, clientWidth, clientHeight, scrollWidth, scrollHeight。再加上 offset[Top | Left], scroll[Top | Left], client[Top | Left] 等方向距離的屬性導致這件事變得異常複雜，外加它們都是整數因此在一些操作上會有些誤差。在開始之前對於那些急性子的人我先提供他們一些對於座標屬性的整理，您可以先大略看過這些整理，後面我們將針對一個實際的例子來練習，這些整理應該可以讓一些老手快速的回復記憶，其實就是因為這樣所以我才紀錄了這篇文章。 先附上兩張圖式 CSS Box 為 content-box 時的情況(下面為 HTML DOM 屬性) offsetWidth/offsetHeight: 元素 Box Model 總寬高 (width + padding + border) 在 box-sizing: content-box; 時 width = content area width 範例 不管是否超出父元素限制範圍都是總寬高 clientWidth/clientHeight: 一般情況下即元素 Box Model 可視區的 width + padding 可視區 只針對取值的元素本身，以元素本身的角度出發，意思是當我們限制元素寬高時只有能看見的部分會列入計算，扣掉 scrollbar width 如果有個子元素超過自己的寬高則 clientWidth 和 clientHeight 仍然是 width + padding 範例 scrollWidth/scrollHeight: 整個框內的總寬高 元素本身的 padding + 內部元素寬高， 舉例 (scrollHeight) 會是self_padding + children_margin + children_border + children_padding + children_height 範例 offsetTop/offsetLeft: 定義 elem.offsetTop 為唯讀的屬性，會回傳目前元素與 offsetParent 元素的距離 當 position 為 static (沒設定預設是 static) 時 offsetParent 就會是根節點(root) 或是外層結構中最接近的 table cell 元素。其他有 position 的屬性( fixed, absolute, relative)都會讓被設定的外層元素變成 offsetParent 計算元素和 offsetParent 的距離 =&gt; 從元素本身的 margin + offsetParent 的 padding 當元素 CSS 有 display: none; 時，offsetParent 為 null 範例 clientTop/clientLeft: 單純就是 border 寬度 定義為回傳該方向的 border 寬度，單位用 px 該屬性不包含元素的 padding 或者 margin 用 document.getElementById(&quot;elem&quot;).style.borderTopWidth 這類方法取得一樣的值 scrollTop/scrollLeft: 如果該目標元素沒有 scrollbar 則值為 0 例如: 沒有 y 軸 scrollbar 則 scrollTop = 0 從元素 border 內緣開始計算，scrollTop 與 scrollLeft 是取有捲軸的那個元素捲到哪 按照規定 scrollTop 不會小於 0 但是在 OSX 下的 Chrome 和 Safari 可能會產生負值。 範例 CSS Box 為 border-box 時的情況 offsetWidth/offsetHeight: 由於 border-box 的關係 css 設定的 width 會等於總寬。 注意: 在 border-box 模式下 width 不等於 content area 的寬，而是整個 block (不含 margin) clientWidth/clientHeight: border-box 狀態時算法變成從外面減回去 width - border = content area + padding scrollWidth/scrollHeight: 取得值沒有差異，雖然是往內扣但該有的 padding 還是存在。 offsetTop/offsetLeft: 取得值沒有差異 clientTop/clientLeft: 取得值沒有差異 scrollTop/scrollLeft: 取得值沒有差異 理解 Javascript 與 DOM 座標雖然大部份的開發者對於 CSS 的 Box Model 與排版操作十分熟悉不過當我們想要使用 Javascript 來操作這些位置的時候可能會遇到障礙。問題通常出在如何準確擷取到您要的座標資料，一般來說元素本身的座標(排版位置)都不是您直接定義，而是被父元素的 float, padding, margin, position 等等屬性所影響。極少的情況下才會設定絕對位置的 x, y。 為了能夠精準的控制位置，我們得先知道元素的 x, y 座標。會搞得這麼複雜的原因是因為 HTML DOM API 或 Javascript 並沒有內建的功能來處理這些任務。 在這份簡短的教學中，您會學到如何取得 HTML 元素精準的座標和背後的原理。 我們有一個需求在我們開始寫程式之前讓我們先假設遇到一個需求 - 我們想要取得 HTML 元素確切的 x, y 座標。 一般來說，所有的座標設定的行為都需要一個相對的起始點，通常我們會拿 document 最左上角的點來當對應的起始點。而我們放的位置點則對應到元素的最左上角。 現在問題來了您的 HTML 文件並不是一張 bitmap 或者 canvas。如同前面所提到的 HTML 和 Javascript 並沒有一套內建的機制處理這種情形。所以我們需要參考其他元素的相關設定或樣式來得到這個座標，因為他們通常都是透過一堆 CSS 樣式來排版的。接著讓我們透過一個範例來理解其中是如何運作的，最後我們將融會貫通這些技巧來完成我們的需求。 取得座標的程式碼當我們使用原生 Javascript 要取得 HTML 元素的 x ,y 的座標範例如下 123456789101112function getPosition (element) &#123; var x = 0; var y = 0; // 搭配上面的示意圖可比較輕鬆理解為何要這麼計算 while ( element ) &#123; x += element.offsetLeft - element.scrollLeft + element.clientLeft; y += element.offsetTop - element.scrollLeft + element.clientTop; element = element.offsetParent; &#125; return &#123; x: x, y: y &#125;;&#125; getPosition 這個 function 會取得 HTML 元素在 document 中的位置並回傳一個包含 x, y 的物件。 下面則示範了如何使用 123var elem = document.querySelector('img');var position = getPosition(elem);alert(\"座標: \" + position.x + ', ' + position.y); 上面我們使用了 querySelector 函式來找到我們要的元素，其他原生的函式包含 getElementById, getElementByTagName, getElementByClassName。又或者您可以使用 jQuery 的 $( &quot;.girl&quot; )[ 0 ] 來取得元素的 DOM。 範例運作的狀況為了看看上面這段範例程式碼的效果您可以直接連到 範例 範例中的提示框會告訴我們元素座標，如果您去量測瀏覽器的 viewport 可視區域的左上角到該圖片的左上角會如下得到準確的座標，注意 border 不會算在其中。 我們簡單的示範了最單純的例子但是實務上總不是那麼容易。 背後的原理對大多數的狀況來說一個元素的位置取決於自己的 CSS 樣式，不過更多的部分是受到父元素樣式的影響。這些樣式包含了 padding, margin, border ，同時再加上 position 那事情就變得越來越亂了。 小技巧記得直接用瀏覽記得工具來協助計算 解析取得座標的程式碼對於上面的程式碼您應該有個概略的理解，但實作的時候您必須要精準的理解每個片段才行。現在讓我們來認真看看這些程式碼是怎麽運作的 首先再複習一下剛剛取得座標的程式碼 12345678910111213function getPosition (element) &#123; var x = 0; var y = 0; // 搭配上面的示意圖可比較輕鬆理解為何要這麼計算 while ( element ) &#123; x += element.offsetLeft - element.scrollLeft + element.clientLeft; y += element.offsetTop - element.scrollLeft + element.clientTop; // 這邊有個重點，當父元素被下了 position 屬性之後他就會變成 offsetParent，所以這邊我們用迴圈不斷往上累加。 element = element.offsetParent; &#125; return &#123; x: x, y: y &#125;;&#125; 第一步是 function 的部分 1function getPosition(element) 我們定義了一個 getPosition 函式，有一個參數 element ，如您從剛剛的用法我們把要取得座標的元素(DOM物件)傳進去。 接著我們定義了兩個座標 x, y 並且初始化為 0 12var x = 0;var y = 0; 這兩個變數會被用來儲存 x, y 座標，因為 offset[Top/Left] 取的是該元素和 offsetParent 的距離，當我們沒有使用 position CSS 規則時 offsetParent 會是 root 或 外層結構中離元素最近的 table cell (在 HTML 標準兼容模式中 root 為 body)，另外一旦您對元素設定了 display: none; 那麼 offsetParent 就會回傳 null。 原來 offset[Top | Left] 並不是像我們一開始認為的直接算出到最左上角的距離，是和 offsetParent 的距離。意思是當外層的結構有元素套用了 position: absolute; 或 relative 等等的時候 offsetParent 就換人了，static 則維持預設。 繼續回到我們的程式碼，因為 offsetParent 不會永遠是 root 所以這邊我們用了一個小小的技巧 123456// 現在您懂了為什麼我們要在這邊用 while!!while(element) &#123; x += (element.offsetLeft - element.scrollLeft + element.clientLeft); y += (element.offsetTop - element.scrollTop + element.clientTop); element = element.offsetParent;&#125; 透過 while 先計算丟進來的元素跟 offsetParent 的距離，如果遇到這個元素有參考 offsetParent 我們就用 element = element.offsetParent 往外一層一層加上去直到 root 為止。 讓我們再更深入探討，稍早我曾提到排版會受到 padding, margin, border 影響。單純看這些屬性本身並不複雜但是混在一起使用時那就真的是災難。 Offset 屬性關於 offsetLeft 和 offsetTop 剛剛上面有提過它就是回傳元素和 offsetParent 之間的距離。 舉例來說當父元素設定了 position: absolute; 那麼我們得到的 offset[Top | Left] 就會是從該元素的 margin 再加上 offsetParent 元素的 padding 所以 offsetParent 元素 border 以內的 block 都被計算了，我們上面就是接著利用 while 把外層的這個元素做一樣的動作。一直做到 root 結果就是我們會得到元素到 root 之間的距離 等等！不要忘記 border由於 border 在 CSS Box Model 中歸屬於 block 內部，所以這段 offset 距離中其實並沒有包含元素的 border 我們可以透過 client[Top | Left] 把它加進去，這樣才是我們要的。用 document.getElementById(&quot;elem&quot;).style.borderTopWidth 這種方法取得值等價。 做到這一步幾乎可以處理所有的狀況，不過還有一個萬惡的捲軸。 Scrolling 捲軸的部分如果您設計的 block 可以捲動，一般來說就是父元素限制了寬高且 overflow: auto; ，但內容的寬高卻超過了這個尺寸，此時您的內容的確是在父元素內部，但取得的座標卻不是我們要的 - 從看到的元素左上角到 root 左上角為了取得這個座標於是我們要把 scrollTop 扣掉。直接看圖比較快 最後呢! 回傳 x, y 1return &#123; x: x, y: y &#125;; 進階範例最後我們透過這個進階的範例 將 position, border, margin, padding 混在一起，透過練習請確定您知道每個部分的值是怎麼得到的。 另外我知道這麼多規則很難記住，所以我整理了上面的總結，您可以在忘記的時候對照一下圖片和規則。 補充在 jQuery 中 $(element).offset() 我們取得的是元素到 document 之間的距離( 自己的 margin 到 document)。但是當元素設定 position: fixed 時取得的值可能不正確。因為當 document 大於 viewport ，就是內容很長，當你捲到底下的時候 fixed 的元素取到的 offset() 會大於你所期待的值。 此時如果要取 fixed element 相對於 viewport 的位置則用 1$(\"#el\").offset().top - $(document).scrollTop(); 參考StackOverflowGet an Element’s Position Using JavaScript","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"如何將 Azure 帳號或擁有的專案轉給另一個使用者","slug":"how-to-transfer-ownership-to-another","date":"2015-04-07T02:46:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/07/how-to-transfer-ownership-to-another/","link":"","permalink":"//andyyou.github.io/2015/04/07/how-to-transfer-ownership-to-another/","excerpt":"有些時候，我們會需要將一些權限或者帳單轉交給其他負責人或者公司。為了處理這個問題，你需要提交一個帳務類型的支援回報給 Microsoft。","text":"有些時候，我們會需要將一些權限或者帳單轉交給其他負責人或者公司。為了處理這個問題，你需要提交一個帳務類型的支援回報給 Microsoft。 提交一個 Azure 帳號移轉的支援請求(Support ticket) 連到Azure Support 或Azure 支援中文 然後點擊 取得支援(Get support) 接著您就可以送出一個事件給 Azure 帳務中心。 如果您已經在 Azure 管理介面時可以點您的帳號選下 -&gt; 下拉式選單 -&gt; 聯絡 Microsoft 支援服務 注意只有帳號的最高權限有這個存取權限。 在 建立支援票證 介面填入您的資料 支援類型選擇 帳務(Billing) 選擇語系接著建立支援服務 問題類型選擇 帳戶、訂閱和帳戶入口網站協助(Account, Subscription and Account Portal Assistance) 選擇 移轉我的帳戶、訂閱或資料(Transfer my account, subscription or data) 確認聯絡資料 填寫問題需求 勾選同意之後送出 最後您就可以在管理這邊追蹤進度。 2015-04-07 更新","categories":[{"name":"Cloud","slug":"Cloud","permalink":"//andyyou.github.io/categories/Cloud/"}],"tags":[{"name":"azure","slug":"azure","permalink":"//andyyou.github.io/tags/azure/"}],"keywords":[{"name":"Cloud","slug":"Cloud","permalink":"//andyyou.github.io/categories/Cloud/"}]},{"title":"Psql 學習記錄","slug":"psql-notes","date":"2015-04-06T12:18:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/06/psql-notes/","link":"","permalink":"//andyyou.github.io/2015/04/06/psql-notes/","excerpt":"何謂 psqlpsql 是讓我們可以操作 Postgres SQL 的指令介面。其包含著一大票的參數設定，不過這篇記錄只會紀錄我工作時比較常用到的部分 OK! 首先是當我們安裝好 Postgres 之後怎麼連線","text":"何謂 psqlpsql 是讓我們可以操作 Postgres SQL 的指令介面。其包含著一大票的參數設定，不過這篇記錄只會紀錄我工作時比較常用到的部分 OK! 首先是當我們安裝好 Postgres 之後怎麼連線 連線 -h 代表要連線的 host，以本機來說就是 localhost -U 要登入的帳號 使用 –username 等價 -W 登入帳號的密碼 使用 –password 等價 -w 不使用密碼 -p PORT 號 –port 等價 (預設: 5432) -d 資料庫名稱 –dbname= 等價 小提醒：縮寫的參數後的值只需要隔一個空白則可，但全名(–dbname, –username) 可以加上 = 或不加。但縮寫不可以加上 = 1234$ psql -h localhost -U andyyou database_name# 完整版psql \"dbname=your_dbname host=your_host user=andyyou password=12345678 port=5432 sslmode=require\" 如果您想使用 GUI 的話 PGCommander 可能是目前最好用的工具。不過這邊我們希望把指令學起來，如此當下次需要在遠端伺服器執行任務時就可以派上用場。 登入後確認當前使用者1$ select current_user; 離開123$ \\q# 或者 CTRL + d 求助如果記不住指令的時候只要記得下 --help 參數即可 123456# 指令介面下$ psql --help# 已經登入 postgres 之後$ \\?$ \\help 操作資料庫一般來說只要記住 \\? 進到指令介面在查要用的指令即可。不過這邊還是把我常用的列出來 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 修改密碼$ alter user user_name with password 'new_password';# 列出所有資料庫$ \\l# 列出所有 Tables$ \\d# 顯示表格資訊$ \\d table_name# 列出 table schema$ \\d+ [tablename]# 列出使用者SELECT * FROM \"pg_user\";# 列出所有角色 + 權限$ \\du# 列出該 db schema 與角色的權限$ \\dn+# 列出當前使用者SELECT current_user;# 授權$ grant all on schema public to public;# 移除 db (OSX)$ rm /usr/local/var/postgres/postmaster.pid$ dropdb rbase_test# 在 SQL 中移除 db$ drop database if exists [database name]# 列出 Table/View 權限$ \\dp# 建立使用者$ CREATE USER andy with password 'p@ssw0rd';$ createuser test --interactive -P # 含建立密碼 + 權限# 連線資料庫/切換資料庫$ \\c database# 建立新資料庫$ CREATE DATABASE mydb;# 刪除 tableDROP TABLE IF EXISTS table;# 建立 table 範例CREATE TABLE films ( code char(5) CONSTRAINT firstkey PRIMARY KEY, title varchar(40) NOT NULL, did integer NOT NULL, date_prod date, kind varchar(10), len interval hour to minute);# 插入資料INSERT INTO films VALUES('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');INSERT INTO films (code, title, did, date_prod, kind)VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama'),('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');# 備份 / 還原 使用 Dump# 備份$ pg_dump dbname &gt; outfile$ pg_dump dbname | gzip &gt; filename.gz# 還原$ psql dbname &lt; infile$ createdb dbname &amp;&amp; gunzip -c filename.gz | psql dbname# 更新$ update auth_user set is_superuser = 't' where username='abhiomkar';# 顯示所有 roles 名稱(SQL)$ select rolname from pg_roles;# 查看 table 權限$ \\z# 移除 db (OSX)$ rm /usr/local/var/postgres/postmaster.pid$ dropdb rbase_test pg_hba.conf 在哪裡？/var/lib/pgsql/data/pg_hba.conf (Linux 預設路徑)/usr/local/var/postgres/pg_hba.conf (OSX 預設路徑) 善用 find 指令 查詢檔案名稱 1$ find / -name 'pg_hba.conf' 查詢檔案名稱 (不區分大小寫) 1$ find / -iname 'pg_hba.conf' 查詢檔案名稱 (指定目錄) 1$ find /usr -name 'pg_hba.conf' 只搜尋檔案 1$ find /usr -name 'pg_hba.conf' -type f 只搜尋目錄 1$ find /usr -name 'postgres' -type d 忘記密碼的解法1. 找到 pg_hba.conf2. 備份一份起來3. 修改設定1local all all trust 4. 重啟一般在 OSX 下我習慣都用 brew 可以多裝一套 brew services 123$ brew services start postgresql$ brew services restart postgresql$ brew services stop postgresql 5. 現在任何 User 登可以登入了1$ psql -U postgres 6. 重設定密碼1$ ALTER USER user_name with password 'new_password'; 7. 換回原來設定8. 重啟無法刪除 dbDETAIL: There is 1 other session using the database. 麻煩請找找是否有 GUI 軟體或其他 Session 正在連線。 無法連線的狀況錯誤訊息 123psql: could not connect to server: Connection refused Is the server running locally and accepting connections on Unix domain socket &quot;/tmp/.s.PGSQL.5432&quot;? OSX 環境下解法 1$ rm /usr/local/var/postgres/postmaster.pid","categories":[{"name":"Database","slug":"Database","permalink":"//andyyou.github.io/categories/Database/"}],"tags":[{"name":"postgresql","slug":"postgresql","permalink":"//andyyou.github.io/tags/postgresql/"}],"keywords":[{"name":"Database","slug":"Database","permalink":"//andyyou.github.io/categories/Database/"}]},{"title":"rake db 常用指令備註","slug":"rake-t","date":"2015-04-05T21:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/06/rake-t/","link":"","permalink":"//andyyou.github.io/2015/04/06/rake-t/","excerpt":"","text":"123456789101112$ rake db:create # Create the database from DATABASE_URL or config/database.yml for the current Rails.env (use db:create:all to create all dbs in the config)$ rake db:drop # Drops the database using DATABASE_URL or the current Rails.env (use db:drop:all to drop all databases)$ rake db:fixtures:load # Load fixtures into the current environment's database$ rake db:migrate # Migrate the database (options: VERSION=x, VERBOSE=false)$ rake db:migrate:status # Display status of migrations$ rake db:rollback # Rolls the schema back to the previous version (specify steps w/ STEP=n)$ rake db:schema:dump # Create a db/schema.rb file that can be portably used against any DB supported by AR$ rake db:schema:load # Load a schema.rb file into the database$ rake db:seed # Load the seed data from db/seeds.rb$ rake db:setup # Create the database, load the schema, and initialize with the seed data (use db:reset to also drop the db first)$ rake db:structure:dump # Dump the database structure to db/structure.sql$ rake db:version # Retrieves the current schema version number","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Jekyll - Psych::Nodes (NameError)","slug":"fix-jekyll-psych-issue","date":"2015-04-04T06:49:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/fix-jekyll-psych-issue/","link":"","permalink":"//andyyou.github.io/2015/04/04/fix-jekyll-psych-issue/","excerpt":"Jekyll 遇到 uninitialized constant Psych::Nodes (NameError)當 jekyll 的環境遇到 Ruby 2.1.x Psych 2.0.10 會出現不相容問題，所以請","text":"Jekyll 遇到 uninitialized constant Psych::Nodes (NameError)當 jekyll 的環境遇到 Ruby 2.1.x Psych 2.0.10 會出現不相容問題，所以請 1$ gem uninstall psych 參考","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"//andyyou.github.io/tags/jekyll/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Devise 快速上手","slug":"devise","date":"2015-04-04T04:05:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/devise/","link":"","permalink":"//andyyou.github.io/2015/04/04/devise/","excerpt":"devise 使用筆記Devise 是一套彈性的驗證機制解決方案，它是根據 Warden 為架構的基礎延伸的。Devise 本身具備 支援 rake 架構在 Rails 之上提供完整的 MVC 方案 提供您可以使用多個 Model 在同一時間登入 模組化，您只需要採用您需要的部份","text":"devise 使用筆記Devise 是一套彈性的驗證機制解決方案，它是根據 Warden 為架構的基礎延伸的。Devise 本身具備 支援 rake 架構在 Rails 之上提供完整的 MVC 方案 提供您可以使用多個 Model 在同一時間登入 模組化，您只需要採用您需要的部份 整體是由 10 個模組組成 Database Authenticatable 加密並儲存密碼於資料用以驗證使用者身份。驗證機制可以透過 POST 或者 HTTP 基本的驗證方式 Omniauthable 加入 OmniAuth(https://github.com/intridea/omniauth) 的支援 Confirmable 寄送 Email 與確認機制驗證帳號是否正確與啟用 Recoverable 重設密碼與寄送 Reset 信件 Registerable 處理註冊流程包含帳號本身的編輯與刪除 Rememberable 管理 Token 的產生與清除，這些資訊會被存在使用端的 cookie Trackable 追蹤紀錄登入的次數，時間與 IP Validatable 提供信箱和密碼的驗證機制。此部分並沒有強制使用且可以根據不同的情況客製，您可以自行定義您的驗證機制 Lockable 提供鎖定機制，當帳號不斷登入失敗時會啟用。同時提供 Email 解鎖的機制 Devise 確保能夠在 YARV, JRuby 環境下執行緒安全(Thread-Safe)，簡單的說即在多執行緒的情況下確保變數(通常是全域變數)是正確一致的。 資訊Devise wikiDevise wiki 提供許多關於 Devise 的資料包含 how-to 的文章以及常見問題的答案。當您完成這個 README 文件的閱讀後請記得瀏覽 wiki Bug 回報如果您發現問題，我們希望您能告知我們。然後我們希望當您想要回報時可以遵循一些規範如果您發現關於安全問題的 bug ，請不要使用 Github 上面的 Issue 回報，請直接發 Mail 到 opensource@plataformatec.com.br 郵件列表如果您有任何問題，意見或疑慮，請使用 Google Group 告知我們而不是在 Github 上面開 Issues https://groups.google.com/group/plataformatec-devise RDocs當然您可以查閱 RDoc 格式的 Devise 文件在下面連結 http://rubydoc.info/github/plataformatec/devise/master/frames 如果您需要使用舊版的 Rails 搭配 Devise 您可以在指令介面執行 gem server 來存取舊版的文件。 程式範例這邊有一些程式範例放在 Github 上面，它們展示了 Devise 各種不一樣的功能同時也有搭配不同版本 Rails 的範例，如下面連結 https://github.com/plataformatec/devise/wiki/Example-Applications 套件我們的社群已經建立了很多的擴展套件，它們可以幫您加上其他的功能，您可以參考下面連結根據您的需求使用 https://github.com/plataformatec/devise/wiki/Extensions 貢獻我們希望您可以考慮協作 Devise。如果要執行測試，請進入 Devise 的頂層目錄並執行 bundle install -&gt; rake 為了通過這些測試您會需要使用 MongoDB Server 與 Rails 整合如果您是第一次建立 Rails 應用程式我們建議您不要使用 Devise。Devise 需要您對於 Rails Framework 有足夠的了解。如果是這種情況我們建議您先使用一些簡單的驗證機制 Michael Hartl’s online book Ryan Bates’ Railscast 一旦您對於 Rails 和驗證機制有充足的認識，我們保證 Devise 將會讓您開發更便捷。 入門Devise 3.0 需搭配 Rails 3.2 以上版本。您可以先在 Gemfile 加入: 1gem 'devise' 接著執行 bundle install 安裝它。在完成安裝之後，您需要執行 generator 來自動安裝和變更一些設定 1$ rails genereate devise:install 這個 generator 會安裝一個 initializer 其內容是用來描述所有 devise 的設定。通常您需要查看一下這隻檔案 config/initializers/devise.rb在您完成這個步驟之後您已經可以使用 generator 將 devise 加入到任何 model 1$ rails generate devise MODEL 將 MODEL 的地方取代成您要的 model name ，這個 model 在程式中代表使用者(通常我們使用 User 或者 Admin)。一旦執行該指令會產生一個 model (請確保 model 不重複)以及設定其為預設的 devise 模組。注意：這個指令同時也會設定您的 config/routes.rb 檔案，幫您把路由指定到 devise controller 接著我們檢查 MODEL 看看是否要增加其他的設定，您可能會想要加入像是 confirmable 或 lockable 的功能。如果您開啟這個選項，請記得到 migration 檔案檢查欄位設定，去把適當的屬性註解拿掉，因為 migration 才是實際調整資料庫的地方。舉例來說如果您在 model 中加入 :confirmable 支援那麼就需要去把 migration 中跟 confirmable 相關的部分註解也拿掉。接著執行 rake db:migrate 下一步您需要設定預設的 URL 給 devise 的 mailer 使用，下面提供一個範例設定 1config.action_mailer.default_url_options = &#123; host: 'localhost', port: 3000 &#125; 在完成修改之後需要重啟應用程式，否則您將會看到錯誤訊息。 Controller filters 和 helpersdevise 會幫我們建立一些 helpers 讓我們可以在 controller 和 view 裡面使用。例如要設定一個 controller 需要驗證，只要在 before_action (例如您的 model 叫作 User)加入 12# 限制 controller 的使用權限before_action :authenticate_user! 如果您的 devise model 是其他名稱則把 _user 的部分換掉，例如 model 叫 admin 則換成 authenticate_admin! 下面的 helper 都是以此類推。 12345678# 判斷是否登入user_signed_in?# 取得當前使用者current_user# 存取 sessionuser_session 當使用者執行了登入，啟用帳號，更新密碼之後，devise 會找尋 scope 內的 root_path。具體舉例來說當我們使用了 :user 的 resources就會去找 user_root_path 如果存在就會用它，否則預設會去找 root_path，意思是我們至少需要設定 root_path 12345root to: \"home#index\"namespace :user do root to: 'home#index' # 路徑會是 /user/home#indexend 您也可以覆寫 after_sign_in_path_for 和 after_sign_out_path_for 到您自訂的 redirect_to 程式碼片段 注意如果您的 devise model 叫 Member 而不是 User 的話，那麼 helpers 會完全不一樣 1234before_action :authenticate_member!member_singned_in?current_membermember_session 設定 Model關於 devise model 內的方法(method) 也允許我們做一些額外的設定，例如您可以選擇加密的演算法 123class User &lt; ActiveRecord::Base devise :database_authenticatable, :registerable, :confirmable, :recoverable, stretches: 20end 除了 :stretches，您還可以定義 :pepper, :encryptor, :confirm_within, :remember_for, :timeout_in, :unlock_in想取得更詳細的資料可以看 initializer 檔案，這隻檔案就是我們執行 rails generate devise:install 時產生的。這隻檔案預設在 config/initializers/devise.rb Strong Parameters 核可參數核可參數提供了一個介面來防止使用者亂送參數，阻止送 Action Controller 的參數被用在 Model 中，除非參數被加到白名單，此外參數也可以被註記為 required 必須。 當您客製化了您的 view，最終您可能要加入新的屬性(attributes)到您的 form。Rails 4 把參數的防護措施從 Model 移到了 Controller，造成 devise 也把處理機制換到了 controller 在 devise 只有三個 action 允許您設定參數是否允許通過傳到 model，這是因為必要的防護機制。它們的名稱和 permitted parameters 允許參數預設值如下 sign_in(Devise::SessionsController#create) - 只允許驗證 key 通過(如 email) sign_up(Devise::RegistrationsController#create) - key 和 password, password_confirmation 三個 account_update(Devise::RegistrationsController#update) - key, password, password_confirmation, current_password 根據您想要放行額外的參數您可以簡單的在 ApplicationController 的 before_action 123456789class ApplicationController &lt; ActionController::Base before_action :configure_permitted_parameters, if: :devise_controller? protected def configure_permitted_parameters devise_parameter_sanitizer.for(:sign_up) &lt;&lt; :username endend 上面這段範例可以協助您增加額外的欄位。如果您需要的是巢狀的屬性(物件)換句話說您正使用 accepts_nested_attributes_for ，這樣的話您就需要告訴 devise 關於這個物件的資訊，devise 讓您可以透過一個 block 來修改預設值 123def configure_permitted_parameters devise_parameter_sanitizer.for(:sign_in) &#123; |u| u.permit(:username, :email) &#125;end 如果您在註冊的時候有一些 checkbox 用來表示使用者的權限(角色)，瀏覽器會把勾選的 checkbox 值當成一個陣列傳入。一個陣列並不屬於核可參數這種情況的話我們可以照下面這樣做 123def configure_permitted_parameters devise_parameter_sanitizer.for(:sign_up) &#123; | u | u.permit(&#123; roles: []&#125;, :email, :password, :password_confirmation)&#125;end 要查詢所有允許的準則和如何宣告內嵌物件和陣列的 permitted keys 請查閱https://github.com/rails/strong_parameters#nested-parameters 另外如果您有多個 devise model 您可能想要針對每個 model 設定不同的防護機制，這種情況下我們建議您直接繼承 Devise::ParameterSanitizer 12345class User::ParameterSanitizer &lt; Devise::ParameterSanitizer def sign_in default_params.permit(:username, :email) endend 然後直接在 controller 內直接使用 1234567891011class ApplicationController &lt; ActionController::Base protected def devise_parameter_sanitizer if resource_class == User User::ParameterSanitizer.new(User, :user, params) else super # Use the default one end endend 上面這個範例覆寫了 User model 允許的參數，這樣 :username 和 :email 都會放行。 設定 views官方建立了 devise 來協助您快速的開發讓您的程式具有驗證機制，然而並不是所有的狀況都剛好適用預設值，您可能會希望客製一些東西。因為 devise 屬於一個引擎，所有的 view 都被打包在 gem 內部。這些 view 可以幫助您快速的開始，不過隨後您可能會希望修改它們，在這種情況下您可以調用下面的指令把 view 從 gem 複製出來 1$ rails generate devise:views 如果您有超過一個的 devise model (例如 User 和 Admin) 您會注意到 devise 所有 model 都使用相同的 view ，幸運的是 devise 提供一個簡單的方法來自訂這些 views您只需要在 config/initializers/devise.rb 中設定 config.scoped_views = true 之後您就可以根據角色如 users/sessions/new, admins/sessions/new 提供不同的 views。如果在 scope 找不到 view，devise 會使用預設在 devise/sessions/new 的 view。 或者您可以使用 generator 來產生 1$ rails g devise:views users 如果您想要只產生部分的 views 例如 registerable 和 confirmable 模組，您可以傳入參數 -v 1$ rails g devise:views -v registrations confirmations 設定 controller如果客製 view 的層級還不夠您使用，您甚至可以自訂 controller 如下 1. 建立您的 controller1$ rails generate devise:controller [scope] 如果您設定 users 來當作 scope 那麼 controllers 將會被建立在 app/controllers/users/ 目錄下，而這些 session controller 會如下 1234567class Users::SessionsController &lt; Devise::SessionsController # GET /resource/sign_in # def new # super # end ... end 2. 設定 routes1devise_for :users, controllers: &#123; sessions: \"users/sessions\" &#125; 3. 從 devise/sessions 複製 views 到 users/sessions。因為 controller 已經被修改了，所以沒辦法使用預設的 devise/sessions 的 view4. 最後，修改 controller 的 actions12345class Users::SessionsController &lt; Devise::SessionsController def create # custom sign-in code endend 或者您也可以簡單呼叫父類別的行為 1234567class Users::SessionsController &lt; Devise::SessionsController def create super do |resource| BackgroundWorker.trigger(resource) end end end 注意 devise 會使用 flash message 來讓使用者知道操作的結果。devise 預設您的程式會呼叫 flash[:notice] 和 flash[:alert] 設定路由devise 也提供預設的路由。如果您需要自訂他們，您可以透過 devise_for 方法。它提供了一些參數像是 class_name, path_prefix 等等 1devise_for :users, path: \"auth\", path_names: &#123; sign_in: 'login', sign_out: 'logout', password: 'secret', confirmation: 'verification', unlock: 'unblock', registration: 'register', sign_up: 'cmon_let_me_in' &#125; 您可能會需要根據 i18n 修改路徑 您可以再參考文件來瞭解更多關於 devise_for 的用法 如果您有需要在做更多的設定例如除了 /users/sign_in 還允許 /sign_in 可以做登入的動作，您只需要建立一個路由 123devise_scope :user do get \"sign_in\", to: \"devise/sessions#new\"end 這樣一來您就多了一個 /sign_in 可以存取了 I18ndevise 在 flash messages 使用了 i18n ，即您在 flash[:notice] 和 flash[:alert] 中的訊息是多國語系的，如果要針對訊息客製您可以在 local file 定義 1234en: devise: sessions: signed_in: 'Signed in successfully.' 您也可以根據 resources 區分不同的訊息，注意 scope 是單數 1234567en: devise: sessions: user: signed_in: 'Welcome user, you are signed in.' admin: signed_in: 'Hello admin!' devise mailer 使用簡單的格式來建立標題訊息 12345678en: devise: mailer: confirmation_instructions: subject: 'Hello everybody!' user_subject: 'Hello User! Please confirm your email' reset_password_instructions: subject: 'Reset instructions' OmniAuthdevise 同時支援 OmniAuth 讓您可以使用一些外部的驗證機制，要使用它們只需要把 config/initializers/devise.rb 的設定註解拿掉即可 1config.omniauth :github, 'APP_ID', 'APP_SECRET', scope: 'user,public_repo'","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"},{"name":"devise","slug":"devise","permalink":"//andyyou.github.io/tags/devise/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Carrier Wave 使用筆記","slug":"carrier-wave","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/carrier-wave/","link":"","permalink":"//andyyou.github.io/2015/04/04/carrier-wave/","excerpt":"Carrier Wave這套 gem 提供一個簡單且非常彈性的方式來協助 Ruby 程式上傳圖片，同時也能夠跟 Rake base 的程式整合的很好 e.g. Ruby on Rails","text":"Carrier Wave這套 gem 提供一個簡單且非常彈性的方式來協助 Ruby 程式上傳圖片，同時也能夠跟 Rake base 的程式整合的很好 e.g. Ruby on Rails 安裝 gem 12gem &apos;carrierwave&apos;&gt; bundle install 建立 uploader 1&gt; rails g uploader Avatar 範例我們加開一個 User 12&gt; rails g model User name bio:text&gt; rake db:migrate 針對已經存在的物件我們加入關聯 12&gt; rails g migration AddAvatarToUsers avatar:string&gt; rake db:migrate 調整 User Model 讓 User 可以取得 carrierwave 處理好的資訊 123class User &lt; ActiveRecord::Base mount_uploader :avatar, AvatarUploaderend 處理 View 123456&lt;%= form_for @user, :html =&gt; &#123;:multipart =&gt; true&#125; do |f| %&gt; &lt;p&gt; &lt;%= f.file_field :avatar %&gt; &lt;%= f.hidden_field :avatar_cache %&gt; &lt;/p&gt;&lt;% end %&gt; 注意 :html =&gt; {:multipart =&gt; true} 要加，還有 controller 中的 permit 要放行。e.g params.require(:user).permit(:name, :bio, :avatar, :avatar_cache) 接下來在 view 中就可以使用 &lt;%= image_tag(@user.avatar_url) %&gt;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"},{"name":"carrier wave","slug":"carrier-wave","permalink":"//andyyou.github.io/tags/carrier-wave/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"ActionPack 雜記","slug":"action-pack-note","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/action-pack-note/","link":"","permalink":"//andyyou.github.io/2015/04/04/action-pack-note/","excerpt":"Action PackAction Pack 是整個 Rails 的核心部份，由 ActionDispatch, ActionController, ActionView 組成ActionDispatch 處理接收到的請求(Requests)，即網址的部分，ActionController 負責把請求對應轉換成回應(Responses)接著 ActionController 調用 ActionView 來處理回應的格式(html, js, json, xml) 等","text":"Action PackAction Pack 是整個 Rails 的核心部份，由 ActionDispatch, ActionController, ActionView 組成ActionDispatch 處理接收到的請求(Requests)，即網址的部分，ActionController 負責把請求對應轉換成回應(Responses)接著 ActionController 調用 ActionView 來處理回應的格式(html, js, json, xml) 等 通常 ActiveRecord 比較常會被獨立使用，而 ActionPack 通常我們會透過 Rails 整合在一起使用。 路由在 Rails 路由通常分成2大類 comprehensive, resources ，通用型的路由就是讓你指定 [http verb] [mapping url] [controller#action]具體的流程是當 Server 透過網址取得請求，此時 Rails 會透過 Action Dispatch 去處理網址判斷該對應到哪個 controller 和 action 並把 parameter 帶進去 123Sample::Application.routes.draw do resources :products # Resources 會產生 7 組路由end 上面的範例 Rails 會先假設您有一個 ProductsController 1resources :people, except: [:update, :destroy] 12345678910111213141516171819202122232425262728293031323334def index @products = Product.allenddef show @product = Product.find(params[:id])enddef new @product = Product.newenddef create @product = Product.new(prarms.require(:product).premit(:title, :description, :image_url, :price)) respond_to do |format| if @product.save format.html &#123; redirect_to @product, notice: \"Product was successfully created\" &#125; format.json &#123; render action: 'show', status: :created, location: @product&#125; else format.html &#123; render action: 'new' &#125; format.json &#123; render json: @product.errors, status: :unprocessable_entity &#125; end endenddef editenddef updateenddef destroyend 共用 route12345concern :reviewable do resources :reviewsendresources :products, concern: :reviewable 路由得設法123456789root :to =&gt; 'welcome#index'root to: 'controller#action'match 'messages/show', to: 'messages#show', :via =&gt; 'get'match 'messages/show' =&gt; 'messages#show', via: [:get, :post]get 'messages/show' =&gt; 'messages#show'# 省略的寫法match 'messages/show' # 相等於 match 'messages/show' =&gt; 'messages#show'match 'messages' =&gt; 'messages#index', :as =&gt; 'index'match \"/messages/show/:id\" =&gt; \"messages#show\", :constraints =&gt; &#123;:id =&gt; /\\d/&#125; # 限制參數","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Compass 使用筆記","slug":"compass","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/compass/","link":"","permalink":"//andyyou.github.io/2015/04/04/compass/","excerpt":"Compass Note 4 個關鍵的功能 變數, mixin, 繼承, 巢狀 selector sass 透過變數 $ 來減少重複與達到管理樣式的能力，與 less 的 @ 是一樣的 e.g. $variable 透過 mixin 就可以減少重複 selector ，且一般我們如果要追加某種共用樣式可能要多加一個 class 在 sass 中可以透過 mixin 來處理這個問題","text":"Compass Note 4 個關鍵的功能 變數, mixin, 繼承, 巢狀 selector sass 透過變數 $ 來減少重複與達到管理樣式的能力，與 less 的 @ 是一樣的 e.g. $variable 透過 mixin 就可以減少重複 selector ，且一般我們如果要追加某種共用樣式可能要多加一個 class 在 sass 中可以透過 mixin 來處理這個問題 123456789101112ul.horizontal-list &#123; float: left; padding-left: 1em;&#125;#header ul.nav &#123; color: white;&#125;#footer ul.nav &#123; color: black;&#125; 就可以換成 1234567891011121314@mixin horizontal-list &#123; float: left; padding-left: 1em;&#125;#header ul.nav &#123; @include horizontal-list; color: white;&#125;#footer ul.nav &#123; @include horizontal-list; color: black;&#125; mixin 也可以使用參數，把其當作一個 function 來宣告並使用，宣告時用 @mixin 前綴詞，引用時用 @include 透過在 scss 內部加入 @extend 來繼承，繼承的原理就只是把 @extend 的父元素名稱複製一份加到 @extend .list 中的 list 1234567.error &#123; color: red;&#125;.validate-error &#123; @extend: .error;&#125; extend 後面記得是 .class sass 3.2 後有一種 placeholder selector 用 % 就是該 class 是不會輸出的 1234567%base &#123; color: red;&#125;.header &#123; @extend %base;&#125; placeholder selector 的用途是避免多產生多餘的樣式，以免干擾 CSS 如果 placeholder selector 沒有被繼承那麼所有片段程式碼都不會被輸出 簡言之 Compass 是一個 Sass Framework 作用是讓撰寫 Sass 更有效率更快速 就像 Rails 之於 Ruby , Compass 之於 Sass Compass 是由三個主要的部分組成的 mixins, utilities 函式庫 一個和應用程式整合的環境 一個平台用來建置套件和 framework 操作建立專案 1compass create project-name compass 幫你建立了一個 config.rb, sass 目錄, stylesheets 目錄 其中 stylesheets 是用來輸出 css 的地方 compass unpack extension-name 可以把套件解壓縮到專案目錄 extensions/compass stats 查閱目前樣式狀態 @import &quot;compass/reset&quot; 可以載入 Eric Meyer 的 reset.css 而 compass 有把 reset 拆成比較小的 mixin 如: @include reset-body; Grid system 最有名的兩套分別是 Bluepint and 960Grid簡單的說 Grid system 就是透過 columns 和 gutter 來設定欄位和區間，原本你可能需要數學計算分配而透過這些 framework 你只需要指定所佔的欄位數即可。 Compass 支援 Grid system 中的功能把其變成 mixin 於是你就只要在原本具有的語義 class 中 @include 就好如此一來就不需要追加 class Blueprint .container width: 950px column 設定方式為 span-1, span-x 預設共 24 欄 compass 現在已經移除 blueprint 如果要再用需要 gem install compass-blueprint 接著在 config.rb 加入 require &quot;copass-blue&quot; compass 把 blueprint 抽成 mixin 所以只需要在要套用的樣式中 @include column(2) zebra-stripe Table helpers12345678910@import \"compass/reset\";@import \"compass/utilities/tables\";table &#123; $table-color: #666; @include table-scaffolding; @include inner-table-borders(1px, darken($table-color, 40%)); @include outer-table-borders(2px); @include alternating-rows-and-columns($table-color, adjust-hue($table-color, -120deg), #222222);&#125; 載入 css3 函式庫 123456789@import 'compass/css3';.rounded &#123; @include border-radius(5px);&#125;/* 單個圓角 */.rounded-one &#123; @include border-corner-radius(top, left, 5px);&#125; Sass 的變數是有 scope 的 舊版的 Sass 變數採用 ! 不過因為不好看就改成 $ 當宣告完變數之後本身並沒有任何影響，除非你開始套用變數 CSS 的命名規則是只有 _ 和英文字為開頭後面可用一般英數，使用 - 連接時視為單一字的語意 e.g. $dark-color 而不是 $darkcolor 用 `` 則表示兩個單字的語義 在 Sass 中 - 和 _ 是可以互換的 $blue-color 和 $blue_color 都可以指向同一個變數，包含 mixin 和 function 除了變數, mixin, function 之外其他 .class 的地方則不能通用 &amp; 在 nested selector 中代表的是 parent. 所以除了一般 123456789101112/* 除了一般 */.foo &#123; &amp;:hover &#123; color: red; &#125;&#125;&lt;!--也可以--&gt;.foo &#123; .bar &amp; &#123; color: blue; &#125;&#125; selector nesting 還可以用在樣式 1234567891011.nav &#123; border: &#123; color: red; width:1px; style: solid; &#125;&#125;border: 1px solid #ccc &#123; left: 0px; 0pright: 0px;&#125; 在變數後面加上 !default 的意思是如果載入的的檔案中有人先定義了那就不複寫 一般來說在 Sass 中 @import 是說在 compile 時期去把對應的檔案載入一起編譯而不是原來的 CSS import 不過在三種狀況下會使用原來 CSS 的 import 後面接 .css 副檔名 http 的檔案路徑 使用 url() 如果有一隻 CSS 又想要用 sass 的 @import 那就直接把副檔名換成 .scss 在原生 CSS 中所有註解都會顯示但在 sass 中提供一種 silent comments 的機制 // 註解就是 silent comment 一般是不會被輸出的 /*...*/ 則會輸出，不過如果該註解被放在一些地方則不會被輸出 1234body &#123; color /* This won't appear in the CSS */: #333; padding: 1em; /* Nor will this */ 0;&#125; 當需要重複的不再只是單純得值，而是一小段樣式的時候就該使用 mixin 區分何時該用 mixin 何時該用 .class 的區別，通常如果你能夠給一些樣式集一個有意義的名稱且在不同的 .class 中套用那就應該用 mixin e.g. rounded-corner而 .class 是用在 html 裡面的， mixin 適用在 css 裡面的 依照 Sass 的觀念 mixin 用來描述外觀，而 .class 需要有語意 mixin 參數用 , 隔開 12345@mixin link-color($normal, $hover, $visited) &#123; color:$normal; &amp;:hover &#123; color:$hover; &#125; &amp;:visited &#123;color:$visited; &#125;&#125; @include mixin 時參數可以帶名稱和預設值 一直用 mixin 會導致 CSS 越來越大，有效的利用繼承可以減少程式碼 @extend 繼承的功用 1234.disabled &#123; color: gray; @extend a;&#125; 繼承簡單來說就是把被繼承的 selector 複製一份加入繼承元素的 selector group 123456789101112a &#123; color: blue;&#125;.disabled &#123; @extend a;&#125;&lt;!--will turn to --&gt;a, .disabled &#123; color: blue;&#125; @extend 的時候不能指定 .a .b 一次只能指定一個 selector 或 placeholder selector 123456789.a .b &#123; color:red;&#125;.c &#123; @extend .a // 可以 @extend .a.b // 可以 @extend .a .b // 錯誤&#125; 儘量讓 @extend 繼承保持單純不要去 @extend 已經在巢狀內部的 selector 透過 @import 整合成一隻檔案避開傳統 css @import 效能低落的問題 $x: red !default; 預設變數的跟 !important 相反，如果有直就不覆蓋 _ 和 - 可以互相替換，變數, mixin, function 都可以，不過 selector 就不行了 mixin 讓我們可以在 sass 裡面把表現層的語義保留在 sass 內部而不用為了增加外觀樣式追加 .class extend 就是擴展 selector group，盡量不要在多重 nest 中使用 extend ，僅僅在有關係的語義上使用可以避免混亂 Grid system Grid 是從印刷術出現就開始有的近幾年引入 web design 簡單說其目的就是提供統一的欄位與間隔留白讓所有內容遵循規則來達成好閱讀，有設計感的目的 在 web 中 grid 就只是一些簡單的數學除法 用來計算 content 和 container Grid 技術上使用了 3 種東西來設計 column 測量內容的垂直單位, container 容器包含著一個柵格系統, gutter 統一的間距在每個 column 之間 sass 裡面是可以用 for 的用法如下 1234567891011@for $n from 1 to 10 &#123; .span-#&#123;$n&#125; &#123; @extend .column; width: span($n); &#125;&#125;.span-#&#123;$blueprint-grid-columns&#125; &#123; @extend .column; width: span($blueprint-grid-columns); margin: 0;&#125; Sass 跟 Less 一樣都能用 #{$variable} 來取代 selector 或者 properties ceil 無條件進位 floor 無條件捨去 round 四捨五入 compass create project –using blueprint/basic 只建立最基本的 blueprint 只提供 span() 等 function compass create project –using blueprint/semantic 有提供 column 來建立欄位*@include column($content-columns, true); true 是 last 就是沒有 margin-right: 10px 那段 960 Grid 960Grid 和 Blueprint 第一個差異是 960Grid 的 column 兩邊都有 gutter 在 960gs 中 container 變成 container_12 而 span-1 變成 grid_1 在 960gs 不像 blueprint 需要在 row 最後一個 column 加上 last 他會自動斷行，不過如果需要強制斷行就要用 omega 安裝外掛 gem install compass-plugin 接著在 config.rb require compass create project -r x –using 960 其中 -r 是 require 某 lib ，而 --using 是套用某 framework 到該專案 blueprint 用 span() function 和語意版的 column() 來做欄位切分而 960gs 則是用 grid() grid system 還有一個重要的部分就是 vertical rhythm, column 用來做垂直分配 column 而 vertical rhythm 則用來控制水平 row 之間的間距 vertical rhythm 用 compass 來處理 vertical rhythm 第一步就是先載入 `compass/typography” 宣告 $base-font-size base-line-height @include establish-baseline 接著用 @include adjust-font-size-to(48px); 要在上下追加空白 @include leader(2) or @include trailer(1) 底層的原理是透過一樣的計算方式追加 margin leader(2) 裡面的數字是 baseline 的倍數 leader, trailer 用的是 margin padding-leader, padding-trailer 是用 padding 12345678@import \"compass/typography\";$base-font-size: 16px;$base-line-height: 24px;@include establish-baseline;h1 &#123; @include adjust-font-size-to(24px);&#125; compass common helpers 其他筆記 table 要消除預設的 border 間距 1234table &#123; border-collapse: collapse; border-spacing: 0;&#125; 載入 reset.css 只要 @import “compass/reset” 或者 12@import \"compass/reset/utilities\";@include global-reset; 又或者要個別使用每個小段落 reset-html5 讓 html5 新標籤 display: block; reset-box-model 移除 margin, padding, borders reset-font 設定 font-size 和 line-height reset-focus 移除 outline 例如 input 的樣式 reset-table, reset-table-cell 設定 table 的 border 和 alignment reset-quotation 特別為 blockquotes 設定 截斷文字 12345.truncate &#123; wihte-space:nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 超連結樣式，截斷文字，清單樣式 這些功能都需要先 @import &quot;compass/typography&quot; 最佳實踐關於超連結的 pseudo selector 的順序應該是 a :visited :focus :hover :active 不過 compass 提供的 link-color 的參數是根據開發者常用的習慣 link-colors($normal, $hover, $active, $visited, $focus) 帶參數名稱如下 1234567a &#123; @include link-colors( #333, $hover: #00f, $active: #f00, $visited: #555, $focus: #f00);&#125; 不過根據 80/20 法則我們一般開發時最常用的狀況是 a { @include link-colors(#333, #00f); } 就是設定一般顏色和 hover 顏色而已 a {@include hover-link} 單純在 hover 時幫你的 link 加底線 @include unstyled-link 幫你把連結的樣式全部去除，編譯後的 CSS 如下 1234567p.secret a,p.secret a:hover,p.secret a:focus &#123; color: inherit; cursor: inherit; text-decoration: inherit&#125; List background-position: right 30px bottom 10px 也可以這樣設定 background-position 若用百分比的話不是以外框來計算而是以中心點 在處理圖片清單時因為 IE 的 list-style-image 有 bug 所以一般的做法都是如下 12345ul.features li &#123; background: url(/images/pretty-bullet.png) 5px 5px no-repeat; list-style-type: none; padding-left:20px;&#125; 不過你就需要根據圖片大小計算 background-position (padding - image width)/2 compass 提供了 @include pretty-bullets(&#39;pretty-bullet.png&#39;) 方法讓你可以快速製作圖片清單 同時也提供 $height, $width, $line-height, and $padding 參數給你設定 12345ul.features &#123; @include pretty-bullets('pretty-bullet.png', $padding: 10px, $line-height: 22px)&#125; 注意在 compass 中我們設定圖片不指定完整路徑只要給 檔名+副檔名即可 mixin 內部 compass 自己有用 image-url helper 因為在 IE 8 以前光用 list-style: none 是無法去除 list 樣式的還要額外加上 list-style-image: none; list-style-type: none; margin: 0;所以 compass 另外提供了 @include no-bullets 來消除樣式 注意無論 pretty-bullets 或者 no-bullets 都有單複數的用法差別是加上 s 會影響所有子元素，不加 s 只會影響一層 @include horizontal-list 可以快速做出水平的清單 horizontal-list($padding, $direction) @include delimited-list 把項目 inline 並且在中間加上 , 1ul.words &#123; @include delimited-list(\"! \") &#125; 截斷文字 @include ellipsis; 不換行 @include nowrap text-indent 文字縮排 直接用圖片取代文字 @include replace-text(&quot;coffee-header.png&quot;) replace-text-with-dimensions 根據圖片尺寸修改元素尺寸 Layout helper 要用 sticky footer 和延展元素的 Helper 就需要先載入 compass/layout 果直接用 fixed 把 footer 定在 bottom 在 IE6 會死必須要設定 body height:100%; sticky footer -&gt; @include sticky-footer(40px, &quot;#content&quot;, &quot;#footer&quot;, &quot;#sticky-footer&quot;); #footer 放在 #content 內部是用來撐開內容避免和 #sticky-footer 重疊 stretch 擴展元素 123456a.login &#123; @include stretch(5px, 5px, 5px, 5px) &#125;/* 編譯成 */a.login &#123; position: absolute; top: 5px; right: 5px; bottom: 5px; left: 5px;&#125; css3 要用 css3 功能要先 @import “compass/css3” 舉例來說 @include border-radius(5px) 會幫你把所有瀏覽器的 prefix 都加進去，所以檔案一定會變大，如果要減少你可以設定 1234@import \"compass/css3\";$experimental-support-for-opera: false;$experimental-support-for-khtml: false;$experimental-support-for-microsoft:false; 設定成 false，compass 就會忽略不加 prefix @include border-radius(10px); 圓角 line-height 有 5 種方式定義 line-height normal 是第一種預設是 1 - 1.2 inherit 繼承 parent 百分比 px, em 等單位 純數字 這五種定義的方式可以用縮寫跟在 font 後面 123body &#123; font: 100%/normal arial;&#125; CSS 的繼承又分成 絕對繼承和相對繼承 例如 color 在 parent 設定了之後子元素都會繼承，這種稱為絕對繼承 font-sizez 為相對繼承，例如 body 12px 子元素 h1 font-size: 120% 就會拿 12px * 1.2 = 14.4 繼承列表 line-height 的繼承比較複雜 @include text-shadow($color, $x, $y, $blur) mixin 來做陰影 box-shadow 和 text-shadow 都有 mixin 可以用 使用 shadow 時可以設定預設值這樣就不用全部一個一個設定 1234567891011121314$shadow-color:#ccc$shadow-h:5px;$shadow-v:5px;$shadow-blur:0;$default-text-shadow-color: $shadow-color;$default-text-shadow-h-offset: $shadow-h;$default-text-shadow-v-offset: $shadow-v;$default-text-shadow-blur: $shadow-blur;$default-box-shadow-color: $shadow-color;$default-box-shadow-h-offset:$shadow-h;$default-box-shadow-v-offset: $shadow-v;$default-box-shadow-blur: $shadow-blur; 漸層 漸層的顏色方向 0deg 和 360 deg 方向是往上，90deg 往右 順時針以此類推至於顏色的百分比則是到該點前都是這個顏色，顏色的百分比把它當成點即可 在 compass 裡面用漸層如下 12345#pattern &#123; @include background( linear-gradient(360deg, red 0%, blue 100%) )&#125; line-height 繼承的例子1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;style&gt; body &#123; font-size: 16px; line-height:120%;&#125; h1 &#123; font-size: 32px; &#125; p &#123;font-size: 12px;&#125; #footer &#123; font-size:12px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; Level - h1 &lt;/h1&gt; &lt;p&gt; Lorem ipsum dolor sit amet co &lt;/p&gt; &lt;div id='footer'&gt; This is footer foobar. &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 當大家都有 font-size 然後 line-height 在父元素用百分比時如上 16px * 120% = 19.2px 所以底下的子元素都會套用這個 line-height line-height 是設定 content-area 跟 inline-box 是兩個東西 因為繼承的關係所以 line-height 最好用純數字，因為其會根據 font-size 做計算 font-face 可以用來指定字體來源 在 compass 中使用 font-face 123@import \"compass\";@include font-face(\"FontName\", \"FontName.woff\", woff, \"FontName.ttf\", ttf) compass 可以透過 PIE.htc 來支援 IE6 以前的瀏覽器使用方法是先安裝 compass install compass/pie 123456789@import \"compass/css3/pie\";.pie-element &#123; @include pie-element(relative);&#125;.rounded &#123; @include pie; @include border-radius(20px);&#125; CSS sprites 為什麼要用 sprite 第一點降低下載的次數，第二當 web 需要換圖片路徑時不管網路速度多快還是會閃爍 compass 產的 sprite 只能夠用 png 要用 compass 幫你產 sprites 第一步需要先 @import &quot;compass/utilities/sprites&quot;; 第二步只要 @import &quot;icons/*.png&quot; 只要 import 該目錄底下的圖片即可就可以讓 compass 幫你產 sprite map 的圖片而已，注意不要路徑不要全帶。以 @import “icons/*.png” 這個範例接著 compass 就會去把 images/icons/ 底下的 png 都合體產出一張 icons-xxxxxx.png 的圖片在 /images 中預設 sprites 會用垂直排列的方式 第三步我們要產出 spriting css 就是對應取得圖片的 css ，compass 提供兩種方式產出這些 css @include all-icons-sprites; // 中間是 map name 接著就會全部寫入 css @include -sprite($name) // 前面是 map name 後面參數是要產出的圖片檔名，這種方式不能用在全域只能套用在某個 .class 內部。 通常 map name 就是目錄的名稱 當我們用 @include all-icons-sprites 把所有 css 的樣式產出之後就可以用 icons-filename 去套用該圖片 預設來說 compass 不會幫我們設定 width, height 通常我們在套用 sprite 的時候建議用 @extend ，因為產出是 .class 如果要使用 mixin 就要改成下面的寫法，注意這種方式只會產出內部的 properties 就是樣式 rules單一 mixin 的方式只能寫在 selector 內部 123456@import \"compass/utilities/sprites\";@import \"icons/*.png\";.add-button &#123; @include icons-sprite(box-add);&#125; 當把圖片放在巢狀目錄內的時候 e.g. images/icons/whats 那麼 sprites 會在該目錄先產出一張圖片命名規則一樣 what-&lt;hashcode&gt;.png，不過 mixin, variable, function 則會用最後一層的目錄名稱 可以使用 map 的名稱即目錄名稱加上屬性來針對該 sprite 設定 12345$&lt;map&gt;-&lt;property&gt;: setting;$&lt;map&gt;-&lt;sprite&gt;-&lt;property&gt;: setting;$&lt;目錄名稱&gt;-&lt;圖片名稱&gt;-&lt;屬性&gt;: 設定值;$icons-spacing: 10px; 注意：這些變數必須被定義在圖片匯入 @import 之前否則他們不會產生效果 $icons-spacing 可以在 sprite 周圍加透明的 padding $icons-repeat: repeat-x; 可以設定圖片是否要重複 compass 不支援垂直重複，所以沒有 repeat-y 可以設定 透過 $&lt;map&gt;-position: 0px 來達到 offset ，注意的是百分比%會跟 CSS 的 position 一樣並不是用最左邊界來計算也就是說如果設定 100% 會剛好貼齊右邊 sprite map layout 除了預設的垂直排列外 compass 還提供了不同的組圖方式 $&lt;map&gt;-layout: vertical/horizontal/diagonal/smart $icons-layout:smart 用 smart ，compass 會用最少的空間去排列組合 sprites 注意一旦使用了 smart 就不能用 position 和 repeat 這兩個屬性只能給 vertical 和 horizontal 使用 compass 預設會自動清除過期或不用的圖片，不過如果你不想清除可以設定 $&lt;map&gt;-clean-up: true/false 預設 compass 產出的 sprite 是沒有帶尺寸的 postion 會自動根據圖片的大小去排列但如果要加上尺寸也是可以如下設定，注意他們是 helper function 不是設定值 123456789&lt;map&gt;-sprite-height($name);&lt;map&gt;-sprite-width($name);@import \"icons/*.png\";.next &#123; @include icons-sprite(arrow); width: icons-sprite-width(arrow); height: icons-sprite-height(arrow);&#125; 或者全部都要加上尺寸 $&lt;map&gt;-sprite-dimensions: true/false 當然我們也可以替所有的 sprite 加上基本的樣式 .class 1$&lt;map&gt;-sprite-base-class: \".class-name\"; 原理來說每一個 sprite 會 @extend base-class compass 會自動輸出 :hover, :active, :target 等 pseudo selectors 給 sprites 只要檔案名稱結尾符合 _hover _active 只要圖片名稱如上面這樣給定 compass 就會自動幫你產出 :hover 等狀態時的樣式 arrow_hover.png 通常我們只要 @import &quot;icons/*.png&quot; compass 就會自動幫我們產生一張 sprite map 然後伴隨著 mixin, function 等東西，但如果你不想使用這些變數或 mixin 也可以使用sprite-map($glob)` helper 1$icons: sprite-map(\"icons/*.png\", $arrow-spacing: 5px); 如此一來就不用根據 map name 和 sprite name 一個一個設定 在 compass 協助我們產出 sprites map 之後我們仍然需要針對每一個 sprite 撰寫樣式此時我們就能夠用 sprite helper 或者說這個 helper 可以直接讓我們操作底層的東西 1234$icons: sprite-map(\"icons/*.png\");.next &#123; background: sprite($icons, arrow) no-repeat;&#125; 模擬底層的運作寫法 sprite-map 函式的意義就是建立一個 map 物件 12345678910$icons: sprite-map(\"icons/*.png\");.sprite-base &#123; background: $icons no-repeat;&#125;.next &#123; @extend: .sprite-base; background-position: sprite-position($icons, arrow);&#125;.add-button &#123; @extend .sprite-base; @include sprite-background-position($icons, box-add);&#125; 加入尺寸 1234567@icons: sprite-map(\"icons/*.png\");.sprite-base &#123; background: $icons no-repeat; &#125;.next &#123; @extend .sprite-base; @include sprite-background-position($icons, arrow); @include sprite-dimensions($icons, arrow);&#125; compass 提供了三種路徑 helper image-url(‘logo.png’) 從 /root 裡面的 images 目錄開始找 font-url(‘arial.ttf’) 從 /font 目錄找 stylesheet-url 從 /css 或 /stylesheets 目錄開始找 注意到 compass 沒有提供 javascript 的目錄同樣的也沒有 sass 的 helper 透過在 config.rb 加入一些設定可以在 assets 後面追加 query 且使用版號 123asset_cache_buster do |http_path, real_path| \"v=1\"end 因為在路徑後面加上 query 會導致某些 proxy 不敢 cache 所以也可以關掉 1asset_cache_buster :none 所以正確來說我們會在檔案中加入 time-stamp 或 hash 所以 compass 提供的作法如下 1234567891011121314asset_cache_buster do |path, real_path| if File.exists? (real_path) pathname = Pathname.new(path) modified_time = File.mtime(real_path) new_path = \"%s/%s-%s%s\" % [ pathname.dirname, pathname.basename(pathname.extname), modified_time.strftime(\"%s\"), pathname.extname ] &#123;:path =&gt; new_path&#125; endend 即使在開發時期都應該使用 URL 而不是相對路徑，不過 compass 還是提供設定讓你可以快速產生相對路徑 1relative_assets = true http_path 可以快速幫所有路徑修改 URL Path http_path = &quot;/super-fancy-app&quot; 編譯 production 1compass compile --force -e production 一旦加上了 http_path 建議就要把 relative_assets 關閉 1234http_path = '/my-app'relative_assets = falseimages_dir = 'images' #locally it's the images folderhttp_images_dir = 'imgs' #on the webserver it's different 在註解加上驚嘆號就會被強制輸出 123/*! comment here*/ 另外就像 less 一樣變數也可以在字串中，樣式屬性，Selector 使用用法為 #{$variable} 123456$copyright-year: unquote(\"2012\");$company-name: unquote(\"Example, Inc\");/*! Copyright #&#123;$copyright-year&#125;, #&#123;$company-name&#125; All Rights Reserved.*/ 包含全部網址的設定 1234asset_host do |asset| host_number = (asset.hash % 4) + 1 \"//img-#&#123;host_number&#125;.example.com\"end compass 也提供一個 method 讓我們可以快速地把圖片轉成 base64 .icon { background: inline-image(&quot;black-dot.png&quot;); } gem install css_parser compass stats 可以觀察目前 selectors 和 css 的狀態 expression 表達式在 sass 中大多用來表示樣式值或屬性 data type 每一個 css property 的值或者變數都有一個型別，依據不同的型別有不同的行為 string 分成有加 &quot; 和 沒有 &quot; ，有加的可以包含除了 “ 以外其他的特殊符號例如 !, 沒有加引號的不能用數字或特殊符號開頭也不能包含空白 * &amp; 除此之外還有一些其他特殊的結構 sass 也是為字串 如 !important 雖然他是用 ! 開頭但 sass 是其為字串 url() 內部得值也被視為 unquoted string number, 單位也會被一併計算 e.g 1em 2px = 2empx color 有 hex, rgb, hsl 等方式定義 list e.g. 1px solid black，列表值可以用空白隔開或者 , list 是一系列的值的組合被用在像是 border 或 background 中 boolean 在 sass 中 若比較的兩個值為非布林值則傳回得值跟一般程式不同，e.g blue and red = red, false and red = false, blue or red = blue string, number, color, list, boolean 以上為 Sass 中的型別 當 function 有很多參數時 sass 的 function 可以帶入參數名稱 rgb($green: 127, %blue: 127, $red: 255) abs() 絕對值, ceil() 無條件進位, comparable(1, 2) 傳回 true/false 看兩者是否能夠運算或比較, floor() 無條件捨去, percentage() 把小數轉成百分比, round() 四捨五入, unit() 傳回單位, unitless() 傳回 true/false 看是否有單位 色彩的 function 像是 alpha($color), opacity($color), blue($color), red($color), green($color) 來取得色彩資訊 adjust($color, $red:20, $blue: -20) 調整顏色 red + 20, blue - 20 調淡顏色 adjust(gray, $lightness:15%) scale($color, $lightness: 30%) scale 只能用百分比且不支援 $hue function 的寫法 123@function grid-width($cells) &#123; @return ($cell-width +$cell-padding) * $cells;&#125; 在 #{...} 中 &quot; 會被移除 迴圈的寫法 1234567@for $i from 1 to 5 &#123; ... /* $i 到 4 */&#125;@for $i form 1 through 5 &#123; /* ... 到 5 */&#125; Sass 的 loop 不能一次加2 也不能倒數，不過我們可以透過一些小技巧來達到這個需求 12345678910@for $i from 0 to 10 &#123; $i: 10 - $i; ...&#125;@for $i from 0 through 10 &#123; $i:$ * 2; ...&#125; each 的用法 123456@each $section in home, about, archive, projects &#123; nav .#&#123;section&#125; &#123; ... &#125;&#125; nth($list, $index) 取得列表中的值","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"sass","slug":"sass","permalink":"//andyyou.github.io/tags/sass/"},{"name":"compass","slug":"compass","permalink":"//andyyou.github.io/tags/compass/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Rails 精簡練習","slug":"commands","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/commands/","link":"","permalink":"//andyyou.github.io/2015/04/04/commands/","excerpt":"","text":"指令練習1234567891011121314$ rails generate scaffold User name:string bio:text birthday:date$ rails destroy scaffold User$ rails g scaffold Post name --skip-assets$ rails db$ rails console$ rails g controller posts # 複數$ rails g controller posts index new create # 後面可以接 action$ rails g model Post title body:text$ rails d model post$ rake db:setup$ rake db:migrate$ rake db:migrate:status$ rake routes 手刻練習 建立文章控制器 posts_controller.rb 加入 resources :posts 路由 加入 列表 action index 建立 index view 加入 新增 action new 加入 new view 重點在 form_for 表單 新增 post model rails g model post title body:text 建立 create action 來儲存 model，記得補上驗證 建立 show view 顯示單筆資料 Model 可以建立之後把 index view 補上 each do 把 new view 抽出 _form 然後建立 edit action and update 補上 destroy action 加上關聯的 comment 留言 model 補上 model 關聯的設定 路由設定 建立 comments_controller.rb comments 這個 controller 是依附在 posts 底下，加上巢狀 resources 會得到 /posts/:post_id/comments 所以注意表單 form_for([@post, @post.comments.build]) 的部分 建立 create action 重點在 @post = Post.find(params[:post_id]) 和 @comment = @post.comments.create(params[:comment].permit(:name, :body)) 注意 view 的 _form 部分 view 總共會建立 3 個 _form, _comment, 再修改 posts/show 使用 render “comments/form” 實作 comments_controller 的 destroy action ，記得要從 @post.commetns.find() -&gt; destroy models/post.rb 記得 dependent: :destroy 1.1$ rails g controller posts 2. 修改 config/routes.rb12resources :postsroot \"posts#index\" 3. 加入 action123456class PostsController &lt; ApplicationController def index endend 4. 加入 index view1&lt;h1&gt;Hello world!&lt;/h1&gt; 5. 實作新增 new123456class PostsController &lt; ApplicationController #... def new endend 6. 在 app/views/posts/new.html.erb 新增表單，此時沒有 Model ，因為我們在 form_for 用 symbol123456789&lt;%= form_for :post, url: posts_path do |f| %&gt; &lt;%= f.label :title %&gt; &lt;%= f.text_field :title %&gt; &lt;%= f.label :body %&gt; &lt;%= f.text_field :body %&gt; &lt;%= f.submit %&gt;&lt;% end %&gt; 此時當我們送出 post 的時候，第一沒有 create 的 action 因為 resources :posts 幫我們加上了 8 個路由，扣掉 put, patch 功能一樣有 7 組不同功能的路由 12345678get \"posts\" =&gt; \"posts#index\", :as =&gt; \"posts\" # 取得 posts_path helperpost \"posts\" =&gt; \"posts#create\", :as =&gt; \"posts\"get \"posts/:id\" =&gt; \"posts#show\", :as =&gt; \"post\" # 注意單數，用的時候後面要帶 model 參數才能取得 :idget \"posts/new\" =&gt; \"posts#new\", :as =&gt; \"new_post\"get \"posts/:id/edit\" =&gt; \"posts#edit\", :as =&gt; \"edit_post\"put \"posts/:id\" =&gt; \"posts#update\", :as =&gt; \"post\"patch \"posts/:id\" =&gt; \"posts#update\", :as =&gt; \"post\"delete \"posts/:id\" =&gt; \"posts#destroy\", :as =&gt; \"post\" 7. 新增 Post Model12$ rails g model Post title body:test$ rake db:migrate 8. 在 controller 新增 create action12345678910def create @post = Post.new(post_params) @post.save redirect_to @postendprivatedef post_params params.require(:post).permit(:title, :body)end 這個時候送出會產生錯誤，因為 redirect_to @post 的關係。一般情況下此時只要有對應的 app/views/posts/show.html.erb 就能 work 了 9. 建立 show action 和 view12345&lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;&lt;p&gt;&lt;%= time_ago_in_words(@post.created_at) %&gt;&lt;/p&gt;&lt;p&gt;&lt;%= @post.body %&gt;&lt;/p&gt; 10. index 列表1234&lt;% @posts.each do |post| %&gt; &lt;h2 &gt;&lt;%= link_to post.title, post_path(post)%&gt;&lt;/h2&gt; &lt;p class=\"date\"&gt;&lt;%= post.created_at.strftime(\"%B %d, %Y\") %&gt;&lt;/p&gt;&lt;% end %&gt; 11. 加入 comment12$ rails g model Comment name:string body:text post:references$ rake db:migrate 12345678910111213# post.rbclass Post &lt; ActiveRecord::Base has_many :comments validates :title, presence: true, length: &#123; minimum: 5 &#125; validates :body, presence: trueend# routes.rbresources :posts do resources :commentsend 因為現在 Comment model 是關聯在 Post model 下面，所以 @post = Post.find(params[:post_id]) 當我們要在 CommentsController 找 Post 需要 :post_id 12345678class CommentsController &lt; ApplicationController def create @post = Post.find(params[:post_id]) @comment = @post.comments.create(params[:comments].permit(:name, :body)) redirect_to post_path(@post) endend form_forform_for 的用途是建立一個 html 的 form 表單，讓使用者可以透過 form 把資料傳回後端，新增或者更新某個指定物件的屬性。這個方法(method)有幾種稍微不同的用法，取決於您想從 Rails 的 Model 中自動對應多少東西，或者說自動處理掉 Model 對應的部分針對一般情況的 Model，我們透過傳入 form_for 一個字串或 symbol 來表示我們要對應的物件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#--- erb&lt;%= form_for :xx do |f|%&gt; &lt;%= f.text_field :oo %&gt;&lt;% end %&gt;#--- 輸出&lt;form method=\"post\" accept-charset=\"UTF-8\" action=\"同一個路由\"&gt; &lt;input name=\"utf8\" value=\"✓\" type=\"hidden\"&gt; &lt;input name=\"authenticity_token\" value=\"EsXGzijdB1Wx8f5FNtO+l8XDEpoA49Ko7nJsZw+Tb5N5BpIQPs3NCw9iO5gwZTkJgyzDm48GHDQCkPwwcFa2WA==\" type=\"hidden\"&gt; &lt;input id=\"xx_oo\" name=\"xx[oo]\" type=\"text\"&gt;&lt;form &gt;#-- 協助記憶&lt;%= form_for :object do |f| %&gt; &lt;%= f.text_field :attribute %&gt;&lt;% end %&gt;#--- 您也可以單純用 text_field，在 yield 中的 f 變數是一個 FormBuilder 物件，透過與 Model 物件或者 symbol 的定義合作產生表單#--- erb&lt;%= text_field :a, :b %&gt;&lt;%= text_field :person, :name %&gt;#--- 輸出&lt;input type=\"text\" id=\"a_b\" name=\"a[b]\"&gt;&lt;input type=\"text\" id=\"person_name\" name=\"person[name]\"&gt;#--- 當 submit 的時候會收到 params[:a][:b], params[:pserson][:name]#--- 此時如果有一個 @a 的變數傳進來預設就會初始化帶入這些欄位#--- 範例#--- view/&lt;input type=\"text\" id=\"a_b\" name=\"a[b]\"&gt;#--- controller/class SomeController &lt; ApplicationController class A attr_accessor :b end def action @a = A.new @a.b = \"What happen?\" endend#--- 如此 view 的 a[b] 就會自動帶入 What happen? 在 form_for 右邊還可以帶入參數 url 可以修改 submit 的網址即 action=”url here” namespace 替內部的 input id 再加上特殊的前綴字例如上面本來是 a_b 如果加上 namespce: ‘x’ 就會變成 x_a_b html 其他原生 html 的屬性 e.g. :html =&gt; { :multipart =&gt; true } 針對表單還有 FormOptionHelper 和 DateHelper 可以針對下拉式選單或日期做處理 注意 form_for 本身不會建立一個獨立的 scope ，意味著您看同時混搭 FormHelper 和 FormTagHelper 123456&lt;%= form_for :person do |f| %&gt; &lt;%= f.text_field :first_name %&gt; &lt;%= text_area :last_name %&gt; &lt;%= check_box_tag \"person[admin]\", \"1\", @person.company.admin? %&gt; &lt;%= f.submit %&gt;&lt;% end %&gt; form_for 搭配 Model在上面的範例，會根據傳入 form_for 的 symbol 去產生對應的 from 表單 name 屬性，如此一來可以被對應為一個物件，如果您傳入的是字串那麼意思也是一樣的。我們也可以把 Model 物件本身當作參數傳入，如果 @person 存在且您想編輯它那麼您可以直接使用如下 123&lt;%= form_for @person do |f| %&gt; ...&lt;% end %&gt; 這麼寫的行為幾乎跟您使用 symbol 一樣，不過有些微不同，首先是表單的前綴字即用 model 的 class name ， 且 form 會有 id 且會根據 new 或 edit 不同當然如果不想被綁死您也可以修改 12&lt;%= form_for(@person, as: :client) %&gt;&lt;% end %&gt; 其次是當該物件已經被初始化或者說有值的時候對應 attributes 的欄位會自動帶入該值，因此如果該 view 已經有個變數 post也可以這樣寫 12&lt;%= form_for post do |f| %&gt;&lt;% end %&gt; 在剛剛的範例中，雖然我們沒有明確的指定，但我們還是要使用 :url 來指定 post 的目標。然而如果我們的物件有透過 resources 指定路由的話路徑就會自動處理例如 123456789101112131415161718192021222324252627&lt;%= form_for @post do |f| %&gt;&lt;% end %&gt;# 會等於&lt;%= form_for @post, as: :post, url: post_path(@post), method: :patch, html: &#123; class: \"edit_post\", id: \"edit_post\"&#125; do |f| %&gt;# 如果 @post 是剛初始化的話&lt;%= form_for(Post.new) do |f| %&gt; ...&lt;% end %&gt;&lt;%= form_for @post, as: :post, url: posts_path, html: &#123; class: \"new_post\", id: \"new_post\" &#125; do |f| %&gt; ...&lt;% end %&gt;# 當然也可以覆寫&lt;%= form_for(@post, url: super_post_path) do |f| %&gt;# 或者設定回應的格式&lt;%= form_for(@post, format: :json) dp |f| %&gt;# 針對 namespace 路由 e.g. admin_post_url&lt;%= form_for([:admin, @post]) do |f|&gt;# 如果是關聯的子物件屬性&lt;%= form_for([@post, @comment]) do |f| %&gt; 關掉 id 12345&lt;%= form_for(@post) do |f| %&gt; &lt;%= f.fields_for(:comments, include_id: false) do |cf| %&gt; ... &lt;% end %&gt;&lt;% end %&gt; 也可以改用別的 FormBuilder 1234&lt;%= form_for @person, url: &#123; action: \"create\" &#125;, builder: LabellingFormBuilder do |f| %&gt;# 照上面的範例如果我們用&lt;%= render f %&gt;# 則會 render people/_labelling_form 的樣板 redirect_to 的用法將瀏覽器重新定向到參數(options)中指定的目標，這個參數可以用下面格式:(Hash, Model Record, String 搭配 protocol://, String, :back) 總結來說是三種格式 Hash - 這種格式是透過搭配 url_for 產生的 12redirect_to url_for(controller: 'posts', action: 'new')redirect_to :action =&gt; \"new\" # 就算你不加 url_for 預設也會幫您呼叫 Record - 一筆紀錄其實就是您取出來的 model 本質上當您 redirct_to @model 時總結來說就是轉址到 model_path(@model)對應的路徑即 /posts/:id 就是 “posts#show” (PostsController &gt; show action)。所以雖然我們上面沒有定義 show action 但只要有 view (show.html.erb)就能夠執行是因為 Rails 預設當找不到 action 的時候會直接去找對應 action 的 view。 傳入紀錄的方式在內部是透過 polymorphic_url 來處理 123456789101112131415161718192021222324# 當我們使用 RESTful 路由時內部的各種狀況範例如下:## # 呼叫 post_url(post)# polymorphic_url(post) # =&gt; \"http://example.com/posts/1\"# polymorphic_url([blog, post]) # =&gt; \"http://example.com/blogs/1/posts/1\"# polymorphic_url([:admin, blog, post]) # =&gt; \"http://example.com/admin/blogs/1/posts/1\"# polymorphic_url([user, :blog, post]) # =&gt; \"http://example.com/users/1/blog/posts/1\"# polymorphic_url(Comment) # =&gt; \"http://example.com/comments\"### ==== 其他範例## # an Article record# polymorphic_url(record) # same as article_url(record)## # a Comment record# polymorphic_url(record) # same as comment_url(record)## # it recognizes new records and maps to the collection# record = Comment.new# polymorphic_url(record) # same as comments_url()## # the class of a record will also map to the collection# polymorphic_url(Comment) # same as comments_url() 字串 - 有使用 protocol:// 例如: http:// 就是直接傳入網址 字串不搭配 protocol 就是 //example.com 會用當前的通訊協定 :back - 簡單的說就是 redirect_to(request.env[&amp;quot;HTTP_REFERER&amp;quot;]) 的縮寫 123456789101112# 完整範例 redirect_to :action =&gt; \"show\", :id =&gt; 5 redirect_to post redirect_to \"http://www.rubyonrails.org\" redirect_to \"/images/screenshot.jpg\" redirect_to articles_url redirect_to :back# 搭配狀態 redirect_to post_url(@post), :status =&gt; :found redirect_to :action=&gt;'atom', :status =&gt; :moved_permanently redirect_to post_url(@post), :status =&gt; 301 redirect_to :action=&gt;'atom', :status =&gt; 302 routesrouting 模組使 Ruby 具有 rewrite URL 網址的能力，這是一種處理 Request 對應到 controller 及 action 的方式。主要是用來取代像是 apache 中 mod_rewrite 規則的功能。而在 Rails 中您可以不用動到 Server 的設定，只要設定 config/routes.rb 即可。 建立路由的核心概念就像是列出一張對應表，對應 Requests 。這張對應表告訴系統該怎麼執行，其中必須要遵循一些規則樣式。 1234Rails.application.routes.draw do # Pattern 1 指定對應的 request 路徑到 controller # Pattern 2 告訴他們去別的地方end 其中路由的功能還包含 helper 來協助生成網址 最基本的 Pattern 1 類似於下面範例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455get '/products/:id', to: 'products#show' # 把 :id 傳入 params 然後把 request 交給 products_controller 的 show action 處理get '/products/:id', to: 'products#show', as: 'product' # 對應單數如此一來會產生 product_path helper# 使用 resources 方式一口氣產出 7 種不同的路由(實際上 patch, put 功能一樣總數有8個)resources :products # 複數# 這種 resources 的方式是透過 http method 搭配 url 組成一系列的路由，把 4 組 url + 5 個 http verbs = 7 組功能# 例如 DELETE /products/17 當 Rails 收到這組 Request 時，就會呼叫 products 的 destroy 並把 params 帶入get '/photos', to: 'photos#index'get '/photos' =&gt; 'photos#index' # 除了用 :to 還可以直接用 =&gt;get '/photos/new', to: 'photos#new'get '/photos/:id', to: 'photos#show'post '/photos', to: 'photos#create'get '/photos/:id/edit', to: 'photos#edit'put '/photos/:id', to: 'photos#update'patch '/photos/:id', to: 'photos#update'delete '/photos/:id', to: 'photos#destroy'# 省略的寫法match 'messages/show' # 相等於 match 'messages/show' =&gt; 'messages#show'match 'messages' =&gt; 'messages#index', :as =&gt; 'index'match \"/messages/show/:id\" =&gt; \"messages#show\", :constraints =&gt; &#123;:id =&gt; /\\d/&#125; # 限制參數# 單數的 resourceresources :post&gt; new_post_path&gt; edit_post_path&gt; post_path# 命名空間的用法namespace :admin do resources :photosend# 這樣的路徑會加上 admin -&gt; /admin/posts# 如果單純想把前面沒有 /admin 的路由對應到 Admin::PostsController 則scope module: 'admin' do resources :postsend# 或者resources :posts, module: 'admin'# 當某個 model 底下有子 model 時如class User &lt; ActiveRecord::Base has_many :orderendclass Order &lt; ActiveRecord::Base belongs_to :userend# 路由得設法resources :users do resources :ordersend render 方法 文件渲染回應給瀏覽器的內容 渲染 action (rendering an action) 123render :action =&gt; \"goal\"render :action =&gt; \"short_goal\", :layout =&gt; falserender :action =&gt; \"long_goal\", :layout =&gt; \"spectacular\"","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"ActiveRecord 雜記","slug":"active-record","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/active-record/","link":"","permalink":"//andyyou.github.io/2015/04/04/active-record/","excerpt":"優化 Model count123class Like &lt; ActiveRecord::Base belongs_to :guestbook_entry, counter_cache: trueend","text":"優化 Model count123class Like &lt; ActiveRecord::Base belongs_to :guestbook_entry, counter_cache: trueend 其他小筆記 Rails 慣例 date -&gt; created_on, datetime -&gt; created_at 如果 Model 的單偶數錯誤了就到 config/initializers/inflections.rb 去修改 123ActiveSupport::Inflector.inflections do |inflect| inflect.irregular 'tax', 'taxes'end 或者直接改 Model 本身 123class Sheep &lt; ActiveRecord::Base self.table_name = \"sheep\"end 要換 key 的名稱，4 版後直接調整 schema 12345create_table :products, id: false do |t| t.string :sku, primary_key: true t.timestampsend rails console 下的一些指令12$ Order.column_names$ Order.columns_hash[\"column_name\"]","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Ruby 快速筆記","slug":"ruby-notes","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/ruby-notes/","link":"","permalink":"//andyyou.github.io/2015/04/04/ruby-notes/","excerpt":"Ruby 快速筆記 Ruby 中的字串需要包在 &quot; 或者 &#39; 中不過兩者有一點微妙的差別，在雙引號中可以使用逸出字元(\\n \\r \\) 等等，不過單引號會原封不動的輸出除了 \\\\ 例外 在呼叫方法的時候 Ruby 可以省略 () puts 和 print 的差別是 puts 會在行末加上 \\n，如果是用 , 分開不同的參數輸出則每個參數後面都會有 \\n 第三個輸出的 method 是 p ，puts 和 print 不管輸出的是數字或字串都只會顯示內容","text":"Ruby 快速筆記 Ruby 中的字串需要包在 &quot; 或者 &#39; 中不過兩者有一點微妙的差別，在雙引號中可以使用逸出字元(\\n \\r \\) 等等，不過單引號會原封不動的輸出除了 \\\\ 例外 在呼叫方法的時候 Ruby 可以省略 () puts 和 print 的差別是 puts 會在行末加上 \\n，如果是用 , 分開不同的參數輸出則每個參數後面都會有 \\n 第三個輸出的 method 是 p ，puts 和 print 不管輸出的是數字或字串都只會顯示內容 1234puts \"1\" # =&gt; 1puts 1 # =&gt; 1p \"1\" # =&gt; \"1\"p 1 # =&gt; 1 用 p 輸出可以得知值的型別，值得注意的是如果用 p 輸出，單引號和雙引號會有差別 因為 p 不會轉譯逸出字元所以雙引號會被直接輸出 123456p \"Hello \\n\" # =&gt; \"Hello \\n\"# 但是單引號本來就會直接輸出逸出字元, 如下:puts '\\n' # =&gt; \\n 所以骨子裡是 '\\\\n'# 因此遇上 p 的時候會輸出 `\\\\n`p '\\n' #= '\\\\n' 設定語系 1$ ruby -E utf-8 say_chinese.rb 陣列的多種初始化方式 12345a = Array.new # =&gt; []a = [] # =&gt; []# Array.new(size, default_value)a = Array(2, 3) # =&gt; [3, 3] 取得 User Input 1text = gets.chomp 格式化文字 123\"String\".upcase # =&gt; STRING\"String\".downcase # =&gt; string\"string\".capitalize # =&gt; String 條件控制式 123456789if / elsif / elseif true puts \"Yes\"elsif true puts \"I don't know\"else puts \"No\"end unless 123456789unless false =&gt; excuteunless true =&gt; do nothingunless = if not# unless = if notunless false puts 'It will excute'end while 12345counter = 1while counter &lt; 11 puts counter counter = counter + 1end while true =&gt; 執行 =&gt; false 停止 until false =&gt; 執行 =&gt; true 就停止 for 1234567for num in 1..3 # 1, 2, 3 puts numendfor num in 1...3 # 1, 2 puts numend loop 1234567891011121314151617181920212223loop &#123; print \"Hello, World!\" &#125;i = 0loop do i += 1 puts i break if i &gt; 5end# 迴圈中 skiploop do i += 1 next if i % 2 == 0 print iendarray.each do |i| puts iend5.times do puts \"Ruby!\"end 轉字串 11.to_s reverse 陣列的方法，單純反轉 index 1234567891011121314puts \"Please input words: \"text = gets.chompwords = text.split(' ')frequencies = Hash.new(0)words.each &#123; | word | frequencies[word] += 1&#125;frequencies = frequencies.sort_by&#123; | word, frequence | frequence &#125;frequencies.reverse!frequencies.each do | word, frequence | puts word + \" \" + frequence.to_send is_a? 121.is_a? Integer # =&gt; true\"string\".is_a? Integer # =&gt; false 確認該值為 Boolean 12# checking whether foo is a boolean!!foo == foo 字串轉 symbol / symbol 轉字串 12\"string\".to_sym:symbol.to_s 關於排序 12345678910111213141516arr = [4, 3, 2, 1]arr.sort!arr.sort! &#123; |x, y| x &lt;=&gt; y&#125; # 小到大arr.sort! &#123; |x, y| y &lt;=&gt; x&#125; # 大到小arr.sort! do if x &gt; y 1 elsif x &lt; y -1 else 0 endend# x &gt; y = 1, x &lt; y = -1 時是小到大 Hash 12345678910111213141516171819202122232425262728hash = Hash.new# 設定預設值hash = Hash.new('a default')hash['nonexists'] # =&gt; a defaulthash = &#123;&#125;hash = &#123; \"one\": 1&#125;hash = &#123; :one =&gt; 1&#125;hash = &#123; one: 1&#125;hash = Hash[\"xxx\" =&gt; 1]movie_rating = &#123; iron_man: 4, super_man: 3&#125;good_movies = movie_rating.select &#123; |k, v| v &gt; 2 &#125;movie_rating.each_value &#123; |v| puts v &#125;movie_rating.each_key &#123; | k | puts k &#125; 產出 Range Array 12a_z = (\"a\"..\"z\").to_a[1, 2, 3].zip([4, 5, 6]) #=&gt; [[1, 4], [2, 5], [3, 6]] 計算效能 123performance = Benchmark.realtime do # do your codeend 因為 block 本身不是物件，所以不能夠用變數來存取他。也因此有了 Proc 物件的存在。 Proc 物件的用法可以在加入 method 的參數使用 &amp; 1234567891011121314151617181920212223def greeter yieldendphrase = Proc.new &#123; puts \"Hello, Ruby!\" &#125;greeter &amp;phrase# 或者直接運行phrase.call# 進階用法把 method 當作 Proc 傳入strings = [\"1\", \"2\", \"3\"]nums = strings.map(&amp;:to_i)# 範例def greeter yield(\"your name\")endhi = Proc.new &#123; |name| puts \"Hi #&#123;name&#125;\" &#125;hi.callgreeter &amp;hi 相等的 methods collect = map to_sym = intern lambda 與 ProcProc 和 lambda 都是物件，大致上行為一致例如: 12lambda &#123; puts \"Hello!\" &#125;Proc.new &#123; puts \"Hello!\" &#125; 最主要的兩個差別是 lambda 會確認 arguments 的數量，Proc 不會Proc 會幫你把沒傳入的參數帶入 nil 1234l = lambda &#123;|x, y| puts x &#125;p = Proc.new &#123; |x, y| puts x &#125;l.call(1) # ArgumentError: wrong number of arguments (1 for 2)p.call(1) # Work 第二個最恐怖的差異是 Proc return 之後就不回原本的 method 了控制權由他掌控，而 lambda 會把控制權交回給呼叫的 method yield 指的是呼叫 block 這件事，而 Proc 是用來包 block 的物件，lambda 也是不過骨子裡還是 Proc 物件。&amp; 的意思是把 Proc 或 lambda 轉回 block 所以我們可以這樣用 123456789101112131415def meow yieldendl = lambda &#123; puts \"I'm lambda\" &#125;p = Proc.new &#123; puts \"I am Proc\" &#125;meow &amp;lmeow &amp;p# 當要把 block 當作實際參數時則def bark(o) o.callendbark lbark p 歸納 block, Proc, lambda 一個 block 只是一小段程式碼被包在 do ... end 或者 { } 裡面。他本身並不是一個物件，不過他可以被傳進方法(method) e.g each, select, collect, map，由於其不是一個物件所以不能夠直接存進變數中。 一個 Proc 物件可以儲存一個 block，然後我們可以重複使用。 lambda 就跟 Proc 很類似，不過它在乎您傳入的參數的數量，且當 method 呼叫時他會把控制權交回給 method 並不像 Proc 會立即回傳。 123456789101112131415def batman_ironman_proc victor = Proc.new &#123; return \"Batman will win!\" &#125; victor.call \"Iron Man will win!\"endputs batman_ironman_procdef batman_ironman_lambda victor = lambda &#123; return \"Batman will win!\" &#125; victor.call \"Iron Man will win!\"endputs batman_ironman_lambda 其 Proc 的指標。如果要取得該 Proc 的指標，需要在最後一個參數前面加上 ’&amp;’，這東西只能有一個，且必須放在最後面，否則都會跳出 syntax 123456def f3(n, p) p[n] # call proc p # 'p[n]' is equivalent to 'p.call(n)' # 'yield n' will not work unless a block was given, but notice that the block has nothing to do with parameter 'p'endf3('Tony', Proc.new&#123;|name| puts name&#125;) # 'Proc.new' is equivalent to 'Kernel::proc' &amp; 的意義是當我們把 block 傳進定義的 method 參數時把該 block 轉成 Proc (背地裏是取得該指標) 參考文章 Proc &amp; lambda 百分比符號的用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748%(interpolated string (#&#123; \"default\" &#125;)) #=&gt; \"interpolated string (default)\"# 雙引號的另外一種取代的寫法，當文字裡面有其他雙引號時可以用這種寫法內不會自動幫您把 `\"` 轉成 `\\\"` 如此一來可以省略反斜線%Q(interpolated string (#&#123; \"default\" &#125;)) #=&gt; \"interpolated string (default)\"# (...) 括號可以用其他非英數字元取代如 `!`%Q!Joe said: \"Frank said: \"#&#123;what_frank_said&#125;\"\"!%Q[Joe said: \"Frank said: \"#&#123;what_frank_said&#125;\"\"]%Q+Joe said: \"Frank said: \"#&#123;what_frank_said&#125;\"\"+# 單引號的另一種寫法，不過注意單引號內部不會轉譯會直接輸出%q(non-interpolated string) #=&gt; \"non-interpolated string\"%q(Joe said: 'Frank said: '#&#123;what_frank_said&#125; ' ') #=&gt; \"Joe said: 'Frank said: '\\#&#123;what_frank_said&#125; ' '\"# 類似 %Q 的功能不過用在正規式上，該脫曳的字元會自動加上 `\\`%r(#&#123; \"interpolated\" &#125; regexp)i #=&gt; /interpolated regexp/i# 空白分開會被轉成陣列，每個元素外圍用雙引號包起來%W(interpolated\\ string #&#123; \"separated by whitespaces\" &#125;) #=&gt; ['interpolated string', 'separated by whitespaces']%W(#&#123;foo&#125; Bar Bar\\ with\\ space) #=&gt; [\"Foo\", \"Bar\", \"Bar with space\"] # 跟 %W 類似但元素不會編譯或脫曳字元%w(non-interpolated\\ string separated\\ by\\ whitespaces) #=&gt; ['non-interpolated string', 'separated by whitespaces']%w(#&#123;foo&#125; Bar Bar\\ with\\ space) #=&gt; [\"\\#&#123;foo&#125;\", \"Bar\", \"Bar with space\"]# 轉成 symbol%s(non-interpolated symbol) #=&gt; :'non-interpolated symbol'%s(foo) #=&gt; :foo%s(foo bar) #=&gt; :\"foo bar\"%s(#&#123;foo&#125; bar) #=&gt; :\"\\#&#123;foo&#125; bar\"# 會將內部內容透過子 shell 來執行%x(echo #&#123; \"interpolated shell command\" &#125;) #=&gt; \"interpolated shell command\\n\"","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"CentOS Rails 環境安裝","slug":"deploy","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/deploy/","link":"","permalink":"//andyyou.github.io/2015/04/04/deploy/","excerpt":"CentOS Rails 環境安裝安裝 Apache &amp; PostgreSQL","text":"CentOS Rails 環境安裝安裝 Apache &amp; PostgreSQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212$ service --status-all # 檢查服務運行的狀態$ yum list installed # 檢查已安裝的 yum packages$ yum install httpd # 安裝 apache$ yum install postgresql postgresql-server postgresql-devel postgresql-libs # 安裝 PostgreSQL，注意沒裝 devel 和 libs 裝 gem 時會出錯。# 第一次啟動如果炸掉 ERROR: `/var/lib/pgsql/data is missing. Use “service postgresql initdb” to initialize the cluster first.`$ service postgresql initdb# 如果又遇到 Initializing database: mkdir: cannot create directory `/var/lib/pgsql/data/pg_log': File exists$ rm -rf /var/lib/pgsql/data/pg_log # 把 log 刪除$ service postgresql start # 啟動 PostgreSQL$ chkconfig postgresql on # 設定開機後自動啟動# 修改 /var/lib/pgsql/data/pg_hba.conf (預設路徑)# local all all ident sameuserlocal all all trust# host all all 127.0.0.1/32 ident sameuserhost all all 127.0.0.1/32 md5# 註：md5 和 trust 差別在於 trust 允許在本機不用輸入密碼來登入資料庫。# 由於變更設定檔需要 reload$ su - postgres$ pg_ctl reload$ psql # 進入介面開 table 或建立 users 權限# 列出 database$ \\list$ \\l# 連線該 db$ \\connect [database_name]# 重設密碼$ \\password# 在 command line 裡分成兩種方式一種是先切換成 postgres 使用者身份直接下指令，另一種是登入 psql 後下 sql 指令# 預設 PostgreSQL 只允許本機上的 user 和 PostgreSQL 中 role name 相同的帳號不用密碼登入# 預設只有 db 的 owner 可以操作裡面的東西(不包含 superuser)# 建立 db role$ createuser test_user # 這種方式會有精靈讓你選權限# SQL下指令記得加 ;# 建立 db role (SQL)$ create role [rails_user] with createdb login password 'password here';# 修改 role (SQL)$ alter role [rails_user] with createdb login password 'password here';# 列出所有使用者的權限$ \\du# 顯示所有 roles 名稱(SQL)$ select rolname from pg_roles;# 查看 table 權限$ \\z# 列出所有 table$ \\dt# 當前的使用者$ select current_user;# 當前連線的 db$ select current_database();# 離開 psql$ \\q# 檢查 PostgreSQL status$ service postgresql status# 移除 db (OSX)$ rm /usr/local/var/postgres/postmaster.pid$ dropdb rbase_test# 在 SQL 中移除 db$ drop database if exists [database name]# 列出 tables$ \\dt# 建立新資料庫$ CREATE DATABASE mydb;# 建立使用者$ CREATE USER andy with password 'p@ssw0rd';$ createuser test --interactive -P # 含建立密碼 + 權限# 連線資料庫$ \\c database# 建立 table 範例CREATE TABLE films ( code char(5) CONSTRAINT firstkey PRIMARY KEY, title varchar(40) NOT NULL, did integer NOT NULL, date_prod date, kind varchar(10), len interval hour to minute);# 列出 table schema$ \\d+ [tablename]# 刪除 tableDROP TABLE IF EXISTS table;# 插入資料INSERT INTO films VALUES('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');INSERT INTO films (code, title, did, date_prod, kind)VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama'),('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');# 選取 table 大小和隨機的指數SELECT relname, reltuples, relpages FROM pg_class ;# select size of tables and indices in descending order of sizeSELECT relname, reltuples, relpages FROM pg_class ORDER BY relpages DESC ;# select size of tables and indices in descending order of tuple- / recordcountSELECT relname, reltuples, relpages FROM pg_class ORDER BY reltuples DESC ;# 修改密碼$ su - postgres$ psql template1$ alter user postgres with password 'postgres_password';# 列出使用者SELECT * FROM \"pg_user\";# change user for all tablesfor tbl in `psql -qAt -c \"select tablename from pg_tables where schemaname = 'public';\" YOUR_DB` ; do psql -c \"alter table $tbl owner to NEW_OWNER\" YOUR_DB ; done# change user for all seqsfor tbl in `psql -qAt -c \"select sequence_name from information_schema.sequences where sequence_schema = 'public';\" YOUR_DB` ; do psql -c \"alter table $tbl owner to NEW_OWNER\" YOUR_DB ; done# change user for all viewsfor tbl in `psql -qAt -c \"select table_name from information_schema.views where table_schema = 'public';\" YOUR_DB` ; do psql -c \"alter table $tbl owner to NEW_OWNER\" YOUR_DB ; done# 複製資料庫create database NEWDB with template OLDDB;# 修改 DB owner/nameALTER DATABASE name RENAME TO newnameALTER DATABASE name OWNER TO new_owner# Showing transaction status in the psql prompt$ \\set PROMPT1 '%/%R%x%# '# from http://sql-info.de/postgresql/notes/transaction-status-in-the-psql-prompt.html# 列出資料表欄位SELECT attname FROM pg_attribute, pg_typeWHERE typname = 'table_name'AND attrelid = typrelidAND attname NOT IN ('cmin', 'cmax', 'ctid', 'oid', 'tableoid', 'xmin', 'xmax');# 備份 / 還原 使用 Dump# 備份$ pg_dump dbname &gt; outfile$ pg_dump dbname | gzip &gt; filename.gz# 還原$ psql dbname &lt; infile$ createdb dbname &amp;&amp; gunzip -c filename.gz | psql dbname# 更新$ update auth_user set is_superuser = 't' where username='abhiomkar';```[完整 PostgreSQL 建立 ROLE 教學](https://www.digitalocean.com/community/tutorials/how-to-use-roles-and-manage-grant-permissions-in-postgresql-on-a-vps--2)[OSX PostgreSQL Installing](https://marcinkubala.wordpress.com/2013/11/11/postgresql-on-os-x-mavericks/)[OSX 簡易控制 PostgreSQL](http://robots.thoughtbot.com/starting-and-stopping-background-services-with-homebrew)## 安裝 Rails```# 1. 安裝 git$ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel# 取得原始碼 https://www.kernel.org/pub/software/scm/git/$ wget https://www.kernel.org/pub/software/scm/git/git-2.2.0.tar.gz$ tar -zxf git-2.0.0.tar.gz$ make prefix=/usr/local all # 注意換路徑不需要加到 bin$ sudo make prefix=/usr/local install? Ruby with Readline 尚未測試成功# 2. 安裝 Ruby$ yum install -y gcc openssl-devel libyaml-devel libffi-devel readline-devel zlib-devel gdbm-devel ncurses-devel$ wget http://cache.ruby-lang.org/pub/ruby/2.2/ruby-2.2.0.tar.gz$ tar -zxvf ruby-2.0.0.tar.gz$ ./configure$ make &amp;&amp; make install$ gem install bundler# 安裝 Rails 之前先安裝 sqlite3$ yum install sqlite-devel$ yum install readline-devel$ gem install rails$ cd [YOUR_PROJECT]$ bundle install 常見問題日文完整教學","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"},{"name":"centos","slug":"centos","permalink":"//andyyou.github.io/tags/centos/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"Rails 簡易的實作登入","slug":"login","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/login/","link":"","permalink":"//andyyou.github.io/2015/04/04/login/","excerpt":"簡易的實作登入1. Create a User model12$ rails g model User name:string password:digest$ rake db:migrate","text":"簡易的實作登入1. Create a User model12$ rails g model User name:string password:digest$ rake db:migrate 2. Modify user.rb to have validations of name(account)1234class User &lt; ActiveRecord::Base validates :name, presence: true, uniqueness: true has_secure_passwordend 確保 name 就是帳號是唯一的，然後因為 password 的 type 為 digest 所以預設幫我們使用了 has_secure_password我們知道當我們在註冊的時候表單常常會要求我們輸入兩次密碼以確保我們設定是正確的，這就是 has_secure_password 幫我們處理的部份如果我們使用 scaffold 的話，Rails 會自動在幫我們在 model and view 加上這個，這會告訴 Rails 幫我們驗證兩個 passwords 的欄位接著 view 就會吃 :password, :password_confirmation 兩個參數，如此 model 才會驗證。 在 view 裡面 Rails 會幫我們多一組 password_confirmation 的參數，這個參數實際上並不會建在 db 裡面 3. Gemfile uncomment gem &#39;bcrypt&#39;1$ bundle install 到了這一步我們的 User model 就有驗證的功能。即 User 可以 user.authenticate接著因為 Rails 會幫我們把 hash 自動從 view 中移除，即不會顯示 password 的資料。所以我們就到 create and update 把導向 :show的部份移除，直接導回首頁。 調整完 view 之後就可以建立 Session controller。會員 controller 單純管理會員資料，而 SessionController 負責管理登入登出 1$ rails g controller Sessions new create destroy 在 session 的 create action 中我們必須要記錄一些資料在 session，好讓我們知道該 user 的身份 我們在 session controller 有三個 action 分別為 new, create, destroy new 用來顯示登入頁面create 用來登入，建立 sessiondestroy 用來刪除 session 登出 4. 登入驗證 in Session#create123456789def create user = User.find_by(name: params[:name]) if user and user.authenticate(params[:password]) session[:user_id] = user.id redirect_to root_url else redirect_to login_url endend 5. 調整 new.html.erb 用來當作登入123456789101112131415161718192021&lt;div class=\"depot_form\"&gt; &lt;% if flash[:alert] %&gt; &lt;p id=\"notice\"&gt;&lt;%= flash[:alert] %&gt;&lt;/p&gt; &lt;% end %&gt; &lt;%= form_tag do %&gt; &lt;fieldset&gt; &lt;legend&gt;Please Log In&lt;/legend&gt; &lt;div&gt; &lt;%= label_tag :name, 'Name:' %&gt; &lt;%= text_field_tag :name, params[:name] %&gt; &lt;/div&gt; &lt;div&gt; &lt;%= label_tag :password, 'Password:' %&gt; &lt;%= password_field_tag :password, params[:password] %&gt; &lt;/div&gt; &lt;div&gt; &lt;%= submit_tag \"Login\" %&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;% end %&gt;&lt;/div&gt; 6. 登出片段1234def destroy session[:user_id] = nil redirect_to root_url, notice: \"Logged out\"end 7. 調整 route1234567Sample::Application.routes.draw do controller :session do get 'login' =&gt; :new post 'login' =&gt; :create delete 'logout' =&gt; :destroy endend 8. 綁上 before_action in application_controller.rb1234567891011class ApplicationController &lt; ActionController::Base before_action :authorize private def authorize unless User.find_by(id: session[:user_id]) redirect_to login_url, notice: \"Please log in\" end endend 9. 不要驗證，在 controller 加上，記住 SessionController 自己本身要加1skip_before_action :authorize, only: :create 注意 before_action and before_filter","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"歡迎使用 Jekyll","slug":"welcome-to-jekyll","date":"2015-04-04T04:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2015/04/04/welcome-to-jekyll/","link":"","permalink":"//andyyou.github.io/2015/04/04/welcome-to-jekyll/","excerpt":"哈囉 jekyll ！這是一篇展示的文章。使用 Markdown 格式所撰寫","text":"哈囉 jekyll ！這是一篇展示的文章。使用 Markdown 格式所撰寫 123456def print_hi(name) puts \"Hi, #&#123;name&#125;\"endprint_hi('Tom')#=&gt; prints 'Hi, Tom' to STDOUT. 1234def print_hi(name) puts \"Hi, #&#123;name&#125;\"endprint_hi('Tom') 123456$ jekyll build$ jekyll build --watch$ jekyll build --source &lt;s&gt; --destination &lt;d&gt;$ jekyll serve$ jekyll serve --watch$ jekyll serve --port 8000 超連結用法 Jekyll docs &gt;for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll’s dedicated Help repository. 副檔名列表 程式語言縮寫 Rouge 支援語言列表 Try to use default markdown def say_hello puts &quot;Hello, Ruby&quot; end","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"//andyyou.github.io/tags/jekyll/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"使用 Selenium 搭配 Cloud-based 壓力測試","slug":"use-selenium-to-match-cloud-based-stress-test","date":"2014-12-23T08:47:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/12/23/use-selenium-to-match-cloud-based-stress-test/","link":"","permalink":"//andyyou.github.io/2014/12/23/use-selenium-to-match-cloud-based-stress-test/","excerpt":"這是一篇記流水帳的操作步驟，文章翻譯自微軟 Developer Tools Blogs文章加上小弟遇到的特殊情形經官方人員協助處理完成的紀錄。","text":"這是一篇記流水帳的操作步驟，文章翻譯自微軟 Developer Tools Blogs文章加上小弟遇到的特殊情形經官方人員協助處理完成的紀錄。 本文主要是介紹如何使用 Selenium 搭配微軟的雲端服務 Visual Studio Online 執行壓力測試。透過 Selenium 我們可以達到最貼近使用者操作的情形模擬。首先讓我們需要概略的認識 Visual Studio Online(VSO) 的 Cloud-based Load Testing(CLT) 和 Selenium。 Cloud-based Load Testing: 這是 Visual Studio 2013 後引入的新功能，這篇記錄就不詳細介紹關於 CLT 的部分您可以參考官方的介紹 快速入門的話可參考這個連結 Selenium Selenium 是一套模擬瀏覽器操作，自動執行的測試軟體，簡單說就是可以側錄或撰寫 script 讓它自動幫你執行，詳細介紹直接參考官方 請參考官方網站對 Selenium 的基礎操作有些瞭解，這篇文章主題為 Selenium 搭配 CLT 故如何撰寫 script 不再這篇重點 原文教學針對使用 Selenium Nuget 搭配 Phantomjs Nuget ，不過因為小弟的站大量使用 socket.io 在這邊 phantomjs 1.x 會有一些問題，所以我們補上如何使用 Firefox 當作模擬的瀏覽器 正文開始在 VS 撰寫 Selenium 單元測試【一】 首先在 VS 中建立一個單元測試專案(Unit Test Project)。 檔案 -&gt; 新增專案 -&gt; 範本 -&gt; Visual C# -&gt; 測試 -&gt; 單元測試專案 【二】 專案建立完成後，安裝 Selenium Nuget 。對專案按右鍵 -&gt; 管理 Nuget 套件 -&gt; 搜尋 Selenium -&gt; 安裝 【三】 安裝完成之後，參考目錄下應該會看到 WebDriver 【四】 下載實際使用的瀏覽器模擬驅動，原文為了單純起見使用了 PhantomJs，接著您可以在 Nuget 搜尋 PhantomJS 並且安裝，安裝後記得修改 phantomjs.exe 的屬性為有更新時才複製 【五】 建立 C# 檔案開始撰寫單元測試，您也可以先透過 Selenium IDE 側錄大部份的行為為程式碼再來修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using Microsoft.VisualStudio.TestTools.UnitTesting;using OpenQA.Selenium;using OpenQA.Selenium.PhantomJS;using System;using System.Text;namespace SeleniumSample&#123; [TestClass] public class SeleniumTests &#123; [TestMethod] public void TheBingSearchTest() &#123; TestContext.BeginTimer(\"BingSearchTest_Navigate\"); _driver.Navigate().GoToUrl(\"http://www.bing.com/\"); TestContext.EndTimer(\"BingSearchTest_Navigate\"); TestContext.BeginTimer(\"BingSearchTest_SearchBHarry\"); _driver.FindElement(By.Id(\"sb_form_q\")).SendKeys(\"Brian harry blog\"); _driver.FindElement(By.Id(\"sb_form_go\")).Click(); TestContext.EndTimer(\"BingSearchTest_SearchBHarry\"); var elementText = _driver.FindElement(By.XPath(\"//ol[@id='b_results']/li/h2/a\")); Assert.IsTrue(elementText.Text.Equals(\"Brian Harry's blog - Site Home - MSDN Blogs\"), \"Verified title of the blog page\"); &#125; public TestContext TestContext &#123; get; set; &#125; #region Additional test attributes [TestInitialize] public void SetupTestSuite() &#123; Console.WriteLine(\"Test init called: &#123;0&#125;\"); _driver = new PhantomJSDriver(); &#125; [TestCleanup] public void CleanupTestSuite() &#123; _driver.Quit(); &#125; #endregion private IWebDriver _driver; &#125;&#125; 其他範例使用 Firefox 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using System;using System.Text;using Microsoft.VisualStudio.TestTools.UnitTesting;using System.Text.RegularExpressions;using OpenQA.Selenium;using OpenQA.Selenium.Firefox;using System.Threading;using OpenQA.Selenium.Interactions;using System.Collections.Generic;using OpenQA.Selenium.Support.UI;using System.Linq;namespace PasserTesting&#123; [TestClass] public class SeleniumCase &#123; private IWebDriver _driver; private const String WEB_SITE = \"http://www.google.com\"; public TestContext TestContext &#123; get; set; &#125; [TestMethod] public void VisitGoogle() &#123; TestContext.BeginTimer(\"Begin View Index\"); _driver.Navigate().GoToUrl(WEB_SITE); TestContext.EndTimer(\"Begin View Index\"); var title = _driver.Title; Assert.IsTrue(title.Equals(\"Google\")); &#125; private bool IsElementPresent(By by) &#123; try &#123; _driver.FindElement(by); return true; &#125; catch (NoSuchElementException) &#123; return false; &#125; &#125; #region Additional test attributes [TestInitialize] public void SetupTestSuite() &#123; Console.WriteLine(\"Test init called: &#123;0&#125;\"); _driver = new FirefoxDriver(); &#125; public void CleanupTestSuite() &#123; _driver.Quit(); &#125; #endregion &#125;&#125; 【六】 對方案右鍵加入 -&gt; 新增項目 -&gt; 測試設定 -&gt; 加入測試設定檔案 【七】 設定測試設定的部署加入 phantomjs.exe 【八】 建置方案 【九】 從 測試 -&gt; 測試設定 -&gt; 選取測試設定擋 【十】 先透過測試總管(Test Explorer)在本機驗證測試 (測試 -&gt; 視窗 -&gt; 測試總管) 到此我們已經完成測試的流程，接著要設定上 CLT 執行 為單元測試加上負載測試【一】 替專案加上負載測試(右鍵 -&gt; 加入負載測試) 根據精靈提示設定您需要的情節 【二】 在本地端驗證設定執行的狀況 透過 Visual Studio Online 執行 Selenium 測試搭配 CLT【一】 恭喜！接下來您只要一個鍵就能夠在 Microsoft Azure Cloud 執行您的測試【二】 當負載測試加完之後，在 測試 -&gt; 測試設定 -&gt; 選取測試檔案 選擇之前建立的 .testsettings【三】 打開這個測試檔案把設定改成使用 VSO 想瞭解更多關於壓力測試請參考 【四】 當執行全部完成之後你就可以下載報告。就可以點擊檢視報告上方的連結 【五】 最後您可以得到關於你這次的測試資料大略如下圖 使用 Firefox(暫時的解決方案，官方表示正在處理更完整的方式)當您因為一些其他原因無法使用 PhantomJS 當作 WebDriver 時這裏提供另外一個方案 【一】 首先我們必須要雲上裝上 Firefox 所以我們必須要提供一段 script 讓雲上的機器自己安裝 Firefox 12345678910111213141516171819202122232425262728293031323334353637::::::::::::::::::::::::::::::::::::::::::: Automatically check &amp; get admin rights:::::::::::::::::::::::::::::::::::::::::@echo offCLSECHO.ECHO =============================ECHO Running Admin shellECHO =============================:checkPrivilegesNET FILE 1&gt;NUL 2&gt;NULif '%errorlevel%' == '0' ( goto gotPrivileges ) else ( goto getPrivileges ):getPrivilegesif '%1'=='ELEV' (shift &amp; goto gotPrivileges)ECHO.ECHO **************************************ECHO Invoking UAC for Privilege EscalationECHO **************************************setlocal DisableDelayedExpansionset \"batchPath=%~0\"setlocal EnableDelayedExpansionECHO Set UAC = CreateObject^(\"Shell.Application\"^) &gt; \"%temp%\\OEgetPrivileges.vbs\"ECHO UAC.ShellExecute \"!batchPath!\", \"ELEV\", \"\", \"runas\", 1 &gt;&gt; \"%temp%\\OEgetPrivileges.vbs\"\"%temp%\\OEgetPrivileges.vbs\"exit /B:gotPrivileges::::::::::::::::::::::::::::::START::::::::::::::::::::::::::::setlocal &amp; pushd .\"%~dp0\\Firefox.exe\" /S 【二】 要執行這段 setup script 我們需要先在方案的資料夾下建立一個 Deployment 資料夾把上面那段 script 放入並且命名為 setup.cmd【三】 下載要安裝的 Firefox.exe 放置到一樣的 Deployment 目錄【四】 開啟 Visual Studio 對 .testsettings 點擊兩下開啟如下設定 【五】 加入 Deployment 目錄後下一步設定指令碼，選擇剛剛在同個目錄下的 setup.cmd","categories":[{"name":"Cloud","slug":"Cloud","permalink":"//andyyou.github.io/categories/Cloud/"}],"tags":[{"name":"azure","slug":"azure","permalink":"//andyyou.github.io/tags/azure/"},{"name":"selenium","slug":"selenium","permalink":"//andyyou.github.io/tags/selenium/"}],"keywords":[{"name":"Cloud","slug":"Cloud","permalink":"//andyyou.github.io/categories/Cloud/"}]},{"title":"輕鬆學 Flux","slug":"fools-learn-flux","date":"2014-11-15T12:58:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/11/15/fools-learn-flux/","link":"","permalink":"//andyyou.github.io/2014/11/15/fools-learn-flux/","excerpt":"前言小弟身為一個資質駑鈍的人，這正是我在學習 Flux 初期最希望有人可以幫我總結的事。服用本篇前須對 React 有基本的認識。因為底子不好在參透官方範例時一直東奔西跑的查資料一下這個 merge 是什麼意思，一下又怎麼這邊一個 Dispatcher, AppDispatcher 然後又 ActionCreator總之是你搞得我好亂啊。不過因為最近 React 的盛行讓我得以閱讀許多大大的分享因而有這一篇","text":"前言小弟身為一個資質駑鈍的人，這正是我在學習 Flux 初期最希望有人可以幫我總結的事。服用本篇前須對 React 有基本的認識。因為底子不好在參透官方範例時一直東奔西跑的查資料一下這個 merge 是什麼意思，一下又怎麼這邊一個 Dispatcher, AppDispatcher 然後又 ActionCreator總之是你搞得我好亂啊。不過因為最近 React 的盛行讓我得以閱讀許多大大的分享因而有這一篇 我應該使用 Flux 嗎？如果您的應用程式需要處理很多動態的資料那麼答案是 YES! 您可能應該使用 Flux但如果您的應用程式只是靜態頁面，且不需要去共用一些應用程式的狀態，也從來不需要更新資料那麼這個答案就是 NOFlux 不能帶給你任何好處 為什麼要用 Flux?Flux 是一個相當複雜的概念，為什麼要增加程式的複雜度呢？哈！開玩笑的！！百分之九十的 iOS 應用程式透過 table view 來呈現資料。iOS toolkit 擁有非常好的架構來處理關於資料模型的問題，這使得開發起來非常容易。 不過在前端的世界(HTML, Javascript, CSS) 我們沒有那些東西也沒人強迫我們一定得用這些，取而代之的是我們有一個大問題。沒人知道該怎麼完美的處理前端架構這個問題。處理前端的工作已經好一陣子了，所謂的最佳實踐從來沒有完美的解決所有問題，現實反而是針對個別小問題的函式庫解決了他們jQuery? Backbone? Handlebars? 其實我們也都知道真正的問題是關於資料，一但它邏輯和 UX 變得越來越複雜就很少人可以精準的控制他。 什麼是 Flux?Flux 是一個 Facebook 創造的術語: 用來描述單一方向的資料流搭配特定的事件和註冊監聽的設計模型。並沒有一定是指 Flux 的函式庫，不過您的確需要 Flux Dispatcher 以及事件函式庫。官方文件是用一種概念的方式在介紹因此對於像我這種資質比較差的人的確不是個很好的起點。沒幫我分解片段片段程式碼就吸收得很慢。不過一旦你了解了關於 Flux 的想法您應該就能夠讀懂那些東西。 先不要試圖去比較 Flux 和 MVC 結構，把它們兩者搞在一起的話只會得到混亂。 OK! 談論夠多了，讓我們慢慢的探討，這篇文章將會慢慢解釋所有概念佐以程式碼。 1. 你的 Views (React Component) 分派了動作一個 dispatcher 本質上是一套事件機制。它負責廣播事件和註冊回呼函式(callback)。而且全部就只有一個，一個全域的 dispatcher 物件。為了讓事情單純你應該就直接使用 Facebook 的 Dispatcher Library 官方在解釋 Dispatcher 那段一開始的確讓我慌了。 12var Dispatcher = require('flux').Dispatcher;var AppDispatcher = new Dispatcher(); 接著我們假設您的應用程式中有一個新增的按鈕功能是加入一個項目到清單中: 1&lt;button onClick=&#123; this.createNewItem &#125;&gt;New Item&lt;/button&gt; 當按鈕點擊的時候會發生什麼事情呢？您的 View 派送了一個非常特別的事件，這個事件包含著兩件事事件名稱和該項目的資料 12345678createNewItem: function( evt ) &#123; AppDispatcher.dispatch(&#123; eventName: 'new-item', newItem: &#123; name: 'Andy' &#125; // example data &#125;);&#125; 2. 您的 Store 需要回應被派送來的事件就像 Flux 一樣 “store” 也是 Facebook 創造的術語。對於我們的應用程式來說，我們需要一個邏輯集合(就是處理邏輯的物件)與資料來處理這份清單。這指的就是 Store ，它不只要管理資料模型也需要回應上面提到的特殊的事件。在這邊我們就稱它為 ListStore一個 store 本身是單獨的物件，應該就只有一個，意思是你不應該 new 出另外一個物件。換言之我們的 ListStore 是獨一無二全域的物件。 123456789101112// 一個全域物件用來處理清單資料和邏輯var ListStore = &#123; // 實際資料模型的集合 items: [], // 存取方法，後續我們將使用它來取得資料 getAll: function() &#123; return this.items; &#125;&#125;; 這個 store 接著要回應 dispatcher 發過來的特殊事件。 12345678910111213141516var ListStore = …AppDispatcher.register( function( payload ) &#123; switch( payload.eventName ) &#123; case 'new-item': ListStore.items.push( payload.newItem ); break; &#125; return true;&#125;); 這是典型的 Flux 處理回應 dispatcher 派送過來的 action 的機制。每一個 payload 包含著事件名稱和資料，透過 dispatcher 分派過來。好了我們同時解釋了在官網那張圖上的 action 與 payload 。 dispatcher.dipatch({}) 發動這個 method =&gt; 派送一個 action{} 裡面的物件我們稱為 payload 接著用一個 switch 程式片段用來決定該執行什麼動作。 核心概念 1: 一個 store 不只是一個資料模型，但其包含著資料模型。 核心概念 2: store 在程式中是唯一知道該如何更新資料的角色。這也是整個 Flux 最重要的部分。dispatcher 觸發的事件並不知道如何處理資料。對應回官方的說明這叫做一個 action。 對應的行為是寫在 store 然後透過 AppDispatcher.register 註冊。 舉例來說如果有其他部分需要追蹤關於圖片的資料您就應該再開一個 store 並叫做 ImageStore。一個 store 只負責處理單一需求。當您的程式變大的時候可以很輕易地根據需求找到對應的部分。如果程式不複雜可能您只需要一個 store。 記住！只有 store 是被允許註冊 dispatcher 的 callback。View 永遠不會呼叫 AppDispatcher.register 。而 dispatcher 也只能夠從 View 送訊息到 store。 3. Store 觸發了一個 “Change” 事件我們幾乎快學完了！現在您的資料確實已經改變了，但是我們需要通知程式中其他角色。store 接著會觸發一個事件，但不是靠 dispatcher 。這邊通常是初學者容易搞混的地方，但這就是 Flux 採用的方式。這邊我們讓 store 具備有觸發事件的能力方法有很東種例如使用 MicroEvent 或者採用 EventEmitter。這邊為了讓你釐清觀念也不要加入太多東西所以我們先用 MicroEvent 其觀念就是讓 Store 具備廣播事件的能力，你可能就會問廣播什麼事件？大略你可以先理解成這是一個發佈/訂閱的事件機制。當 store 告訴全世界: 嘿！我飯煮好了！該吃飯的人就自己自動過來吃 XD。 註: 官方採用的方式可能一直在調整，從 merge 到 object-assign 其實觀念都是一樣的就是讓 store 具備廣播事件的能力且官方使用 EventEmitter。 這邊我們就透過 MicroEvent 讓 store 可以通知全世界: 1MicroEvent.mixin( ListStore ); 好了！store 已經具備該能力了那就直接在下面呼叫 1234567891011121314151617AppDispatcher.register( function( payload ) &#123; switch( payload.eventName ) &#123; case 'new-item': ListStore.items.push( payload.newItem ); // 告訴其他人我已經改變好了 ListStore.trigger( 'change' ); break; &#125; return true;&#125;); 核心觀念: 當我們觸發事件時我們不需要再把資料帶出去。view 只需要知道資料已經有更新了。讓我們繼續看下去來理解原理 4. View 回應 Change 事件現在我們需要顯示清單。當清單發生改變，我們的 view 將會全部重新渲染輸出，沒有錯是全部！為了讓 view 知道何時該更新，從 view 被掛載後它就必須監聽從 store 發出的 change 事件。 123componentDidMount: function() &#123; ListStore.bind( 'change', this.listChanged );&#125;, 為了簡單起見，我們會使用 forceUpdate 強制重新渲染。另一個方法是將整個清單存到 state。在 React 元件內的方法就會如下: 1234listChanged: function() &#123; // Since the list changed, trigger a new render. this.forceUpdate();&#125;, 別忘記當卸載時把監聽清除 123componentWillUnmount: function() &#123; ListStore.unbind( 'change', this.listChanged );&#125;, 然後呢？讓我們來看看 render 函式，我們特意保留到最後再看 123456789101112131415161718192021222324render: function() &#123; // 記住, ListStore 是全域物件! // 透過它取得資料 var items = ListStore.getAll(); var itemHtml = items.map( function( item ) &#123; return &lt;li key=&#123; listItem.id &#125;&gt; &#123; listItem.name &#125; &lt;/li&gt;; &#125;); return &lt;div&gt; &lt;ul&gt; &#123; itemHtml &#125; &lt;/ul&gt; &lt;button onClick=&#123; this.createNewItem &#125;&gt;New Item&lt;/button&gt; &lt;/div&gt;;&#125; 好了！我們已經完成整個循環。當你加入新的項目 -&gt; view 透過 dispatcher 派送一個 action -&gt; store 回應這個 action 處理資料(處理的 callback 已經被註冊到 dispatcher) -&gt; store 處理完畢觸發 change 事件-&gt; view 因為有監聽這個事件所以做出對應的處理更新。 不過這邊還有一個問題，每一次我們都重新渲染了整個 view ，這難道不會造成什麼效能異常糟糕嗎？ 不會！ 沒錯我們的確是讓 render 方法重新在渲染一次，所有在 render 內部的程式碼會重跑一次，不過 React 只會在當資料有所改變的時候才會更新實際的 DOM，關於 render 事實上他只是產生一個虛擬的 DOM。然後 React 會自動去和上一次的比較，如果兩個虛擬的 DOM 不同的話 React 才會更新實際的 DOM 而且是只有實際 DOM 不同的地方而已。 核心觀念: 當 store 的資料改變 view 不需要知道資料到底是增加還是減少或者修改，view 只要負責重新輸出整個元件，接著 React 的虛擬 DOM 機制會幫你處理如何有效率的更新 DOM。是不是整個變得很單純。 還有一個東西: Action Creator 是什麼鬼？記得，當我們點擊我們的按鈕時我們派送了一個特殊的事件: 1234AppDispatcher.dispatch(&#123; eventName: 'new-item', newItem: &#123; name: 'Andy' &#125;&#125;); 如果很多 view 需要這一個事件，那麼很快這一小段程式碼將到處重複，很快當你需要修改的時候又會搞不清楚。Flux 建議我們將這些派送的事件抽象化，叫做 action creator。就只是把這些 AppDispatcher.dispatch 根據其功能分門別類，這樣其他 view 要用就只要引用就好 12345678910ListActions = &#123; add: function( item ) &#123; AppDispatcher.dispatch(&#123; eventName: 'new-item', newItem: item &#125;); &#125;&#125;; 現在您的 view 就可以單純呼叫 ListActions.add 。 希望到這邊為止可以建立起 Flux 的概念，剩下的就在看看官方的範例應該就比較看得懂了。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Flux 概念詳述篇","slug":"flux-notes","date":"2014-11-11T04:25:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/11/11/flux-notes/","link":"","permalink":"//andyyou.github.io/2014/11/11/flux-notes/","excerpt":"介紹還記得之前小弟很認真的想跟大家分享 Flux 不過老實說在當時自己只能夠”模仿”，Dispatcher 和 Store 的觀念也有點模糊。由於今天看了這篇文章之後，覺得很不錯所以來補貼一下。不過在這之前強烈推薦您還是先閱讀關於 Reactjs 的部分。","text":"介紹還記得之前小弟很認真的想跟大家分享 Flux 不過老實說在當時自己只能夠”模仿”，Dispatcher 和 Store 的觀念也有點模糊。由於今天看了這篇文章之後，覺得很不錯所以來補貼一下。不過在這之前強烈推薦您還是先閱讀關於 Reactjs 的部分。 什麼是 Flux再一次我們說 Flux 是 Facebook 內部搭配 React 使用的一種架構，一種設計模式。它不是一個 Framework 或 Library 。它單純是一種新的架構用來搭配補充 React 以及其單向資料流的概念。然而我們也知道 Facebook 有提供一個 Dispatcher 的函式庫。這個 Dispatcher 是一個全域的發佈/訂閱處理函式庫，他可以廣播 payload (實際資料) 到被註冊的 callback 回呼函式。一個典型的 Flux 架構將會使用這個 Dispatcher 函式庫配合 Nodejs 的 EventEmitter 模組來達成設置一個事件系統以協助管理應用程式的狀態。如果用另一個角度來說那就是 Dispatcher 其實就只是處理事件的註冊與廣播，概念上我們可以先理解為一個 Pub/Sub 機制，各自把自己需求的事件註冊到這個管理中心，接著如果廣播觸發某一事件的時候所有對應的事件都要被執行，而實際實作面就是透過 EventEmitter 來完成，想看實際的程式碼大概就是如下: 12345678var EventEmitter = require('events').EventEmitter, person = new EventEmitter();person.on('speak', function() &#123; console.log('I am here');&#125;);person.emit('speak'); 要解釋 Flux 比較好的方式可能是透過說明每一個組成的局部: Actions - 輔助函式 Helper methods, 單純只是便利我們將資料傳給 Dispatcher Dispatcher - 接收 Actions 以及廣播 payloads 到被註冊的回呼函式(callback) Stores - 應用程式狀態和處理邏輯(即那些被註冊到 Dispatcher 的回呼函式)的容器， Controller Views - 一般來說就是那些負責管理 State ，把狀態透過 props 往下傳遞到子元件的 React 元件 看起來就會像下圖: 怎麼 API 也有關聯？ 當你需要處理來自外部的資料，我們發現透過 Actions 來讓資料進入 Flux 流程接著進入 Stores 後續各個流程都將比較方便，是最無痛的方式。 Dispatcher所以到底什麼是 Dispatcher ?基本上 Dispatcher 管理著整個流程。他就像是您應用程式的中央集線器，或者要把它比喻成電話總機。Dispatcher 收到 Actions 來的執行動作，接著分派這個動作和資料去給那些註冊的回呼函式。 所以本質上這就只是一個 發佈/訂閱 系統？不全然是， Dispatcher 會廣播 payload 就是實際要傳遞的資料到所有被註冊的回呼函式包含讓你以特定順序執行回呼的功能，甚至是在執行之前先等更新完成。記住在您的程式中永遠只有一個 Dispatcher ，只有一個總機小姐XD 接著讓我們來看看程式碼的部分: 1234567891011var Dispatcher = require('flux').Dispatcher;var AppDispatcher = new Dispatcher();AppDispatcher.handleViewAction = function(action) &#123; this.dispatch(&#123; source: 'VIEW_ACTION', action: action &#125;);&#125;module.exports = AppDispatcher; 在上面的範例，我們建立了一個 Dispatcher 的實例物件，建立了一個 handleViewAction 的方法。這樣的抽象化有助於區分是 View 觸發 Action 或者 Server/API 觸發 Action。dispatch method 就是用來廣播 action 和 payload 到回呼函式。這個 action 接著就會觸發 Stores 內實際的行為函式然後更新狀態。圖解如下 相依性Dispatcher 模組提供的其中一個最酷的部分就是可以替回呼函式定義相依性和序列化。所以當其中一個函式需要相依於另外一個時，為了適當的輸出，您可以使用 Dispatcher 的 waitFor 方法。為了利用這個特性，我們需要在 Store 回傳並儲存 Dispatcher 的識別索引，而方式就是透過儲存 register 方法回傳的值。程式碼範例如下: 123ShoeStore.dispatcherIndex = AppDispatcher.register(function(payload) &#123;&#125;); 然後在我們的 Store 裡，當處理一個被分派的 action 時我們就可以使用 waitFor 來確保上面那個回呼函式已經被執行 1234567case 'BUY_SHOES': AppDispatcher.waitFor([ ShoeStore.dispatcherIndex ], function() &#123; CheckoutStore.purchaseShoes(ShoeStore.getSelectedShoes()); &#125;); break; Stores在 Flux 中，Stores 針對特定需求管理應用程式的狀態。這基本上是指針對每一個應用程式，stores 管理著資料，接收資料的方法和 dispatcher 的回呼函式。讓我們來看看 Store 的程式碼: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var AppDispatcher = require('../dispatcher/AppDispatcher');var ShoeConstants = require('../constants/ShoeConstants');var EventEmitter = require('events').EventEmitter;var merge = require('react/lib/merge');// shoes 物件，用在內部處理資料var _shoes = &#123;&#125;;// 從 action 載入 shoes 資料function loadShoes(shoes) &#123; _shoes = data.shoes;&#125;// 將我們的 store 物件與 Node 的 Event Emitter 合體var ShoeStore = merge(EventEmitter.prototype, &#123; // 取得所有鞋子資料 getShoes: function() &#123; return _shoes; &#125;, emitChange: function() &#123; this.emit('change'); &#125;, addChangeListener: function(callback) &#123; this.on('change', callback); &#125;, removeChangeListener: function(callback) &#123; this.removeListener('change', callback); &#125;&#125;);// 註冊 dispatcher callbackAppDispatcher.register(function(payload) &#123; var action = payload.action; var text; // 定義如何處理特定動作 action switch(action.actionType) &#123; case ShoeConstants.LOAD_SHOES: loadShoes(action.data); break; default: return true; &#125; // 當 action 執行完畢則觸發 change event ShoeStore.emitChange(); return true;&#125;);module.exports = ShoeStore; 上面程式碼中最重要的一件事就是我們擴充了 store 的功能加入了 EventEmitter。之後我們的 Stores 就可以監聽和廣播事件。而我們的 View 和元件就可以根據事件來更新，因為 Contriller View 監聽 Stores，利用觸發 change event 就可以讓 Controller View 知道程式的狀態已經變更了該更新狀態。我們同時也透過 register 方法註冊了一個 Callback 到 AppDispatcher ，這麼一來 Store 就開始監聽 AppDispatcher 的廣播。上面的 switch 敘述式會決定處理的方式針對對應的 action 然後發出一個廣播，接著觸發 change event 因為 view 監聽著 change event 所以就可以根據事件來更新狀態。 Controller View 就可以透過 getShoes 來檢索 _shoes 裡面的資料，當然這只是一個單純的範例，複雜的邏輯都可以放在這邊。 Action Creators 和 ActionsAction Creators 是一系列方法的集合，我們可以在 View 呼叫他們，透過他們把 action 發送給 Dispatcher. Actions 實際上只是透過 dispatcher 來分派實際資料。關於 Facebook 如何使用它們 - action 類型常數被用來定義該執行什麼樣的行為，並且包含著資料一起被送出。在註冊的回呼函式裡這些 action 可以根據”類型”被處理，且方法可把 action 中的 data 當作參數。 讓我們來看看關於常數是如何定義的: 12345var keyMirror = require('react/lib/keyMirror');module.exports = keyMirror(&#123; LOAD_SHOES: null&#125;); 上面程式碼，我們使用了 React 的 keyMirror 函式庫，沒錯！您已經猜到了。鏡射我們的 keys 所以我們的值就會直接等於我們的 key. 1&#123; LOAD_SHOES: 'LOAD_SHOES' &#125; 之後我們只要透過觀察這支檔案，我們就能得知關於 ShoeStore 的行為，透過常數幫助我們讓事情更具有組織性，也能讓我們得知關於這個程式實際上在做什麼。 現在我們可以來看看對應的 Action Creator 123456789101112131415var AppDispatcher = require('../dispatcher/AppDispatcher');var ShoeStoreConstants = require('../constants/ShoeStoreConstants');var ShoeStoreActions = &#123; loadShoes: function(data) &#123; AppDispatcher.handleAction(&#123; actionType: ShoeStoreConstants.LOAD_SHOES, data: data &#125;) &#125;&#125;;module.exports = ShoeStoreActions; 在上面的範例中，我們在 ShoeStoreActions 建立了一個方法，它可以呼叫 dispatcher 並傳入我們提供的資料。現在我們就能夠在我們的 view 或者 API 匯入這隻 actions 檔案透過 ShoeStoreActions.loadShoes(ourData) 把資料和 actionType 傳給 Dispatcher 並廣播。接著 ShoeStore 將會聽到該事件被呼叫而去執行對應的方法來載入鞋子的資料。 Controller ViewsController Views 就只是 React 元件且該元件正監聽著 change event ，從 Stores 接受應用程式的狀態和資料。當然它可以把資料透過 props 傳遞給子元件。 程式碼看起來便會如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** @jsx React.DOM */var React = require('react');var ShoesStore = require('../stores/ShoeStore');// Method to retrieve application state from storefunction getAppState() &#123; return &#123; shoes: ShoeStore.getShoes() &#125;;&#125;// Create our component classvar ShoeStoreApp = React.createClass(&#123; // Use getAppState method to set initial state getInitialState: function() &#123; return getAppState(); &#125;, // Listen for changes componentDidMount: function() &#123; ShoeStore.addChangeListener(this._onChange); &#125;, // Unbind change listener componentWillUnmount: function() &#123; ShoesStore.removeChangeListener(this._onChange); &#125;, render: function() &#123; return ( &lt;ShoeStore shoes=&#123;this.state.shoes&#125; /&gt; ); &#125;, // Update view state when change event is received _onChange: function() &#123; this.setState(getAppState()); &#125;&#125;);module.exports = ShoeStoreApp; 上面的範例中，我們透過 addChangeListener 把對應更新的事件註冊進去，當事件被廣播時元件就可以執行 this._onChange 函式來更新元件的狀態。應用程式的狀態和資料都被保存在 Stores，所以我們可以使用 Stores 中任何 public 的方法來取得資料或狀態。 結合所有的東西現在我們已經各別解釋關於 Flux 結構的每個部分，我們應該具備關於這個架構實際上是如何運作的觀念，讓我們更仔細地來看看下面運作的圖示","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"},{"name":"flux","slug":"flux","permalink":"//andyyou.github.io/tags/flux/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 實作一個 Tabs 元件","slug":"reactjs-implemented-a-tabs-component","date":"2014-10-07T01:13:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/10/07/reactjs-implemented-a-tabs-component/","link":"","permalink":"//andyyou.github.io/2014/10/07/reactjs-implemented-a-tabs-component/","excerpt":"實作一個 Tabs 元件複合式(組合)元件在 React 中任何東西都是元件，就像樂高一樣，你可以用小片的積木組成大塊的，再組合出您想到的東西。同樣的道理您也可以用許多的小元件(小功能模組)來組合出您的應用程式。所謂的複合式元件或稱作組合元件，他其實就是由多個元件去組成一個多功能的大元件。","text":"實作一個 Tabs 元件複合式(組合)元件在 React 中任何東西都是元件，就像樂高一樣，你可以用小片的積木組成大塊的，再組合出您想到的東西。同樣的道理您也可以用許多的小元件(小功能模組)來組合出您的應用程式。所謂的複合式元件或稱作組合元件，他其實就是由多個元件去組成一個多功能的大元件。 在這篇文章我們要來建立一個 tabs 標簽切換功能的元件，為了達成這個功能我們需要 4 個不同的元件:&lt;Tabs /&gt;, &lt;TabList /&gt;, &lt;Tab /&gt; 和 &lt;TabPanel /&gt; 分別用來呈現整個 tabs ， 列出 標簽列，標簽列的按鈕，以及顯示的內容。結構如下: 123456789101112131415161718&lt;Tabs&gt; &lt;TabList&gt; &lt;Tab&gt;Iron man&lt;/Tab&gt; &lt;Tab&gt;Superman&lt;/Tab&gt; &lt;Tab&gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanel&gt; 鋼鐵人介紹 &lt;/TabPanel&gt; &lt;TabPanel&gt; 超人介紹 &lt;/TabPanel&gt; &lt;TabPanel&gt; 鹿茸介紹 &lt;/TabPanel&gt;&lt;/Tabs&gt; 首先是 &lt;Tabs/&gt; 的行為，它被用來當做一個容器，其角色有點像是一個 controller ，因為它必須要掌管所有 DOM 的事件(點擊 Tab 切換至該內容，被選取到的 index)同時也需要管理 state 看看哪個 &lt;Tab/&gt; 目前正被選取到，所以我們會稱 &lt;Tabs /&gt; 為擁有者元件(owner component)。 我們遭遇到的第一個挑戰是: 元件之間該如何溝通。每一個元件都有一個 state 。每當 state 發生變動，React 就會更新並重新渲染元件以使其跟 state 一致。當我們選了某個索引後，&lt;Tabs/&gt; 元件就要去更新 &lt;Tab/&gt; 和 &lt;TabPanel/&gt; 的 state。 典範轉移首先我們為每一個元件建立一個 API，透過建立一個方法來變更 state。在 React 中一個元件可以透過 this.props.children 去存取子元件。所以一開始我們理論上只要使用 handleSelected 去設定適當該顯示的子元件如下: 12345var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1), index = this.state.selectedIndex;tabs[index].handleSelected(true);panels[index].handleSelected(true); 這樣的做法在 v0.10.0 以前的版本是可以運作的，概略的實作如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;div data-height=\"268\" data-theme-id=\"8540\" data-slug-hash=\"oitzv\" data-default-tab=\"js\" data-user=\"AndyYou\" class='codepen'&gt;&lt;pre&gt;&lt;code&gt;/** * @jsx React.DOM */var Tab = React.createClass(&#123; getInitialState: function () &#123; return &#123;selected: false&#125; &#125;, handleSelected: function (status) &#123; this.setState(&#123;selected: status&#125;); &#125;, render: function () &#123; var cx = React.addons.classSet; var classes = cx(&#123; &amp;#x27;react-tab&amp;#x27;: true, &amp;#x27;active&amp;#x27;: this.state.selected &#125;); return ( &amp;lt;li className=&#123;classes&#125;&amp;gt; &amp;lt;a href=&amp;#x27;#&amp;#x27; data-index=&#123;this.props.index&#125;&amp;gt;&#123;this.props.children&#125;&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; ); &#125;&#125;);var TabList = React.createClass(&#123; render: function () &#123; return ( &amp;lt;ul className=&amp;#x27;react-tab-list&amp;#x27;&amp;gt; &#123;this.props.children&#125; &amp;lt;/ul&amp;gt; ); &#125;&#125;);var Tabs = React.createClass(&#123; getInitialState: function () &#123; return &#123;selectedIndex: 0&#125; &#125;, componentDidMount: function () &#123; var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1), index = this.state.selectedIndex; for (i in tabs) &#123; if (i == index) &#123; tabs[i].handleSelected(true); panels[i].handleSelected(true); &#125; else &#123; tabs[i].handleSelected(false); panels[i].handleSelected(false); &#125; &#125; &#125;, handleClick: function (e) &#123; var index = parseInt(e.target.getAttribute(&amp;#x27;data-index&amp;#x27;)); var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1); for (i in tabs) &#123; if (i == index) &#123; tabs[i].handleSelected(true); panels[i].handleSelected(true); &#125; else &#123; tabs[i].handleSelected(false); panels[i].handleSelected(false); &#125; &#125; &#125;, render: function () &#123; return ( &amp;lt;div className=&amp;#x27;react-tabs&amp;#x27; onClick=&#123;this.handleClick&#125;&amp;gt; &#123;this.props.children&#125; &amp;lt;/div&amp;gt; ); &#125;&#125;);var TabPanel = React.createClass(&#123; getInitialState: function () &#123; return &#123;selected: false&#125; &#125;, handleSelected: function (status) &#123; console.log(this.props.name + &amp;#x27; selected: &amp;#x27; + status); this.setState(&#123;selected: status&#125;); &#125;, render: function () &#123; var cx = React.addons.classSet; var classes = cx(&#123; &amp;#x27;react-tab-panel&amp;#x27;: true, &amp;#x27;active&amp;#x27;: this.state.selected &#125;); return ( &amp;lt;div className=&#123;classes&#125;&amp;gt; &#123;this.props.children&#125; &amp;lt;/div&amp;gt; ) &#125;&#125;);var App = React.createClass(&#123; render: function () &#123; return ( &amp;lt;div className=&amp;#x27;container&amp;#x27;&amp;gt; &amp;lt;Tabs&amp;gt; &amp;lt;TabList&amp;gt; &amp;lt;Tab name=&amp;#x27;ironman&amp;#x27; index=&#123;0&#125;&amp;gt;Iron man&amp;lt;/Tab&amp;gt; &amp;lt;Tab name=&amp;#x27;superman&amp;#x27; index=&#123;1&#125;&amp;gt;Superman&amp;lt;/Tab&amp;gt; &amp;lt;Tab name=&amp;#x27;lucy&amp;#x27; index=&#123;2&#125;&amp;gt;Lucy&amp;lt;/Tab&amp;gt; &amp;lt;/TabList&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-ironman&amp;#x27;&amp;gt; 鋼鐵人 &amp;lt;/TabPanel&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-superman&amp;#x27;&amp;gt; 超人再起 &amp;lt;/TabPanel&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-lucy&amp;#x27;&amp;gt; 露西 &amp;lt;/TabPanel&amp;gt; &amp;lt;/Tabs&amp;gt; &amp;lt;/div&amp;gt; ); &#125;&#125;);React.renderComponent( &lt;App /&gt;, document.getElementById(\"example\")); See the Pen oitzv by AndyYou (@AndyYou) on CodePen. 不過到了 React v0.10.0 版本的時候這樣做會出現警告: 1Invalid access to component property \"setSelected\" 到了 v0.11.0 的時候更慘您已經無法直接存取子元件的方法，因為是新版的 React this.props.children 回傳的物件只是描述物件(discriptors)。不再是對應元件的參考物件，且官方建議您不應該直接存取子元件的實際物件。 Component RefsReact 提供一種機制給你取得實際元件的物件，就是使用 refs 1234567891011121314151617var App = React.createClass(&#123; handleClick: function () &#123; alert(this.refs.myInput.getDOMNode().value); &#125;, render: function () &#123; return ( &lt;div&gt; &lt;input ref=\"myInput\"/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt; Submit &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;); 透過 refs 屬性您就可以取得該子元件的參考 動態的子元件典型的 refs 使用方式是父元件已經知道子元件的情況，所以可以直接在 tag 中指定 ref 如上面的範例。不過這次我們希望我們的 Tabs 元件可以動態的放入 &lt;Tab/&gt; 和 &lt;TabPanel/&gt;例如: 123456789101112131415161718192021222324252627var App = React.createClass(&#123; render: function () &#123; return ( &lt;div className='container'&gt; &lt;Tabs&gt; &lt;TabList&gt; &lt;Tab name='ironman' &gt;Iron man&lt;/Tab&gt; &lt;Tab name='superman' &gt;Superman&lt;/Tab&gt; &lt;Tab name='lucy' &gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanel name='panel-ironman'&gt; 鋼鐵人 &lt;/TabPanel&gt; &lt;TabPanel name='panel-superman'&gt; 超人再起 &lt;/TabPanel&gt; &lt;TabPanel name='panel-lucy'&gt; 露西 &lt;/TabPanel&gt; &lt;/Tabs&gt; &lt;/div&gt; ); &#125;&#125;); 而 Tabs 只是動態地把開發者加入的任意結構輸出 123456789var Tabs = React.createClass(&#123; render: function () &#123; return ( &lt;div className='react-tabs'&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;); 因此我們需要一些動態指定 refs 的方法，而這個方法就是透過 cloneWithProps 12345678910111213141516var App = React.createClass(&#123; render: function () &#123; var index = 0, children = React.Children.map(this.props.children, function (child) &#123; return React.addons.cloneWithProps(child, &#123; ref: 'child-' + (index++) &#125;); &#125;); return ( &lt;div&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;);","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 大解密","slug":"reactjs-reactjs-decrypt","date":"2014-09-19T16:43:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/20/reactjs-reactjs-decrypt/","link":"","permalink":"//andyyou.github.io/2014/09/20/reactjs-reactjs-decrypt/","excerpt":"React 揭秘關於這篇文章將會試著解釋關於 React 核心的概念。","text":"React 揭秘關於這篇文章將會試著解釋關於 React 核心的概念。 鳥瞰架構在傳統的網頁應用程式中，我們如果要增加互動性時勢必廣泛的操作 DOM 元素，一般來說現在最普遍的技術是使用 jQuery:上圖我們故意讓 DOM 示意為紅色這是因為操作更新 DOM 是需要付出昂貴的代價，也意味著這很吃效能。很多時候我們會使用 Model 來記錄關於 APP 狀態，不過通常我們最後目標是必須要將狀態呈現給使用者，所以我們必須自己實作這些細節。這已經是我們很稀鬆平常的開發模式。 而 React 的主要目標就是提供一種不同且更有效率的方式去執行關於操作更新 DOM 這個部分，最終這個方式會取代我們直接操作 DOM 的方法。React 使用的方式是透過建立一套虛擬 DOM 的機制，React 幫你處理關於操作 DOM 方面的事情。 為什麼多引進一層架構會讓效能增加? 如果在其架構之上多引入一層可以提升速度，這不是暗示瀏覽器並沒有實作最佳的 DOM 操作方式。這也意味著虛擬 DOM 有著跟實際 DOM 不同的語義和行為。值得關注的是當我們改變虛擬 DOM 時並不能保證立即得到效果。也因為這個機制導致 React 在實際接觸 DOM 之前必須要等待事件回圈結束。在同一時間它會去計算最小差異並盡可能的用最少的步驟去更新 DOM。 如此一來應用程式便能獨立執行批次更新，套用計算後的差異到實際 DOM 上，任何應用程式如果這麼做那麼都能夠像 React 一樣有效率。但實際上自己編寫程式碼去做這些任務是很繁瑣且容易出錯，React 的精華之處就是幫你處理掉這些問題。 元件就上面所提到的虛擬 DOM 的機制有著跟直接操作實際 DOM 不一樣的語義和行為，所以也會有明顯不同的 API。所謂的元素即在 DOM 結構中的一個節點(node)，不過在虛擬 DOM 機制底下一個節點完全是不一樣的東西，我們稱這個節點為元件。 使用元件對 React 來說是一件非常重要的事情，因為元件的設計概念是要拿來做計算的，就是計算和實際 DOM 的差異。比起計算整個結構的差異，React 透過虛擬 DOM 將使得實際執行的時間複雜度大幅下降。 為了理解為什麼? 我們必須深入探討元件的設計，就從 Hello World 範例: 12345678/** @jsx React.DOM */var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);React.renderComponent(&lt;HelloMessage name=\"Andy\" /&gt;, mountNode); 上面這段程式碼出現了一些可怕的東西，且在這個階段無法完全說明清楚。即使是這麼小的一段範例都包含著一個很強大的概念，所以在這邊我們將會花些時間慢慢一點一點說明。 這個範例建立了一個 React 元件的類別(class): HelloMessage，然後透過 renderComponent() 在虛擬的 DOM 的機制中建立一個元件(&lt;HelloMessage /&gt;, 本質上它就是 HelloMessage 類別實例化的物件，同時也是一個虛擬的 DOM)最後把這個物件裝到真實的 DOM 元素(mountNode)。 首先是需要注意的事情是 React 的虛擬 DOM 通常來自您在應用程式中客制的元件(在這個例子是 &lt;HelloMessage&gt;)。這是一個意義重大的新嘗試，從內建的 DOM 分離出來。DOM 通常不帶有任何程式邏輯，就只是一個被動的資料結構，且讓我們能夠附加處理事件。換句話說 React 的虛擬 DOM 是透過特定程式中的元件所創造的，且能夠加入程式中的特定 API 及內部邏輯。這樣的方式比起直接修改操作 DOM ，例如: 使用 jQuery 的方式，這種建置 View 的方法是一種全新的抽象化方式與框架。 值得一提的是: 如果您一直持續關注 HTML 你也許知道關於 HTML 也許很快的也能自訂 DOM。這將會帶給 DOM 類似的功能: 定義特定程式使用的 DOM 元素，不過 React 並不需要等到官方和瀏覽器完全實作這件事，因為虛擬 DOM 並不是真的 DOM。這讓 React 搶先在自訂元素與 Shadow DOM這些功能實作普及之前您就能先用了。 回到我們的範例，我們已經建立了一個叫做 &lt;HelloMessage&gt; 的元件並且掛載 mountNode 裡面。讓我們用圖片來說明初始化幾個部分的情形，首先，我們將虛擬 DOM 與實際 DOM 的關係視覺化，假設 mountNode 是網頁中的 &lt;body&gt; 標簽: 關於掛載(mount)一詞就理解為『對應』，把 a 掛載到 b 上 = 可以把 b 視為 a 。 箭頭表示虛擬元件已經被掛載到原生 DOM 元素中。這段過程非常短，不過也讓我們來看看關於應用程式的視圖部分的邏輯: 這張圖片指的是整個網頁的內容是由我們客制的 &lt;HelloMessage/&gt; 來呈現，那麼關於 &lt;HelloMessage/&gt; 看起來到底長怎樣? 關於元件輸出渲染的部分是透過 render() 去定義欲呈現的元素。React 並沒有確切的說明關於何時或多頻繁的會去執行 render() 。只有告訴我們當它注意到有效合法的改變時本身會去執行足夠次數的 render()，無論你回傳什麼樣的 DOM 結構。 在我們這個案例，render() 回傳了一個 &lt;div&gt; 裡面包含了一些內容。React 會執行這個 render() 取得 &lt;div&gt; 然後更新實際的 DOM ，使兩者一致。 不僅僅是更新 DOM，還會幫你記住已經更新的東西。這也是我們待會會提到的關於 React 如何快速的判斷其中差異的方法。關於 render() 如何回傳 DOM 節點，這邊我先簡略帶過。它是透過 JSX 去定義結構，這是一個非原生的 Javascript，注意雖然它看起來像是 XML。最後 JSX 會被編譯回 Javascript，看看 JSX 的編譯結果有助我們理解這個架構: 12345678/** @jsx React.DOM */var HelloMessage = React.createClass(&#123;displayName: 'HelloMessage', render: function() &#123; return React.DOM.div(null, \"Hello \", this.props.name); &#125;&#125;);React.renderComponent(HelloMessage( &#123;name:\"John\"&#125; ), mountNode); 看到了吧！我們真的不是回傳一個 DOM 元素，而是一個等價于 DOM 元素的 React Shadow DOM。所以我們得知 React 回傳的並不是真的 DOM。您可以理解為標記物件。 狀態與變化到目前為止，我們忽略了故事中很重要的一段，關於元件可以被改變這件事。如果一個元件不允許被調整修改，那 React 跟 static rendering framework(靜態渲染框架) 也沒啥兩樣，功能就類似于 Mustache 或者 HandlebarsJS這些樣板引擎，不過 React 的重點就是有效率的更新，要能夠更新元件勢必要允許我們修改一些狀態之類的東西。 React 使用元件的 state 屬性來表示其狀態的資料模型。關於這點在官方文件的第二個範例就有舉例說明: 12345678910111213141516171819202122/** @jsx React.DOM */var Timer = React.createClass(&#123; getInitialState: function() &#123; return &#123;secondsElapsed: 0&#125;; &#125;, tick: function() &#123; this.setState(&#123;secondsElapsed: this.state.secondsElapsed + 1&#125;); &#125;, componentDidMount: function() &#123; this.interval = setInterval(this.tick, 1000); &#125;, componentWillUnmount: function() &#123; clearInterval(this.interval); &#125;, render: function() &#123; return ( &lt;div&gt;Seconds Elapsed: &#123;this.state.secondsElapsed&#125;&lt;/div&gt; ); &#125;&#125;);React.renderComponent(&lt;Timer /&gt;, mountNode); React 會在適當的時間點執行回呼函式 getinitialState(), componentDidMount() 以及 componentWillUnmount() ，根據到目前為止的解釋您應該可以清楚地理解這些函式名稱的其含義。所以我們推測元件和狀態背地裡的行為: render() 是 state 和 props 的一個 function，也就是當它們發現異動會執行 render。 state 只能透過 setState() 去改變。 props 不應該持續變動，只有當其父元素用新的屬性重新輸出時才改變。 (在這之前我們沒有明確地提到 props ，不過他們就是屬性 attributes。當元件要 render 時，它們就來自那些 JSX Tag 中的屬性) 稍早，我們曾經提到 React 會自己執行足夠次數的 render ，意思是除非有需要不然 React 不會執行 render。那需要什麼？當你發動 setState() 或者父元件重新賦予新的 props，React 就會重新輸出。 現在我們將所有的事情放在一起，用一張圖來說明當程式更新了虛擬 DOM 的資料流(例如: 回應 AJAX 呼叫): 發動了 AJAX React 內部需要呼叫 setState 用以改變內部狀態 因內部狀態改變進而觸發 render render 執行需要依照生命週期呼叫像 componentWillMount 這類的方法 最後根據計算的最小差異更新 DOM 從 DOM 取得資料截至目前為止，我們只有討論到關於收到狀態改變，到如何傳遞到實際 DOM，但實務上我們會需要從 DOM 取得資料，例如從 input 取得使用者輸入的資料。為了觀察如何運作，我們取用了官方第三個範例: 123456789101112131415161718192021222324252627282930313233343536/** @jsx React.DOM */var TodoList = React.createClass(&#123; render: function() &#123; var createItem = function(itemText) &#123; return &lt;li&gt;&#123;itemText&#125;&lt;/li&gt;; &#125;; return &lt;ul&gt;&#123;this.props.items.map(createItem)&#125;&lt;/ul&gt;; &#125;&#125;);var TodoApp = React.createClass(&#123; getInitialState: function() &#123; return &#123;items: [], text: ''&#125;; &#125;, onChange: function(e) &#123; this.setState(&#123;text: e.target.value&#125;); &#125;, handleSubmit: function(e) &#123; e.preventDefault(); var nextItems = this.state.items.concat([this.state.text]); var nextText = ''; this.setState(&#123;items: nextItems, text: nextText&#125;); &#125;, render: function() &#123; return ( &lt;div&gt; &gt;h3&lt;TODO&lt;/h3&gt; &lt;TodoList items=&#123;this.state.items&#125; /&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input onChange=&#123;this.onChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;button&gt;&#123;'Add #' + (this.state.items.length + 1)&#125;&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125;&#125;);React.renderComponent(&lt;TodoApp /&gt;, mountNode); 簡單的說，我們把我們要的行為綁定到 DOM 的事件(在這個範例就是 onChange)，接著你在這個事件中呼叫 setState 讓 React 幫您更新介面(實際的 DOM)。如果您的程式有資料模型，您的事件大概就是透過 setState 更新那個資料模型，React 發現狀態異動就會去更新。另外如果您曾經用過其他提供雙向資料繫結的框架，看起來可能會懷疑 React 本身在技術上退化了? 儘管這個範例看起來 React 並不是真的把事件加到 &lt;input&gt; 的 “onChange” ，取而代之的是加到文檔層級。讓事件透過汽泡傳遞的機制然後分派他們到正確的虛擬 DOM 元素。這麼做的好處是包含提升速度(在 DOM 綁定太多處理事件會讓網站變慢)，跨瀏覽器實現一樣的行為(處理事件的屬性和其派送的行為並沒有統一的標準，意思是在不同瀏覽器可能有些許的差異)。 所以最後我們可以總結一張完整的圖片來說明關於資料流和事件處理機制: 結論 React 是一個處理 View 的函式庫: React 並不強迫您要在 Model 做些什麼設定或改變。一個 React 元件只是一個 View-Level 的概念，而元件的狀態就只是 UI 方面的狀態。您可以繫結任何類型的資料模型或者函式庫到 React(雖然某些資料模型的處理方式會更有效率，例如 Om) React 的元件抽象化在更新 DOM 的方面尤其優秀: 元件抽象化是一個原則，使得我們可以編寫組織良好的架構，同時又提供高效率的更新機制。 React 元件從 DOM 的角度執行更新不太方便: 比起函式庫自動傳遞同步資料模型，撰寫事件處理給 React 帶來一種很低階的感覺。 React 是抽象漏洞: 意味著 React 有本質上的缺陷，但有提供避免問題發生的方向。大部份的時間你的程式只會和虛擬 DOM 打交道，但有時候你需要直接對 DOM 做些操作。此時您可以查閱手冊的這部分","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React PureRenderMixin","slug":"reactjs-purerendermixin","date":"2014-09-18T03:53:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/18/reactjs-purerendermixin/","link":"","permalink":"//andyyou.github.io/2014/09/18/reactjs-purerendermixin/","excerpt":"PureRenderMixin如果您的 React 元件的 render 函式非常單純(相對來說，就只是單純想把 props 和 state 輸出)，您就可以使用 PureRenderMixin 來提升效能:","text":"PureRenderMixin如果您的 React 元件的 render 函式非常單純(相對來說，就只是單純想把 props 和 state 輸出)，您就可以使用 PureRenderMixin 來提升效能: 12345678var PureRenderMixin = require('react').addons.PureRenderMixin;React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); 內部的 mixin 幫您實作了 shouldComponentUpdate ，他會幫您比對 props 與 state ，只要一樣就回傳 false。協助您快速提升一些效能: 1234567891011121314151617181920212223/** * @jsx React.DOM */var PureRenderMixin = React.addons.PureRenderMixin;var iPhone = React.createClass(&#123; mixins: [PureRenderMixin], getDefaultProps: function () &#123; return &#123;className: 'red'&#125; &#125;, handleClick: function () &#123; this.setProps(&#123;className: 'blue'&#125;); console.log('excute handle click'); &#125;, render: function() &#123; console.log('I am rendering now...'); return &lt;div className=&#123;this.props.className&#125; onClick=&#123;this.handleClick&#125;&gt;foo&lt;/div&gt;; &#125;&#125;);React.renderComponent( &lt;iPhone /&gt;, document.getElementById('example')) 注意:關於比對方面，React 只為您執行淺層的比對。意思是如果您的資料結構非常複雜可能 shouldComponentUpdate() 可能永遠判斷兩個物件為 true，因為他只做淺層比對，有可能是只比較參考。 所以建議您使用單純屬性和狀態或使用強制更新 forceUpdate() 當你知道這個資料結構太複雜的時候。 此外，shouldComponentUpdate 會略過子元件的更新，所以請確保所有的東西是真的很單純！","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 不變性的輔助函式","slug":"reactjs-the-invariance-of-the-auxiliary-function","date":"2014-09-18T02:34:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/18/reactjs-the-invariance-of-the-auxiliary-function/","link":"","permalink":"//andyyou.github.io/2014/09/18/reactjs-the-invariance-of-the-auxiliary-function/","excerpt":"不變性的輔助函式(Immutability Helpers)在一開始我們必須先對這文鄒鄒的術語做個解釋: 所謂的 Immutability 英文的意思就是不能夠或不輕易受外界影響而改變。而在程式領域中我們舉的例子來說明: 即當資料或物件建立之後就不能或者輕易改變。以 C# 來說明就是 Array 和 List 的關係，Object-C 的 NSArray 和 NSMutableArray 對應的關係。","text":"不變性的輔助函式(Immutability Helpers)在一開始我們必須先對這文鄒鄒的術語做個解釋: 所謂的 Immutability 英文的意思就是不能夠或不輕易受外界影響而改變。而在程式領域中我們舉的例子來說明: 即當資料或物件建立之後就不能或者輕易改變。以 C# 來說明就是 Array 和 List 的關係，Object-C 的 NSArray 和 NSMutableArray 對應的關係。 React 允許您使用任何方式來管理資料，包含可變性，或不變性的資料或物件。然而如果您能夠在一些影響效能關鍵的地方使用不變性的資料且判斷是否要執行更新，將會有助您提升效能。通常使用 shouldComponentUpdate() 搭配靜態資料能有效的提升程式的執行效率。 shouldComponentUpdate() 被調用在 props 或 state 收到新值後 render() 之前，如果回傳 true 就更新， false 就不動。 在原生 Javascript 中處理不變性資料比起其他中介語言更加困難例如: Clojure。好消息是官方提供了我們一個方便的輔助函式update()，它可以協助我們處理這類的資料。 在這邊我們補上一個實作範例: 12345678910111213141516171819202122232425262728293031323334353637/** * @jsx React.DOM */var Car = React.createClass(&#123; getInitialState: function () &#123; return &#123; wheel: 4 &#125; &#125;, getDefaultProps: function () &#123; return &#123; brand: &#123;name: 'Toyota'&#125; &#125; &#125;, handleClick: function () &#123; this.setProps(&#123;brand: &#123;name: 'Audi'&#125;&#125;); // this.setState(&#123;wheel: 1&#125;); /* 只要改變 props 或 state 都會觸發 shouldComponentUpdate */ &#125;, shouldComponentUpdate: function (nextProp) &#123; console.log(this.props.brand); console.log(nextProp.brand); console.log(this.props.brand === nextProp.brand) return true; &#125;, render: function () &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.brand.name&#125; &lt;/div&gt; ) &#125;&#125;);React.renderComponent( &lt;Car /&gt;, document.getElementById('example')); 主要的概念舉例來說如果您的資料是這樣: 123myData.x.y.z = 7;// 或者...myData.a.b.push(9); // &#123; a: &#123; b: [ 9 ] &#125; &#125; 由於上一次的物件或資料已經被覆蓋了，您沒有辦法知道哪些資料發生變更。於是，您需要建立一個新的 myData 副本，只改需要改的地方。實務上您應該常常會使用 === 在 shouldComponentUpdate() 去比對新舊物件/資料。下面我們繼續回到資料處理的部分即上面實作範例 handleClick 那邊 123var newData = deepCopy(myData);newData.x.y.z = 7;newData.a.b.push(9); 不幸的是，如果真的複製每一個環節那肯定多做很多不必要的操作，效能自然不好，而且有些狀況下不容易做到。我們的確可以透過另一種方式: 只複製那些我們要改變的物件，保留那些沒變的物件。不過這在今天的 Javascript 非常麻煩 123456var newData = extend(myData, &#123; x: extend(myData.x, &#123; y: extend(myData.x.y, &#123;z: 7&#125;), &#125;), a: extend(myData.a, &#123;b: myData.a.b.concat(9)&#125;)&#125;); 上面這段虛擬碼大略跟您使用 Underscore extend 方法意思相同: http://underscorejs.org/#extend看起來上面這種做法的效能會很不錯(因為他只有淺層複製了 log n 個物件，其他的沿用)。不過這麼做其實很痛苦，因為格式看起來是不斷重複一樣的東西。這樣不止很煩，而且很容易出 bug。 update() 提供了另一種簡單的語法糖衣將這個模式從新包裝，使其看起來清楚一些，我們的程式碼將會是如下: 1234var newData = React.addons.update(myData, &#123; x: &#123;y: &#123;z: &#123;$set: 7&#125;&#125;&#125;, a: &#123;b: &#123;$push: [9]&#125;&#125;&#125;); 雖然語法還是有一點點複雜，需要一點時間適應的(這種寫法的靈感來自 MongoDB 查詢語法)。這樣的做法沒有太多多餘重複的程式碼。關於 $ 前綴字這邊稱之為指令，而要改變的資料結構稱為目標。 指令列表 {$push: array} push() 所有項目至陣列 {$unshift: array} unshift() 就是插入所有項目到陣列 {$splice: array of arrays} 使每個陣列呼叫 splice() {$set: any} 完整取代資料 {$merge: object} 合併物件 {$apply: function} 傳入目前值到函式並取得新值 範例簡易的使用 push12var initialArray = [1, 2, 3];var newArray = update(initialArray, &#123;$push: [4]&#125;); // =&gt; [1, 2, 3, 4] 巢狀集合123var collection = [1, 2, &#123;a: [12, 17, 15]&#125;];var newCollection = update(collection, &#123;2: &#123;a: &#123;$splice: [[1, 1, 13, 14]]&#125;&#125;&#125;);// =&gt; [1, 2, &#123;a: [12, 13, 14, 15]&#125;] 存取集合中索引為 2 ，然後底下的 a 物件執行 splice() 函式，前兩個參數分別是起始索引，第二個參數是要取代幾個元素，後面則是要加入的元素 13, 14 。 使用 function 來更新值12345678910var obj = &#123;a: 5, b: 3&#125;;var newObj = update(obj, &#123;b: &#123;$apply: function(x) &#123;return x * 2;&#125;&#125;&#125;);// =&gt; &#123;a: 5, b: 6&#125;// This is equivalent, but gets verbose for deeply nested collections:var newObj2 = update(obj, &#123;b: &#123;$set: obj.b * 2&#125;&#125;);```### 淺層合併```jsvar obj = &#123;a: 5, b: 3&#125;;var newObj = update(obj, &#123;$merge: &#123;b: 6, c: 7&#125;&#125;); // =&gt; &#123;a: 5, b: 6, c: 7&#125; 補充- 關於淺層複製與深層複製(Shallow copies v.s. Deep copies)淺層複製盡可能的只複製少量資訊，一個集合的淺層複製只複製結構，不複製元素，當您使用淺層複製意味著兩個物件共同參考到同一個元素記憶體位置的意思。而深層複製，複製了所有東西，簡單說就是真的把所有東西複製一份。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React cloneWithProps 與實作 Tabs","slug":"reactjs-clonewithprops-and-implemented-tabs","date":"2014-09-16T08:16:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/16/reactjs-clonewithprops-and-implemented-tabs/","link":"","permalink":"//andyyou.github.io/2014/09/16/reactjs-clonewithprops-and-implemented-tabs/","excerpt":"實作一個 Tabs 元件複合式(組合)元件在 React 中任何東西都是元件，就像樂高一樣，你可以用小片的積木組成大塊的，再組合出您想到的東西。同樣的道理您也可以用許多的小元件(小功能模組)來組合出您的應用程式。所謂的複合式元件或稱作組合元件，他其實就是由多個元件去組成一個多功能的大元件。","text":"實作一個 Tabs 元件複合式(組合)元件在 React 中任何東西都是元件，就像樂高一樣，你可以用小片的積木組成大塊的，再組合出您想到的東西。同樣的道理您也可以用許多的小元件(小功能模組)來組合出您的應用程式。所謂的複合式元件或稱作組合元件，他其實就是由多個元件去組成一個多功能的大元件。 在這篇文章我們要來建立一個 tabs 標簽切換功能的元件，為了達成這個功能我們需要 4 個不同的元件:&lt;Tabs /&gt;, &lt;TabList /&gt;, &lt;Tab /&gt; 和 &lt;TabPanel /&gt; 分別用來呈現整個 tabs ， 列出 標簽列，標簽列的按鈕，以及顯示的內容。結構如下: 123456789101112131415161718&lt;Tabs&gt; &lt;TabList&gt; &lt;Tab&gt;Iron man&lt;/Tab&gt; &lt;Tab&gt;Superman&lt;/Tab&gt; &lt;Tab&gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanel&gt; 鋼鐵人介紹 &lt;/TabPanel&gt; &lt;TabPanel&gt; 超人介紹 &lt;/TabPanel&gt; &lt;TabPanel&gt; 鹿茸介紹 &lt;/TabPanel&gt;&lt;/Tabs&gt; 首先是 &lt;Tabs/&gt; 的行為，它被用來當做一個容器，其角色有點像是一個 controller ，因為它必須要掌管所有 DOM 的事件(點擊 Tab 切換至該內容，被選取到的 index)同時也需要管理 state 看看哪個 &lt;Tab/&gt; 目前正被選取到，所以我們會稱 &lt;Tabs /&gt; 為擁有者元件(owner component)。 我們遭遇到的第一個挑戰是: 元件之間該如何溝通。每一個元件都有一個 state 。每當 state 發生變動，React 就會更新並重新渲染元件以使其跟 state 一致。當我們選了某個索引後，&lt;Tabs/&gt; 元件就要去更新 &lt;Tab/&gt; 和 &lt;TabPanel/&gt; 的 state。 典範轉移首先我們為每一個元件建立一個 API，透過建立一個方法來變更 state。在 React 中一個元件可以透過 this.props.children 去存取子元件。所以一開始我們理論上只要使用 handleSelected 去設定適當該顯示的子元件如下: 12345var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1), index = this.state.selectedIndex;tabs[index].handleSelected(true);panels[index].handleSelected(true); 這樣的做法在 v0.10.0 以前的版本是可以運作的，概略的實作如下: /** @jsx React.DOM*/ var Tab = React.createClass({ getInitialState: function () { return {selected: false} }, handleSelected: function (status) { this.setState({selected: status}); }, render: function () { var cx = React.addons.classSet; var classes = cx({ &#x27;react-tab&#x27;: true, &#x27;active&#x27;: this.state.selected }); return ( &lt;li className={classes}&gt; &lt;a href=&#x27;#&#x27; data-index={this.props.index}&gt;{this.props.children}&lt;/a&gt; &lt;/li&gt; ); }}); var TabList = React.createClass({ render: function () { return ( &lt;ul className=&#x27;react-tab-list&#x27;&gt; {this.props.children} &lt;/ul&gt; ); }}); var Tabs = React.createClass({ getInitialState: function () { return {selectedIndex: 0} }, componentDidMount: function () { var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1), index = this.state.selectedIndex; for (i in tabs) { if (i == index) { tabs[i].handleSelected(true); panels[i].handleSelected(true); } else { tabs[i].handleSelected(false); panels[i].handleSelected(false); } } }, handleClick: function (e) { var index = parseInt(e.target.getAttribute(&#x27;data-index&#x27;)); var tabs = this.props.children[0].props.children, panels = this.props.children.slice(1); for (i in tabs) { if (i == index) { tabs[i].handleSelected(true); panels[i].handleSelected(true); } else { tabs[i].handleSelected(false); panels[i].handleSelected(false); } } }, render: function () { return ( &lt;div className=&#x27;react-tabs&#x27; onClick={this.handleClick}&gt; {this.props.children} &lt;/div&gt; ); }}); var TabPanel = React.createClass({ getInitialState: function () { return {selected: false} }, handleSelected: function (status) { console.log(this.props.name + &#x27; selected: &#x27; + status); this.setState({selected: status}); }, render: function () { var cx = React.addons.classSet; var classes = cx({ &#x27;react-tab-panel&#x27;: true, &#x27;active&#x27;: this.state.selected }); return ( &lt;div className={classes}&gt; {this.props.children} &lt;/div&gt; ) }}); var App = React.createClass({ render: function () { return ( &lt;div className=&#x27;container&#x27;&gt; &lt;Tabs&gt; &lt;TabList&gt; &lt;Tab name=&#x27;ironman&#x27; index={0}&gt;Iron man&lt;/Tab&gt; &lt;Tab name=&#x27;superman&#x27; index={1}&gt;Superman&lt;/Tab&gt; &lt;Tab name=&#x27;lucy&#x27; index={2}&gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &amp;lt;TabPanel name=&amp;#x27;panel-ironman&amp;#x27;&amp;gt; 鋼鐵人 &amp;lt;/TabPanel&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-superman&amp;#x27;&amp;gt; 超人再起 &amp;lt;/TabPanel&amp;gt; &amp;lt;TabPanel name=&amp;#x27;panel-lucy&amp;#x27;&amp;gt; 露西 &amp;lt;/TabPanel&amp;gt; &amp;lt;/Tabs&amp;gt; &amp;lt;/div&amp;gt; ); }}); React.renderComponent( &lt;App /&gt;, document.getElementById(&#x27;example&#x27;)); See the Pen oitzv by AndyYou (@AndyYou) on CodePen. 不過到了 React v0.10.0 版本的時候這樣做會出現警告: 1Invalid access to component property \"setSelected\" 到了 v0.11.0 的時候更慘您已經無法直接存取子元件的方法，因為是新版的 React this.props.children 回傳的物件只是描述物件(discriptors)。不再是對應元件的參考物件，且官方建議您不應該直接存取子元件的實際物件。 Component RefsReact 提供一種機制給你取得實際元件的物件，就是使用 refs 1234567891011121314151617var App = React.createClass(&#123; handleClick: function () &#123; alert(this.refs.myInput.getDOMNode().value); &#125;, render: function () &#123; return ( &lt;div&gt; &lt;input ref=\"myInput\"/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt; Submit &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;); 透過 refs 屬性您就可以取得該子元件的參考 動態的子元件典型的 refs 使用方式是父元件已經知道子元件的情況，所以可以直接在 tag 中指定 ref 如上面的範例。不過這次我們希望我們的 Tabs 元件可以動態的放入 &lt;Tab/&gt; 和 &lt;TabPanel/&gt;例如: 123456789101112131415161718192021222324252627var App = React.createClass(&#123; render: function () &#123; return ( &lt;div className='container'&gt; &lt;Tabs&gt; &lt;TabList&gt; &lt;Tab name='ironman' &gt;Iron man&lt;/Tab&gt; &lt;Tab name='superman' &gt;Superman&lt;/Tab&gt; &lt;Tab name='lucy' &gt;Lucy&lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanel name='panel-ironman'&gt; 鋼鐵人 &lt;/TabPanel&gt; &lt;TabPanel name='panel-superman'&gt; 超人再起 &lt;/TabPanel&gt; &lt;TabPanel name='panel-lucy'&gt; 露西 &lt;/TabPanel&gt; &lt;/Tabs&gt; &lt;/div&gt; ); &#125;&#125;); 而 Tabs 只是動態地把開發者加入的任意結構輸出 123456789var Tabs = React.createClass(&#123; render: function () &#123; return ( &lt;div className='react-tabs'&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;); 因此我們需要一些動態指定 refs 的方法，而這個方法就是透過 cloneWithProps 12345678910111213141516var App = React.createClass(&#123; render: function () &#123; var index = 0, children = React.Children.map(this.props.children, function (child) &#123; return React.addons.cloneWithProps(child, &#123; ref: 'child-' + (index++) &#125;); &#125;); return ( &lt;div&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;);","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"在 CodePen 中使用 React","slug":"reactjs-used-in-the-codepen-react","date":"2014-09-16T05:20:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/16/reactjs-used-in-the-codepen-react/","link":"","permalink":"//andyyou.github.io/2014/09/16/reactjs-used-in-the-codepen-react/","excerpt":"在 codepen.io 上使用 React為了能夠在 CodePen 上使用 React 和 JSX 您必須要: 加入這支 script 到 CodePen http://codepen.io/chriscoyier/pen/yIgqi.js React: http://fb.me/react-0.11.1.js JSX Transformer: http://fb.me/JSXTransformer-0.11.0.js","text":"在 codepen.io 上使用 React為了能夠在 CodePen 上使用 React 和 JSX 您必須要: 加入這支 script 到 CodePen http://codepen.io/chriscoyier/pen/yIgqi.js React: http://fb.me/react-0.11.1.js JSX Transformer: http://fb.me/JSXTransformer-0.11.0.js 緣由React 是一個由 Facebook 團隊所提供的一組 Javascript 函式庫。當您開始使用 CodePen 撰寫一些 React 範例時會發現 CodePen 無法正常運作。這是因為當您在 Javascript 區塊輸入程式碼時，他其實只是在您的文件上加上一個&lt;script&gt; 標簽且並沒有定義任何 type 。所以當您想使用 CodePen 轉寫一些小範例時您有幾種選擇: 不使用 JSX，使用類似像 React.DOM.div 之類的原生 JS 取代 將 JS 寫在 html 區塊，並且使用 &lt;script type=&#39;text/jsx&#39;&gt; 使用上述的方式加入一段 script 關於上面這一小段程式碼是由Mark Funk所提出的一個解法。 1234567891011121314(function() &#123; function runScripts() &#123; var bodyScripts = 'body script:not([src])'; Array.prototype.forEach.call(document.querySelectorAll(bodyScripts), function setJSXType(element) &#123; element.setAttribute('type', 'text/jsx'); &#125;); &#125;; if (window.addEventListener) &#123; window.addEventListener('DOMContentLoaded', runScripts, false); &#125; else &#123; window.attachEvent('onload', runScripts); &#125;&#125;)(); 簡單來說這段程式碼會尋找 CodePen 放置到預覽中的 script 標簽並且加入 type 。附帶一提的是，JSX Transformer 是用來協助您方便開發的並不適用于發佈的產品上。最後，當您發生錯誤時請檢查您瀏覽器的 console，JSX Transformer 會很貼心的提示您錯誤訊息。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"理解 Function.prototype.bind","slug":"reactjs-reactjs-day-1-introduction-and-understanding-functionprototypebind","date":"2014-09-16T03:47:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/16/reactjs-reactjs-day-1-introduction-and-understanding-functionprototypebind/","link":"","permalink":"//andyyou.github.io/2014/09/16/reactjs-reactjs-day-1-introduction-and-understanding-functionprototypebind/","excerpt":"前言自從 2013 年 Reactjs 開放原始碼後就被其單純的架構和理念所吸引。但由於沒有迫切的需求一直沒有將其使用于產品中。且在當時 Angular 正流行，大部份的人都被 two-way binding 神奇簡練的寫法給嚇傻了，相較之下在第一眼看到 Reactjs 其給人的感受為: 怎麼好像要多打很多 Code 啊!?而在 2014 因為 Facebook 提出 Flux 與 Jest 等東西的使我決定認真的研究一下並將其使用在產品上。但由於 React 相關文章大多很散且中文文章不多，所以接下來的 30 天我將逐步根據官網教學與一些國內外高手的文章心得，佐以實作驗證後，記錄為此系列文章。","text":"前言自從 2013 年 Reactjs 開放原始碼後就被其單純的架構和理念所吸引。但由於沒有迫切的需求一直沒有將其使用于產品中。且在當時 Angular 正流行，大部份的人都被 two-way binding 神奇簡練的寫法給嚇傻了，相較之下在第一眼看到 Reactjs 其給人的感受為: 怎麼好像要多打很多 Code 啊!?而在 2014 因為 Facebook 提出 Flux 與 Jest 等東西的使我決定認真的研究一下並將其使用在產品上。但由於 React 相關文章大多很散且中文文章不多，所以接下來的 30 天我將逐步根據官網教學與一些國內外高手的文章心得，佐以實作驗證後，記錄為此系列文章。 準備關於第一個部分，我打算會列出一些網路資源與一點點使用 React 時重要的 Javascript 觀念。 理解 Javascript 的 Function.prototype.bind大部分 Javascript 的介紹您都可以輕易的在網站上找到，不過在學習過程中我覺得特別需要提到的是關於 bind() 的用法，因為在 React 中其實蠻容易遇到的，所以一開始我希望針對這部分做個簡單的介紹。第二天開始我們將從 Getting Started 逐步介紹。 Function.prototype.bind 函式繫結大概是當您開始學習 Javascript 時最後關注到的議題。通常是當您遇到一種狀況：需要在其他 Function 保留 this 的執行環境(Context)。講執行環境可能太抽象，舉例來說就是當您需要在函式的另外一個函式中呼叫 this.action() 的時候。(這邊如果看不懂請耐著性子看下去)不過通常這時您可能也不知道您需要的就是 Function.prototype.bind()。 第一次您遇到上述的問題，您可能會傾向于把 this 儲存成一個變數，接著即便您切換了 Context 還是可以參考到這個物件。如果您看不懂上面在說什麼，請先參考這篇文章。許多人會採用 self, _this 或者 context 當作變數名稱，並且把 this 放進去。這些方法都是可行的且並沒有什麼不妥，但有一個更不錯的方式。 我們實際上要解決的問題是？下面有一份簡單的範例程式碼，情況是某人忘記把 Context 存成一個變數： 123456789101112131415161718192021222324252627282930313233343536/** * 我們舉例一個機器人物件，機器人有一些基本的 function 來執行動作 * 不過問題是當我們要求機器人執行動作的時候，他需要先到確定還有沒有能量。 * * * Note: 這段程式碼只是希望能夠用具像化一點的比喻來說明。 */var Robot = &#123; /** private */ power: 100, walk: function () &#123; console.log('Robot walked'); this.power -= 10; &#125;, fly: function () &#123; console.log('Robot flied'); this.power -= 20; &#125;, check: function (excute) &#123; if (this.power &gt; 0) excute(); &#125;, /** public */ showoff: function () &#123; this.check(function () &#123; this.walk(); /* 實際執行的動作。 */ this.fly(); &#125;) &#125;&#125;Robot.showoff(); 如果照著上面把實際要執行的動作當作 callback 傳給 check()，當您要再次呼叫 this.walk() 的時候就會發現出現錯誤訊息 1TypeError: Object #&lt;Object&gt; has no method &apos;walk&apos; 這是因為我們再次傳進去的匿名函式不知道關於 this 的東西，在這裏我們並沒有善用閉包來保存 Context。而對很多人可能就會把上面的範例修改為如下 123456789101112131415161718192021222324252627282930var Robot = &#123; /** private */ power: 100, walk: function () &#123; console.log('Robot walked'); this.power -= 10; &#125;, fly: function () &#123; console.log('Robot flied'); this.power -= 20; &#125;, check: function (excute) &#123; if (this.power &gt; 0) excute(); &#125;, /** public */ showoff: function () &#123; var that = this; this.check(function () &#123; that.walk(); /* 實際執行的動作。 */ that.fly(); &#125;) &#125;&#125;Robot.showoff(); 宣告成區域變數之後，閉包就會幫助我們 Keep 這個 Context，這也是相對直覺的方式，同上面說的這沒有任何不妥。不過我們知道了一件事，就是我們需要保存 Robot 這個物件參考的 Context，給 Callback 即範例中的 excute。當我們呼叫 that.walk() 的時候其實就是在使用閉包。根據 MDN 說明，其實閉包就是一個特殊的物件，它有兩個含義： 它是一個 function。 它產生了一個 Context ，概略的說就是幫你記錄上一層有宣告的變數。 這裏就不詳細說明關於閉包，不理解的推薦這篇文章和這篇 閉包的方式已經可以運作了，但是我們覺得他不夠漂亮，因此我們就來使用 Function.prototype.bind()。 讓我們來重構上面的程式範例 123456789101112131415161718192021222324252627282930var Robot = &#123; /** private */ power: 100, walk: function () &#123; console.log('Robot walked'); this.power -= 10; &#125;, fly: function () &#123; console.log('Robot flied'); this.power -= 20; &#125;, check: function (excute) &#123; if (this.power &gt; 0) excute(); &#125;, /** public */ showoff: function () &#123; // var that = this; this.check(function () &#123; this.walk(); this.fly(); &#125;.bind(this)); &#125;&#125;Robot.showoff(); 我們剛剛做了什麼？？當我們呼叫了 .bind() 的時候，其實它非常單純的建立了一個新的 function，只不過這個 function 把 this 的值綁定進去。所以我們同時把我們想要的 Context(即 Robot 物件) 給保存了下來。接著當我們的回呼函式在執行的時候 this 就是參考到 Robot 這個物件。 如果你有興趣了解 Function.prototype.bind() 內部運行機制，他看起來大概就像下面這樣 123456Function.prototype.bind = function (scope) &#123; var fn = this; return function () &#123; return fn.apply(scope); &#125;;&#125; 接著我們再來看看一個非常簡單的案例： 12345678910111213var foo = &#123; x: 3&#125;var bar = function () &#123; console.log(this.x);&#125;bar(); // undefinedvar boundFunc = bar.bind(foo);boundFunc(); // 3 這個範例是說，bind() 幫我們建立了一個新的 function ，並且當我們執行時這個 function 的 this 是指向 foo，而不是全域。如果您還是不清楚可以大略理解為：把 function 掛到某個物件底下(當然不是真的加進去)，只是這樣一來可以透過 this 取得該物件的 Context。 實務應用當我們學習某些東西時，我不只需要理解觀念，也會試著將其套用在實務上以驗證自己是否明白。來看看一些實務上的應用吧！ Click 事件處理其中一個用途是拿它來追蹤點擊次數，然後可能是要把它存在某個物件裡類似下面這樣 1234567var logger = &#123; x: 0, increment: function () &#123; this.x++; console.log(this.x); &#125;&#125; 然後指派一個按鈕的 Click 處理函式去呼叫 logger 物件 123document.querySelector('button').addEventListener('click', function () &#123; logger.increment();&#125;); 不過上面這種做法，我們已經建立了一個不必要的匿名函式，並且因為這個匿名函式使用了 logger 呼叫了 increment() 所以產生了一個閉包用以確保了 this 是正確的參考物件。不明白！？再看看下面這個最根本的寫法吧 1document.querySelector('button').addEventListener('click', logger.increment); // NaN 原本是這樣的，當你 Click 的時候執行一個 function ，不過如果你用上面這種寫法的話，意思是你只是把 function 傳進去，根據 this 的定義他其實是指的是誰(哪個物件)呼叫這個函式 this 就是指向它。而這裡呼叫的人根本不是 logger 這個物件。也因此使用了一個匿名函式，建立了一個閉包，就是為了保留住 logger 物件的狀態。 好了！講完上面這些我們來看看更乾淨的寫法： 1document.querySelector('button').addEventListener('click', logger.increment.bind(logger)); 現在，對於 bind() 應該比較不陌生了吧！因為在 React 中蠻多機會的使用 bind()。如官方的範例 123456789101112componentDidMount: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;);&#125; 資源列表官方網站React.NETSebastian GistReactJS.tw 台灣粉絲團React揭秘React Components","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 複製元件","slug":"reactjs-replication-components","date":"2014-09-15T13:40:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/15/reactjs-replication-components/","link":"","permalink":"//andyyou.github.io/2014/09/15/reactjs-replication-components/","excerpt":"複製元件在少數的情況下，某個元件可能想要變更不屬於自己的 props(例如: 修改 this.props.children 的 className )。或者是複製多個被傳入的元件。cloneWithProps() 是這件事變的可能。","text":"複製元件在少數的情況下，某個元件可能想要變更不屬於自己的 props(例如: 修改 this.props.children 的 className )。或者是複製多個被傳入的元件。cloneWithProps() 是這件事變的可能。 1ReactComponent React.addons.cloneWithProps(ReactComponent component, object? extraProps) 複製淺層的 component 然後合併 extraProps 。 Props 被使用和 transferPropsTo() 一樣的方式合併，所以類似像 className 屬性就會被整合進去。 注意: cloneWithProps 不會轉移 key 屬性至複製的元件中。如果您希望保存 key，請使用 extraProps 物件 1var clonedComponent = cloneWithProps(originalComponent, &#123; key : originalComponent.props.key &#125;);","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 單元測試","slug":"reactjs-unit-tests","date":"2014-09-15T10:12:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/15/reactjs-unit-tests/","link":"","permalink":"//andyyou.github.io/2014/09/15/reactjs-unit-tests/","excerpt":"單元測試React.addons.TestUtils 讓您可以在您的測試框架中更簡單的測試您的元件(官方使用 Jest)。簡單的來說它是一系列輔助的方法以協助您測試 React 元件。","text":"單元測試React.addons.TestUtils 讓您可以在您的測試框架中更簡單的測試您的元件(官方使用 Jest)。簡單的來說它是一系列輔助的方法以協助您測試 React 元件。 Simulate (模擬方法)1Simulate.&#123;eventName&#125;(DOMElement element, object eventData) 模擬一個 DOM 的事件調派，其中可以包含一個 eventData。這可能是在 ReactTestUtils 最有用的一個工具。 使用方式的範例: 1234var node = this.refs.input.getDOMNode();React.addons.TestUtils.Simulate.click(node);React.addons.TestUtils.Simulate.change(node);React.addons.TestUtils.Simulate.keyDown(node, &#123;key: \"Enter\"&#125;); 下面開始使用統一的格式來簡易說明每個方法的格式 1回傳的物件型別 方法名稱(參數型別 參數名稱) renderIntoDocument1ReactComponent renderIntoDocument(ReactComponent instance) 輸出一個元件到 document 獨立的 DOM 節點(div)去。如下面舉例的一小段測試範例: 123456789101112describe(\"Label Test\",function()&#123; beforeEach(function() &#123; ReactTestUtils = React.addons.ReactTestUtils; &#125;); it(\"Check Text Assignment\", function () &#123; var label = &lt;Label&gt;Some Text We Need for Test&lt;/Label&gt;; ReactTestUtils.renderIntoDocument(label); expect(label.refs.p).toBeDefined(); expect(label.refs.p.props.children).toBe(\"Some Text We Need for Test\") &#125;);&#125;); 觀察原始碼: 12345renderIntoDocument: function(instance) &#123; var div = document.createElement('div'); // 我們的測試並不需要附加到網頁中的某個 DOM 元素時使用: return React.renderComponent(instance, div);&#125; mockComponent1object mockComponent(function componentClass, string? tagName) 模擬元件，顧名思義透過傳入一個模擬的元件模組到這個方法中以快速製作一個”假”元件，取代本來用 render 的方式。讓我們來查看原始碼好理解官方簡短的說明: 1234567891011mockComponent: function(module, mockTagName) &#123; var ConvenienceConstructor = React.createClass(&#123; render: function() &#123; var mockTagName = mockTagName || module.mockTagName || \"div\"; return ReactDOM[mockTagName](null, this.props.children); &#125; &#125;); copyProperties(module, ConvenienceConstructor); module.mockImplementation(ConvenienceConstructor); return this;&#125; isDescriptorOfType1boolean isDescriptorOfType(ReactDescriptor descriptor, function componentClass) 當 discriptor 物件符合該元件類別時回傳 true。 關於 descriptors我們提過 React 是透過一套虛擬 DOM 的機制，並不是直接操作 DOM 元素，在 v0.10 版之前 React 回傳給你的物件都是這個 discriptor (描速物件) 它和 React 內部操作的元件是指向同一個參考。 更多關於 discriptor 機制 isDOMComponent1boolean isDOMComponent(ReactComponent instance) 如果物件是 DOM 元件 (例如: &lt;div&gt;, &lt;span&gt;)就回傳 true。 isCompositeComponent1boolean isCompositeComponent(ReactComponent instance) 判斷是否為復合式元件(即用 React.createClass())。 isCompositeComponentWithType1boolean isCompositeComponentWithType(ReactComponent instance, function componentClass) 結合 isComponentOfType() 和 isCompositeComponent()。 isTextComponent1boolean isTextComponent(ReactComponent instance) 如果物件是一個純文字元件就回傳 true。 findAllInRenderedTree1array findAllInRenderedTree(ReactComponent tree, function test) 遍歷所有在結構中的元件，並使用傳入的 test()。當 test(component) 為 true 就把該元件加入陣列。很少機會會單純使用這個方法，它通常用來對 React 的原生物件做其他的單元測試。 scryRenderedDOMComponentsWithClass1array scryRenderedDOMComponentsWithClass(ReactComponent tree, string className) 找出在已輸出的 DOM 元件中跟 tagName 一致的物件。 findRenderedDOMComponentWithTag1ReactComponent findRenderedDOMComponentWithTag(ReactComponent tree, string tagName) 類似 scryRenderedDOMComponentsWithClass() 不過一定要回傳一個結果，如果沒有或其他數量就例外。 scryRenderedDOMComponentsWithTag1array scryRenderedDOMComponentsWithTag(ReactComponent tree, string tagName) 找出所有在已輸出樹狀結構中符合 tagName 的元件，並傳回一個陣列。 findRenderedDOMComponentWithTag1ReactComponent findRenderedDOMComponentWithTag(ReactComponent tree, string tagName) 類似 scryRenderedDOMComponentsWithTag() ，不過一定要回傳一個結果，如果沒有或其他數量就例外。 scryRenderedComponentsWithType1array scryRenderedComponentsWithType(ReactComponent tree, function componentClass) 找出在樹狀結構中所有跟 componentClass 型別一致的元件。 findRenderedComponentWithType1ReactComponent findRenderedComponentWithType(ReactComponent tree, function componentClass) 跟 scryRenderedComponentsWithType() 一樣，不過一定要回傳一個結果，如果沒有或其他數量就例外。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 與 DOM 的差異","slug":"reactjs-and-dom-differences","date":"2014-09-14T05:44:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/14/reactjs-and-dom-differences/","link":"","permalink":"//andyyou.github.io/2014/09/14/reactjs-and-dom-differences/","excerpt":"DOM 的差異React 為了跨瀏覽器和提升效能的因素，實作一套和瀏覽器本身無關的 events 以及模擬 DOM 的機制。我們可以借由這個機制處理一些關於原始 DOM 設計上一些不足的地方。","text":"DOM 的差異React 為了跨瀏覽器和提升效能的因素，實作一套和瀏覽器本身無關的 events 以及模擬 DOM 的機制。我們可以借由這個機制處理一些關於原始 DOM 設計上一些不足的地方。 所有的 DOM 屬性 Properties 和 Attributes (包含事件)都應該使用駝峰式命名 camelCased ，這和一般的 Javascrpt 程式碼風格一致。我們故意在這邊違背 html 規格 ，因此這和 html 規格是不同的。 style 屬性透過 Javascript 物件和駝峰式的屬性來設定，而不是 CSS 字串。所以設定 CSS 的語法風格會和 DOM, Javascrit 屬性一致，外加這麼做可以防止 XSS 攻擊。 所有在事件符合 W3C 規範，且所有事件(包含 submit)傳遞都遵照 W3C 規範，查閱 Event System 取得更多資訊。 關於 onChange 事件行為就跟你所期待的一樣，當一個表單欄位改變了，事件就會被觸發，而不是在 onblur 失去焦點的時候才觸發。 我們特意違背現有的瀏覽器行為，因為原始的 onChange 事件行為跟其名稱並不符合，React 需要正確的用到這個 Event ，當使用者輸入資料的同時 React 就會及時反應。查閱Forms得知更多資訊。 表單輸入的屬性例如 value checked 更多關於一些命名，用法，等請查閱 Forms","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React classSet 方法","slug":"reactjs-classset-method","date":"2014-09-14T05:18:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/14/reactjs-classset-method/","link":"","permalink":"//andyyou.github.io/2014/09/14/reactjs-classset-method/","excerpt":"操作樣式名稱(Class)classSet() 是一個協助您快速操作 DOM 裏 class 字串的工具。這裡有一些常見的情況，當沒有使用 classSet() 的時候:","text":"操作樣式名稱(Class)classSet() 是一個協助您快速操作 DOM 裏 class 字串的工具。這裡有一些常見的情況，當沒有使用 classSet() 的時候: 12345678910111213141516171819202122/** * @jsx React.DOM */var ClassSet = React.createClass(&#123; render: function () &#123; var classString = 'message'; if (this.props.isImportant) &#123; classString += ' message-important'; &#125; if (this.props.isRead) &#123; classString += ' message-read'; &#125; return ( &lt;div className=&#123;classString&#125;&gt;Great, I'll be there&lt;/div&gt; ) &#125;&#125;);React.renderComponent( &lt;ClassSet isRead='1' isImportant='1' /&gt;, document.getElementById('example')) 你可能因為一些 CSS Class 設定的問題而開始組合字串，但很顯然的這是個很無聊瑣碎的工作。而且這種做法程式碼很難閱讀且易出錯。這個時候 classSet() 可以幫你解決這個問題。 123456789101112131415161718192021/** * @jsx React.DOM */var ClassSet = React.createClass(&#123; render: function () &#123; var cx = React.addons.classSet; var classes = cx(&#123; 'message': true, 'message-important': this.props.isImportant, 'message-read': this.props.isRead &#125;) return ( &lt;div className=&#123;classes&#125;&gt;Great, I'll be there&lt;/div&gt; ) &#125;&#125;);React.renderComponent( &lt;ClassSet isRead='1' isImportant='1' /&gt;, document.getElementById('example')) 其他補充事項:只要看到程式中使用了 React.addons.*， React 記得使用 react-with-addons 的版本，另外有些屬性名稱因為跟程式關鍵字衝突會有變更，這裡的 class 就變成 className，另外一個常遇到的是 for 要改成 htmlFor。 12345678return ( &lt;div className=&#123;classes&#125;&gt; &lt;label htmlFor='boy'&gt;Boy&lt;/label&gt; &lt;input type='radio' id='boy' name='sex'/&gt; &lt;label htmlFor='girl'&gt;Girl&lt;/label&gt; &lt;input type='radio' id='girl' name='sex'/&gt; &lt;/div&gt;) 當我們使用 classSet() 時，我們傳入一個物件，其中的 key 屬性名稱就是 CSS class 樣式。當它設成 Truthy values 的時候就表示要套用，這個樣式名稱會自動加入串接的字串中。 Truthy values 指的是只要 Javascript 判斷為真即可，並不是一定要 true，舉例來說 1, string, Object 都是 Truthy values 。 不要再使用串字串的方式了！","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 雙向資料繫結","slug":"reactjs-a-two-way-data-binding","date":"2014-09-14T04:19:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/14/reactjs-a-two-way-data-binding/","link":"","permalink":"//andyyou.github.io/2014/09/14/reactjs-a-two-way-data-binding/","excerpt":"雙向繫結(Two-way binding)輔助函式React 可以搭配 ReactLink 是一種實作雙向資料繫結較簡單的方式。","text":"雙向繫結(Two-way binding)輔助函式React 可以搭配 ReactLink 是一種實作雙向資料繫結較簡單的方式。 注意: 如果您剛開始使用這個 framework ，ReactLink 並不是必須的東西，且應該謹慎使用。 在 React 中，資料流遵循單一方向: 從上而下，從父元件到子元件。這是因為在馮‧紐曼架構下資料流通常一次只有一個方向。您可以單純地就把上面提的這些說名歸納為一個 “one-way data binding” 的機制。在實務上說明就是資料都是從 this.state 或 this.props 來的。 由於大部份應用程式的需求都是關於取得資料並在程式中操作這些資料，或者抽象的說需要讓資料流回程式中。什麼意思？舉例來說:當我們開發了一個表單 form 當表單每次收到使用者變更的資料後您就需要更新 React 的 state。(取得 form 資料 -&gt; 更新 state)又或者你希望在 Javascript 和 React 中調整佈局，改變某些 DOM 的尺寸大小。(取得關於 Size -&gt; 調整佈局) 要完成上面這些任務，透過做法是透過監聽 change 事件，取得資料(這些資料通常來自 DOM)，接著執行 setState() 。封閉的資料流可以帶來一些好處如: 明確易懂，便於維護。用實際的範例來說: 只要你能確定資料來源永遠是 this.state ，而每一階層需要資料的元件都是跟 state 取得，如此一來只要變更 state 其他的元件就應該要自己負責更新資料。 Two-way binding 雙向的資料繫結 – 由於很多時候 DOM 上顯示的值必須和某個 state 中的值一致，所以所謂的 Two-way binding 即程式在背後自動幫您同步這兩個值。改變 form 時 model 會修正，更新 model 後 form 的 UI 也會跟著更新。使用 Two-way binding 的好處是程式碼變得簡潔並適用于多種應用。根據上述的這些情況 React 提供了 ReactLink: 這個語法糖衣讓您可以輕鬆完成這樣的功能，或者我們可以說 ReactLink就是幫您連結資料來源到 React 的 state。 注意: ReactLink 只不過幫您把 onChange/setState() 這兩件事包起來做成一個簡單的慣例。它並不會修改底層運行的模式和資料流。 ReactLink: Before 和 After這邊我們先不使用 ReactLink 示範一個簡單的表單範例: 123456789101112131415161718192021/** * @jsx React.DOM */var NoLink = React.createClass(&#123; getInitialState: function () &#123; return &#123; message: 'Hello!' &#125; &#125;, handleChange: function (event) &#123; console.log(event.target.value); this.setState(&#123;message: event.target.value&#125;); &#125;, render: function () &#123; var message = this.state.message; return &lt;input type='text' value=&#123;message&#125; onChange=&#123;this.handleChange&#125; /&gt;; &#125;&#125;);React.renderComponent( &lt;NoLink /&gt;, document.getElementById('example')); 當然這個部分運作的非常良好，且關於資料的運作與流向非常清楚。不過你也發現了，一旦欄位增加程式碼就會變的有些冗長。接著我們換成使用 ReactLink: 12345678910111213141516var WithLink = React.createClass(&#123; /* 載入 React.addons.LinkedStateMixin 中的方法 (this.linkState)*/ mixins: [React.addons.LinkedStateMixin], getInitialState: function () &#123; return &#123;message: 'Hello!'&#125; &#125;, render: function () &#123; return ( &lt;div&gt; &lt;input type='text' valueLink=&#123;this.linkState('message')&#125; /&gt; &#123;this.state.message&#125; &lt;/div&gt; ) &#125;&#125;); LinkedStateMixin 加入了一個叫 linkState() 的方法到 React 元件中。然後 linkState() 的功能是回傳了一個 ReactLink 物件，其實這個物件不過就是包含著 state 的值和實做一個 onChange 的 callback。 ReactLink 物件就像 props 一樣，會被傳到整個階層樹狀結構中，因此您可以輕易的設定任何值的 two-way binding 。 值得提醒的是關於 checkbox 的 value 屬性有比較特殊的行為，只有在 checkbox 被勾選，表單提交時才會送出 value (屬性預設會是 on)。關於 value 屬性值是不會改變的不管是勾選或不選。針對 checkbox ，您應該改用 checkedLink 而不是 valueLink: 1&lt;input type=\"checkbox\" checkedLink=&#123;this.linkState('booleanValue')&#125; /&gt; 總結來說我們就只是透過 valueLink 搭配 ReactLink 物件來完成 two-way binding 這件事。 關於內部運作在這一小節我們將要探討關於 ReactLink 的兩個面向: 建立 ReactLink 物件與如何使用。為了證明 ReactLink 很簡單，我們將實作一些程式碼範例讓您更加清楚其運作。 ReactLink 不使用 LinkedStateMixin1234567891011121314151617181920212223242526272829/** * @jsx React.DOM */var WithoutMixin = React.createClass(&#123; getInitialState: function () &#123; return &#123;message: 'Hello!'&#125; &#125;, handleChange: function (newValue) &#123; this.setState(&#123;message: newValue&#125;) &#125;, render: function () &#123; var valueLink = &#123; value: this.state.message, requestChange: this.handleChange &#125;; return ( &lt;div&gt; &lt;input type='text' valueLink=&#123;valueLink&#125; /&gt; &#123;this.state.message&#125; &lt;/div&gt; ) &#125;&#125;);React.renderComponent( &lt;WithoutMixin /&gt;, document.getElementById(\"example\")) 誠如您所見，即使不使用 addons 提供的輔助函式我們一樣可以輕鬆使用 ReactLink。ReactLink 只是一個非常單純的物件，它就只是包含 value 和 requestChange 這兩個屬性。同樣的 LinkedStateMixin 也很單純，就只是根據您傳入的參數，決定存取哪一個 this.state 和幫您實作一個使用 this.setState() 的方法。最後我們透過 valueLink 或 checkedLink 告訴 React 這個元素的值要使用 ReactLink 物件，請在適當的時候幫我呼叫裡面的 callback 。 觀念上我們可以歸納為: React 本身只有 one-way data binding 的機制，即資料流都是遵從單一方向。而 two-way binding 的機制只不過是簡化 onChange/setState 這兩件事。 ReactLink 不使用 valueLink123456789101112131415161718192021222324252627/** * @jsx React.DOM */var WithoutLink = React.createClass(&#123; mixins: [React.addons.LinkedStateMixin], getInitialState: function () &#123; return &#123;message: 'Hello!'&#125; &#125;, render: function () &#123; var valueLink = this.linkState('message'); var handleChange = function (e) &#123; valueLink.requestChange(e.target.value); &#125;; return ( &lt;div&gt; &lt;input type='text' value=&#123;valueLink.value&#125; onChange=&#123;handleChange&#125; /&gt; &#123;this.state.message&#125; &lt;/div&gt; ) &#125;&#125;);React.renderComponent( &lt;WithoutLink /&gt;, document.getElementById('example')); 關於 valueLink 屬性也相當單純，它只是簡單的處理 onChange 事件以及呼叫 this.props.valueLink.requestChange() 接著使用 this.props.valueLink.value 取代原本的值。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 動畫","slug":"reactjs-animation","date":"2014-09-13T15:02:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/13/reactjs-animation/","link":"","permalink":"//andyyou.github.io/2014/09/13/reactjs-animation/","excerpt":"動畫React 提供了一個 ReactTransitionGroup 的組件元件來作為一個底層的動畫 API，以及另一個 ReactCSSTransitionGroup 來方便實作基本的 CSS 動畫。","text":"動畫React 提供了一個 ReactTransitionGroup 的組件元件來作為一個底層的動畫 API，以及另一個 ReactCSSTransitionGroup 來方便實作基本的 CSS 動畫。 高度抽象化的 API(High-level API) 與 底層的 API(Low-level API) 是什麼？ High-level API 允許開發者操作WSDL，一般來說一個 WDSL 編譯器全部的 SOAP 界面來產生物件，而開發者需要做的就只是直接呼叫物件中的 method，簡單的來說你不需要直接操作 SOAP 的結構。而 Low-level API 則允許開發者直接去動 SOAP 結構，而不是呼叫物件中的方法 更多關於 High-level 與 Low-level 定義 高度抽象化的 API: ReactCSSTransitionGroupReactCSSTransitionGroup 建構在 ReactTransitionGroup 之上，當 React 元件掛載或卸載到 DOM 物件時，您可以透過 ReactCSSTransitionGroup 可以簡單加入 CSS 過場特效與動畫。這個靈感來自于 ng-animate 。 入門ReactCSSTransitionGroup 是一個連接到 ReactTransitions 的介面。這個單純的元素需要把你想要做動畫效果的元件全部包起來。下面的範例是我們要讓列表的項目淡入淡出: 123456789101112131415161718192021222324252627282930313233343536/** @jsx React.DOM */var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;var TodoList = React.createClass(&#123; getInitialState: function() &#123; return &#123;items: ['hello', 'world', 'click', 'me']&#125;; &#125;, handleAdd: function() &#123; var newItems = this.state.items.concat([prompt('Enter some text')]); this.setState(&#123;items: newItems&#125;); &#125;, handleRemove: function(i) &#123; var newItems = this.state.items; newItems.splice(i, 1); this.setState(&#123;items: newItems&#125;); &#125;, render: function() &#123; var items = this.state.items.map(function(item, i) &#123; return ( &lt;div key=&#123;item&#125; onClick=&#123;this.handleRemove.bind(this, i)&#125;&gt; &#123;item&#125; &lt;/div&gt; ); &#125;.bind(this)); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;Add Item&lt;/button&gt; &lt;ReactCSSTransitionGroup transitionName=\"example\"&gt; &#123;items&#125; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); &#125;&#125;); 在這個元件中，當你把一個 item 加入 ReactCSSTransitionGroup ，它將會取得 example-enter 的 CSS 屬性，而當你再次點擊這個項目時會取得 example-enter-active 樣式。而這個慣例是根據在 transitionName 的名稱所組成的。現在，您可以使用這些 class 樣式去觸發 CSS 的動畫或者過場的效果。舉例來說讓我們加入下面的 CSS 12345678.example-enter &#123; opacity: 0.01; transition: opacity .5s ease-in;&#125;.example-enter.example-enter-active &#123; opacity: 1;&#125; 你可能注意到了，當您要移除某個項目的時候， ReactCSSTransitionGroup 卻把它保留在 DOM 裏面。同時如果你用的是未經壓縮的 react-with-addons 版本，就會看到 console 警告你，React 期望取得一個 CSS 效果。ReactCSSTransitionGroup 會保留您的 DOM 元素直到動畫執行完畢 試著加入下面這段 CSS 12345678example-leave &#123; opacity: 1; transition: opacity .5s ease-in;&#125;.example-leave.example-leave-active &#123; opacity: 0.01;&#125; 動畫群組被需要被掛載才能執行為了套用這些過場特效到子元素中，ReactCSSTransitionGroup 必須要先被掛載到 DOM 中。下面是一個錯誤的示範，因為ReactCSSTransitionGroup 是隨著新的項目一起被掛載而無法生效，如果您把 ReactCSSTransitionGroup 包覆在子元素的外層則會出現奇怪的效果。比對上面一開始的範例就會明白了。 這小節要說明的觀念是: ReactCSSTransitionGroup 運作的方式是先安裝到 DOM 在賦予子元件這些效果。 有無 items 的動畫行為雖然上面的範例我們在 ReactCSSTransitionGroup 中渲染了列表，不過 ReactCSSTransitionGroup 的是允許沒有子元件的。意味著您可以移除到完全沒有項目，即渲染的 items 是空的。這個部分我們理解到 ReactCSSTransitionGroup 是針對單一元素在掛載或者卸載的時候套用動畫。同時也可以用在新元素取代舊元素的時候其行為為兩個元素同時播放動畫，舊的元素會先保留 DOM 等其動畫播放完畢。舉例來說，我們可以實作一個簡單圖片輪播的範例: 123456789101112131415161718/** @jsx React.DOM */var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;var ImageCarousel = React.createClass(&#123; propTypes: &#123; imageSrc: React.PropTypes.string.isRequired &#125;, render: function() &#123; return ( &lt;div&gt; &lt;ReactCSSTransitionGroup transitionName=\"carousel\"&gt; &lt;img src=&#123;this.props.imageSrc&#125; key=&#123;this.props.imageSrc&#125; /&gt; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); &#125;&#125;); 注意: 您必須替每一個在 ReactCSSTransitionGroup 中的子元素設定 key 的屬性，即使只有一個項目。這是 React 偵測判斷子元素狀態的方式(entered, left, stayed)。 這邊提供一段展示影片，即使我們只透過 this.state 去更新圖片的 src ，ReactCSSTransitionGroup 還是會再產生一個節點。 官方提供的範例只是概念上的說明，上面展示影片的範例程式碼如下: 1234567891011121314151617181920212223242526272829/** @jsx React.DOM */var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;var ImageCarousel = React.createClass(&#123; propTypes: &#123; imageSrc: React.PropTypes.string.isRequired &#125;, getInitialState: function () &#123; return &#123;imageSrc: this.props.imageSrc&#125; &#125;, handleChangeImage: function () &#123; console.log('changed'); this.setState(&#123;imageSrc: 'dist/images/1.jpg'&#125;); &#125;, render: function () &#123; return ( &lt;div&gt; &lt;ReactCSSTransitionGroup transitionName=\"carousel\"&gt; &lt;img src=&#123;this.state.imageSrc&#125; key=&#123;this.state.imageSrc&#125; onClick=&#123;this.handleChangeImage&#125;/&gt; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); &#125;&#125;);React.renderComponent( &lt;ImageCarousel imageSrc='dist/images/0.jpg' /&gt;, document.getElementById('example')); 關閉動畫如果您想，您也可以取消 enter 或 leave 的動畫。有時候你的需求是只要物件出現時的動畫，但是最一開始的範例有提到如果沒有實作移除的動畫， ReactCSSTransitionGroup 會卡著 DOM 物件。您可以透過在 ReactCSSTransitionGroup 加入 transitionEnter={false} 或 transitionLeave={false} props 已關閉動畫效果。 123&lt;ReactCSSTransitionGroup transitionName='example' transitionLeave=&#123;false&#125;&gt; &#123;items&#125;&lt;/ReactCSSTransitionGroup&gt; 注意: 使用 ReactCSSTransitionGroup 時，裡面的元件並沒辦法在過場或動畫結束後收到任何通知，也不能在動畫時期執行更多複雜的邏輯。如果您需要控制更多細節，您可以使用底層的 API ReactTransitionGroup API ，它一樣是透過提供 hooks 的方式讓您可以自訂效果。 底層 API: ReactTransitionGroupReactTransitionGroup 是動畫的基礎。當子元素被加入或移除(如上面範例)，會在一個特有的生命週期去呼叫它的 hooks。 componentWillEnter(callback)當元件被加入一個已存在的 TransitionGroup 這個事件被呼叫，而觸發時間跟 componentDidMount() 時一樣。它會中斷其他的動畫直到 callback 被執行。另外是他不會在初始化的時候被呼叫。 componentDidEnter()當上面的 callback 執行完畢之後接著會執行這個事件。 componentWillLeave(callback)當子元件已經被從 ReactTransitionGroup 移除的時候會執行這個事件，雖然子元件已經被移除了，但是 ReactTransitionGroup 還是會保留 DOM 直到 callback 被呼叫。 componentDidLeave()一樣的當 willLeave callback 被呼叫(時間點跟 componentWillUnmount 一樣)。 渲染一個不同元件預設 ReactTransitionGroup 會輸出一個 span 不過您是可以使用 component 屬性修改這個預設的行為 123&lt;ReactTransitionGroup component=&#123;React.DOM.ul&#125;&gt; ...&lt;/ReactTransitionGroup&gt; 所有的 DOM 元件都在 React.DOM. 底下，然後 component 並不需要一定是 DOM 元件。這可以是任何您想要的 React 元件甚至是您開發的。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 附加組件介紹","slug":"reactjs-add-ons-introduction","date":"2014-09-13T02:15:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/13/reactjs-add-ons-introduction/","link":"","permalink":"//andyyou.github.io/2014/09/13/reactjs-add-ons-introduction/","excerpt":"附加組件(Add-ons)官方會把一些實用的共用工具放置在 React.addons。這些工具應該暫時被視為還在實驗階段，但最後官方應該會將其整合進核心功能或者如下列共用的工具函式庫:","text":"附加組件(Add-ons)官方會把一些實用的共用工具放置在 React.addons。這些工具應該暫時被視為還在實驗階段，但最後官方應該會將其整合進核心功能或者如下列共用的工具函式庫: TransitionGroup 與 CSSTransitionGroup 是用來處理關於動畫和過場特效，不過它們通常不是這麼容易實作。 LinkedStateMixin 簡化處理使用者表單欄位和元件狀態之間的一些狀況。 classSet 讓操作 DOM 的 CSS 字串時的程式碼較簡潔。 TestUtils 簡單的測試工具。 cloneWithProps 複製 React 元件與修改 props。 update Javascript 函式，簡化處理不可變動的資料的過程。 下面列出的項目只存在 React 開發版本中: PureRenderMixin 適用於特定情況下改善效能。 Perf 用來測量效能並提供優化的建議。 當您需要使用這些附加組件時，請使用 react-with-addons.js ，而不是單純使用 react.js。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 關於工具整合","slug":"reactjs-about-tools","date":"2014-09-13T01:37:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/13/reactjs-about-tools/","link":"","permalink":"//andyyou.github.io/2014/09/13/reactjs-about-tools/","excerpt":"工具整合一般來說，每一個專案使用不同的建置方式，系統環境，以及部署方式。React 試著盡可能的讓一切與系統環境沒有任何相依性。意味著官方盡可能讓所有平台都能用一樣的方式運行 React。","text":"工具整合一般來說，每一個專案使用不同的建置方式，系統環境，以及部署方式。React 試著盡可能的讓一切與系統環境沒有任何相依性。意味著官方盡可能讓所有平台都能用一樣的方式運行 React。 ReactReact CDN在下載頁面官方提供了 React 的 CDN。這些預先編譯的檔案使用的是UMD 模組格式。將它們放置到 &lt;script&gt; 標簽中就可以注入 React 到您的全域環境中。在 CommonJS 與 AMD 的環境下只要引入就能馬上使用。 UMD 提供兼容多種環境的特性。為了達到這個目的，一般狀況，但不是全部，UMD 模組格式會把程式碼包進一個立即調用的函式(Immediately Invoked Function Expression，IIFE)中。 使用 Git 中的 masterReact 提供了一份說明，協助您在取得 GitHub(https://github.com/facebook/react) 後執行編譯建置。同時也提供了 CommonJS 方式的模組在 build/modules 目錄底下，您可以將它們放到任何環境或者支援 CommonJS 的封裝工具。 JSX瀏覽器下的 JSX 編譯如果您偏好使用 JSX ，您也可以在官方下載頁面找到這個可以在瀏覽器執行時期編譯 JSX 的 js 檔案 JSTransformer，以讓您可以在開發時方便的使用。單純的使用 &lt;script type=&#39;text/jsx&#39;&gt; 嵌入您的程式碼，搭配 JSX Transformer 即可。不過請注意要加入 /** @jsx React.DOM */ 在開始的地方，否則 JSX Transformer 將不會執行轉譯的工作。 注意: 瀏覽器版的 JSX 編譯檔案相當大，且必須耗費多餘的與要呈現的結果無關運算，這應該要避免。千萬別在發佈的產品上使用。 發佈: 預先編譯 JSX如果您已經有安裝 npm 那麼您可以很輕鬆的直接執行 npm install -g react-tools 來安裝 jsx 的指令工具。這個工具將會先幫你把 JSX 格式的檔案轉換為原始的 Javascript，然後您就可以直接使用。當然您也可以使用自動編譯的方式，透過 jsx --watch src/ build/，如此一來當目錄有任何變更的時候，指令工具就會自動幫您編譯。需要更多詳細的用法資訊請執行 jsx --help。 實用的開源專案開源碼社群已經有許多整合 JSX 的工具，查閱 JSX 整合工具 可以找到適合您的開源專案或工具。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"關於 Reactjs 的核心觀念","slug":"on-reacts-core-ideas","date":"2014-09-12T08:14:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/12/on-reacts-core-ideas/","link":"","permalink":"//andyyou.github.io/2014/09/12/on-reacts-core-ideas/","excerpt":"這篇文章為官方部落格的文章隻翻譯。原文。 以觀念來說React 是一種使用 Javascript 來快速建立大型 Web 的方式，它非常容易擴展，且官方已將其使用在 Facebook 與 Instagram 上。","text":"這篇文章為官方部落格的文章隻翻譯。原文。 以觀念來說React 是一種使用 Javascript 來快速建立大型 Web 的方式，它非常容易擴展，且官方已將其使用在 Facebook 與 Instagram 上。 其中最好的部分就是 React 讓您在建立程式時重新思考關於應用程式。在這篇文章，將會引導您使用 React 完成一個可以搜尋過濾產品資料的範例。 從模擬架構開始想像我們已經有了一個 JSON 的 API 以及一個設計師模擬的草圖。我們的設計師顯然不是很優，因為他的模擬像這樣： 而我們的 JSON API 傳回來的資料長得像這樣： 12345678[ &#123;category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"&#125;, &#123;category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"&#125;, &#123;category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"&#125;, &#123;category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"&#125;, &#123;category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"&#125;, &#123;category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"&#125;]; 第一步：拆解 UI 為元件階層結構您即將要做的第一個步驟是根據模擬的 UI 畫出每一個元件(包含子元件)的階層方塊並且給予名稱，如果你正在與設計師一起工作那可能你已經完成這個任務。看看他們的 Photoshop 中圖層的名稱大略就是你 React 元件最後的名稱。不過我們怎麼知道哪個部分應該是元件？當您建立一個新的函式或物件，您可以根據單一職責原則，指的是每一個元件理想的情況下應該只做一件事。如果該元件的功能不斷增加那就應該再把它拆解，並建立更小的子元件。 常見的需求是 - 顯示 JSON 的資料給使用者。根據過去的經驗，您會發現如果您的資料模型(Model)建立的正確，您的 UI (同時表示您的元件結構)就可以輕鬆的將資料呈現給使用者。其原因是使用者界面和資料模型往往遵循一樣的資料結構，意味著其實將 UI 獨立為元件並非很困難。就只是根據每一個小區塊需要呈現的資料模型去分解成個別的元件。 看到上圖，這個應用程式將會有 5 個元件，下面的斜體字表示每一個元件對應的模型 FilterableProductTable (橘色) 用來組織包含其他子元件，即這個元件的最上層的容器。 SearchBar (藍色) 取得 使用者輸入的搜尋條件。 ProductTable (綠色) 根據 使用者輸入的搜尋條件 顯示過濾後的資料列表。 ProductCategoryRow (青色) 顯示 分類 標題。 ProductRow (紅色) 顯示每一個 產品。 如果您認真觀察 ProductTable 你會看到表格還有標題列(即 Name 和 Price 欄位名稱那邊)並沒有被規劃為獨立元件。這只是偏好問題。根據這個範例，我們規劃這個區塊為 ProductTable 的一部份，這是因為輸出產品列表資料是 ProductTable 的責任，當然包含欄位名稱，且目前看來它的工作很單純並不需要再拆出一個元件。然而如果這個標題列變得越來越複雜(舉例來說：如果我們需要增加排序功能)，如此一來增加一個 ProductTableHeader 元件會是比較好的做法。 現在我們已經定義好關於這個模擬的元件架構，讓我們重新組織成一個階層圖，這樣我們就能清楚看出元件的主從關係。 FilterableProductTable SearchBar ProductTable- ProductCategoryRow - ProductRow 第二步：建立一個靜態版本的 React 元件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** @jsx React.DOM */var ProductCategoryRow = React.createClass(&#123; render: function() &#123; return (&lt;tr&gt;&lt;th colSpan=\"2\"&gt;&#123;this.props.category&#125;&lt;/th&gt;&lt;/tr&gt;); &#125;&#125;);var ProductRow = React.createClass(&#123; render: function() &#123; var name = this.props.product.stocked ? this.props.product.name : &lt;span style=&#123;&#123;color: 'red'&#125;&#125;&gt; &#123;this.props.product.name&#125; &lt;/span&gt;; return ( &lt;tr&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.product.price&#125;&lt;/td&gt; &lt;/tr&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render: function() &#123; var rows = []; var lastCategory = null; this.props.products.forEach(function(product) &#123; if (product.category !== lastCategory) &#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125; /&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;); return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; render: function() &#123; return ( &lt;form&gt; &lt;input type=\"text\" placeholder=\"Search...\" /&gt; &lt;p&gt; &lt;input type=\"checkbox\" /&gt; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var FilterableProductTable = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;SearchBar /&gt; &lt;ProductTable products=&#123;this.props.products&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var PRODUCTS = [ &#123;category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'&#125;, &#123;category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'&#125;, &#123;category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'&#125;, &#123;category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'&#125;, &#123;category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'&#125;, &#123;category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'&#125;];React.renderComponent(&lt;FilterableProductTable products=&#123;PRODUCTS&#125; /&gt;, document.body); 現在您已經有了元件的階層結構。該是時候實作程式的功能了。在學習 React 的過程中，我們推薦最簡單的方式是一開始只要建立一個能取得資料模型和渲染出 UI 畫面但是不能互動的版本。拆成這些步驟是因為建立靜態版本通常是需要打很多字且不太需要思考，而建立互動機制需要您仔細的構思，如此一來在建立元件時比較不會出錯。 在建立靜態版本的時候通常你會思考關於元件 重複使用 的機會以及該怎麼透過 props 從父元素傳入資料。如果您已經熟悉關於 state 的觀念，就會知道在建立靜態版本時根本不應該使用 state。state 是互動時才會需要用到的功能，所謂的互動指的是當資料變動，而 UI 也需要對應更新。由於這只是靜態版本所以根本不需要用。 您可以由底層往上或者由上而下撰寫您的元件，意思是說你可以選擇從結構中最外層的元件開始建起(即從 FilterableProductTable)開始，或者從最內部的子元件開始(ProductRow)。在單純的範例中，通常從上至下相對快速，而如果專案較大，通常從下而上會比較推薦，因為也同時方便您撰寫測試，可以逐步測試元件是否正常。 在這一步的最後，您會得到一個可重複使用元件的函式庫，你可以用它來輸出呈現你的資料模型，以確認 UI 的呈現是否有誤。不過這個元件只有 render() 方法，因為截至目前為止它還只是靜態版本。 元件的最上層(FilterableProductTable)將會取得資料模型，透過屬性傳入資料。如果你修改了 Model 的資料且再次執行 renderComponent() 你應該會看到資料更新了。這讓你可以清楚地觀察這個元件是怎麼更新資料，這就是 React 透過 one-way data flow (或稱 one-way binding) 單向數據流的方式去保持所有資料一致，同時也方便模組化。 簡易補充: props vs state在 React 裏有兩種類型的 Model 就是你放資料的地方：props 與 state。理解他們的區別非常重要，如果您還不懂他們之間的差別請閱讀官方或者這篇文章 第三步：定義最少但完整的 UI 狀態為了讓您的 UI 俱有互動性，你可能會需要讓資料模型做些修改，接著 UI 根據 one-way binding 更新資料。React 透過使用 state 讓這一切變得很簡單。您可以把 state 想是讓您存放動態資料的地方，而當資料有所變動，React 會自動呼叫 render() 執行 UI 的更新。 而要讓建立的程式能夠正確執行，首先需要思考關於這個程式最少需要哪些可變動的狀態，只有變動的資料才需要放到 state。關鍵的原則是 DRY (Don’t Repeat Yourself) ，不重複原則。找出程式在特定需求內必須要的最少狀態。例如：如果你要建立一個 TODO List，其實你就只要一個陣列包含待辦清單的項目。當你需要計算項目總數時，不需要在 state 中的儲存另一個變數，而是單純使用陣列取得數量即可。 思考我們這個範例中各種取得的資料 所有產品的列表 Search input 的搜尋條件 checkbox 是否有被選取的值 過濾後的清單 讓我們一個一個討論看看誰是屬於 state 。簡單的思考關於這三個問題 資料是透過 props 從父元素傳進來的嗎？如果是，這可能不屬於 state 。 這資料會隨著時間推移而改變嗎？ 如果不是，那它應該不屬於 state 。 你能從現有任何 state 或者 props 計算出這個資料嗎？如過是！那這肯定不屬於 staet。 產品列表是透過 props 傳遞進來的，所以這不應該存在 state，當然有經驗的開發者會說這通常從資料庫來，但這個範例不是。搜尋條件和 checkbox 似乎是狀態，因為他們會改變。而且是不能透過計算得到的。最後過濾後的清單也不該儲存在 state ，因為他是可以被計算出來的，根據我們拿到的過濾條件去運算。所以最後我們歸納出應該被放在 state 的有: 搜尋條件 checkbox 的值 第四步：應該在何處使用 state123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** @jsx React.DOM */var ProductCategoryRow = React.createClass(&#123; render: function() &#123; return (&lt;tr&gt;&lt;th colSpan=\"2\"&gt;&#123;this.props.category&#125;&lt;/th&gt;&lt;/tr&gt;); &#125;&#125;);var ProductRow = React.createClass(&#123; render: function() &#123; var name = this.props.product.stocked ? this.props.product.name : &lt;span style=&#123;&#123;color: 'red'&#125;&#125;&gt; &#123;this.props.product.name&#125; &lt;/span&gt;; return ( &lt;tr&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.product.price&#125;&lt;/td&gt; &lt;/tr&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render: function() &#123; var rows = []; var lastCategory = null; this.props.products.forEach(function(product) &#123; if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked &amp;&amp; this.props.inStockOnly)) &#123; return; &#125; if (product.category !== lastCategory) &#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125; /&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;.bind(this)); return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; render: function() &#123; return ( &lt;form&gt; &lt;input type=\"text\" placeholder=\"Search...\" value=&#123;this.props.filterText&#125; /&gt; &lt;p&gt; &lt;input type=\"checkbox\" value=&#123;this.props.inStockOnly&#125; /&gt; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var FilterableProductTable = React.createClass(&#123; getInitialState: function() &#123; return &#123; filterText: '', inStockOnly: false &#125;; &#125;, render: function() &#123; return ( &lt;div&gt; &lt;SearchBar filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;ProductTable products=&#123;this.props.products&#125; filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var PRODUCTS = [ &#123;category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'&#125;, &#123;category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'&#125;, &#123;category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'&#125;, &#123;category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'&#125;, &#123;category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'&#125;, &#123;category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'&#125;];React.renderComponent(&lt;FilterableProductTable products=&#123;PRODUCTS&#125; /&gt;, document.body); OK 我們已經決定了這個元件程式最少的 state，下一步我們需要定義哪些元件是要變動的，以及是哪些要使用 state 。記住！React 提供的是一種單向資料流的結構，通常是由上而下。剎那間可能不太輕易判斷哪個元件該管理或使用 state，這通常也是初學者最難理解的部分。請跟著下面這些規則去推敲: 思考程式中需要使用到 state 的部分 找出哪些元件需要根據 state 輸出不同的結果 找出共同的擁有者元件(最上層的元件通常需要管理 state) 如果你不能找出某一個元件該擁有狀態的理由，那就建立一個新的元件用來管理狀態，並且加在共同擁有者元件之上。 讓我們應用這些規則在這個範例上 ProductTable 需要根據 state 過濾產品列表以及 SearchBar 需要顯示搜尋條件的值和 checkbox 的狀態。 共同擁有者元件是 FilterableProductTable。 把過濾條件和 checkbox 值都放在 FilterableProductTable 在概念上也是合理的。 所以我們決定 state 應該放在 FilterableProductTable ，首先加上 getInitialState() 方法，讓它回傳一個物件 {filterText: &#39;&#39;, inStockOnly: false}這是用來初始化 state 的，接著傳入 filterText 和 inStockOnly 給 SearchBar 當作屬性，最後在 ProductTable 中使用這些屬性值去過濾，並且設定 form 的值。 現在你可以看到您的應用程式俱有這些行為：在 state 中把 filterText 的值設成 ball 然後資料就會更新。 註：先別急著操作網頁上的 form。 第五步：加入反向數據流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** @jsx React.DOM */var ProductCategoryRow = React.createClass(&#123; render: function() &#123; return (&lt;tr&gt;&lt;th colSpan=\"2\"&gt;&#123;this.props.category&#125;&lt;/th&gt;&lt;/tr&gt;); &#125;&#125;);var ProductRow = React.createClass(&#123; render: function() &#123; var name = this.props.product.stocked ? this.props.product.name : &lt;span style=&#123;&#123;color: 'red'&#125;&#125;&gt; &#123;this.props.product.name&#125; &lt;/span&gt;; return ( &lt;tr&gt; &lt;td&gt;&#123;name&#125;&lt;/td&gt; &lt;td&gt;&#123;this.props.product.price&#125;&lt;/td&gt; &lt;/tr&gt; ); &#125;&#125;);var ProductTable = React.createClass(&#123; render: function() &#123; console.log(this.props); var rows = []; var lastCategory = null; this.props.products.forEach(function(product) &#123; if (product.name.indexOf(this.props.filterText) === -1 || (!product.stocked &amp;&amp; this.props.inStockOnly)) &#123; return; &#125; if (product.category !== lastCategory) &#123; rows.push(&lt;ProductCategoryRow category=&#123;product.category&#125; key=&#123;product.category&#125; /&gt;); &#125; rows.push(&lt;ProductRow product=&#123;product&#125; key=&#123;product.name&#125; /&gt;); lastCategory = product.category; &#125;.bind(this)); return ( &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt; &lt;/table&gt; ); &#125;&#125;);var SearchBar = React.createClass(&#123; handleChange: function() &#123; this.props.onUserInput( this.refs.filterTextInput.getDOMNode().value, this.refs.inStockOnlyInput.getDOMNode().checked ); &#125;, render: function() &#123; return ( &lt;form&gt; &lt;input type=\"text\" placeholder=\"Search...\" value=&#123;this.props.filterText&#125; ref=\"filterTextInput\" onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt; &lt;input type=\"checkbox\" value=&#123;this.props.inStockOnly&#125; ref=\"inStockOnlyInput\" onChange=&#123;this.handleChange&#125; /&gt; Only show products in stock &lt;/p&gt; &lt;/form&gt; ); &#125;&#125;);var FilterableProductTable = React.createClass(&#123; getInitialState: function() &#123; return &#123; filterText: '', inStockOnly: false &#125;; &#125;, handleUserInput: function(filterText, inStockOnly) &#123; this.setState(&#123; filterText: filterText, inStockOnly: inStockOnly &#125;); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;SearchBar filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; onUserInput=&#123;this.handleUserInput&#125; /&gt; &lt;ProductTable products=&#123;this.props.products&#125; filterText=&#123;this.state.filterText&#125; inStockOnly=&#123;this.state.inStockOnly&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var PRODUCTS = [ &#123;category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'&#125;, &#123;category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'&#125;, &#123;category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'&#125;, &#123;category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'&#125;, &#123;category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'&#125;, &#123;category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'&#125;];React.renderComponent(&lt;FilterableProductTable products=&#123;PRODUCTS&#125; /&gt;, document.body); 到上面為止你會發現除非你手動更改 state 的設定，如果你在網頁的表單上輸入任何東西，input 完全沒反應。這是因為 React 是單向數據流的模式。現在讓我們補上其他方向來的數據，由於表單元件在這個結構的內部，而我們只能用 FilterableProductTable 去更新 state 。React 使得數據流非常明確，清楚易懂，歸納的結論就是更新 state 和資料操作請在 owner 擁有者元件裡作，而當子元件的觸發的行為需要更新數據時還是拿父元件的方法。不過這個方式的缺點就是你需要多打一些字，相較于 two-way binding。雖然 React 也提供一個擴充套件叫做 ReactLink 它可以協助您快速做到 two-way binding，不過這篇文章是用來說明整個React 基礎的觀念，所以我們不打算在這篇提太多額外的東西以免造成混淆。 如果您是著輸入一些條件或者勾起 checkbox 在這上一版的程式碼，您會看到 React 忽略您的輸入。這是故意的，因為我們已經設定 input 的 value 是 this.state.filterText ，他就要確保永遠等於這個參考讓我們來想想我們希望怎樣，我們希望確保使用者輸入的任何改變都是去更新 state ，而 input 則一樣從 state 取得資料。 FilterableProductTable 就要把修改 state 的函式傳給 SearchBar，如此一來當 input 觸發 onChange 時才能變更 state。雖然這樣聽起來好像會多了不少程式碼，但這能確保資料流向是非常清楚的。 最後，就這樣而已希望這篇文章能夠使您理解關於 React 如何建立元件和應用程式的觀念。雖然它比起你現在的框架或程式碼的確讓你多打了一些字，不過記住讀程式碼遠遠比撰寫還要困難，而這麼做會讓你的程式碼模組化且非常容易閱讀。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"理解 Javascript 的 Function.prototype.bind","slug":"understanding-javascript-functionprototypebind","date":"2014-09-11T07:51:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/11/understanding-javascript-functionprototypebind/","link":"","permalink":"//andyyou.github.io/2014/09/11/understanding-javascript-functionprototypebind/","excerpt":"Function.prototype.bind 函式繫結大概是當您開始學習 Javascript 時最後關注到的議題。通常是當您遇到一種狀況：需要在其他 Function 保留 this 的執行環境(Context)。講執行環境可能太抽象，舉例來說就是當您需要在函式的另外一個函式中呼叫 this.action() 的時候。(這邊如果看不懂請耐著性子看下去)不過通常這時您可能也不知道您需要的就是 Function.prototype.bind()。","text":"Function.prototype.bind 函式繫結大概是當您開始學習 Javascript 時最後關注到的議題。通常是當您遇到一種狀況：需要在其他 Function 保留 this 的執行環境(Context)。講執行環境可能太抽象，舉例來說就是當您需要在函式的另外一個函式中呼叫 this.action() 的時候。(這邊如果看不懂請耐著性子看下去)不過通常這時您可能也不知道您需要的就是 Function.prototype.bind()。 第一次您遇到上述的問題，您可能會傾向于把 this 儲存成一個變數，接著即便您切換了 Context 還是可以參考到這個物件。如果您看不懂上面在說什麼，請先參考這篇文章。許多人會採用 self, _this 或者 context 當作變數名稱，並且把 this 放進去。這些方法都是可行的且並沒有什麼不妥，但有一個更不錯的方式。 我們實際上要解決的問題是？下面有一份簡單的範例程式碼，情況是某人忘記把 Context 存成一個變數： 123456789101112131415161718192021222324252627282930313233343536/** * 我們舉例一個機器人物件，機器人有一些基本的 function 來執行動作 * 不過問題是當我們要求機器人執行動作的時候，他需要先到確定還有沒有能量。 * * * Note: 這段程式碼只是希望能夠用具像化一點的比喻來說明。 */var Robot = &#123; /** private */ power: 100, walk: function () &#123; console.log('Robot walked'); this.power -= 10; &#125;, fly: function () &#123; console.log('Robot flied'); this.power -= 20; &#125;, check: function (excute) &#123; if (this.power &gt; 0) excute(); &#125;, /** public */ showoff: function () &#123; this.check(function () &#123; this.walk(); /* 實際執行的動作。 */ this.fly(); &#125;) &#125;&#125;Robot.showoff(); 如果照著上面把實際要執行的動作當作 callback 傳給 check()，當您要再次呼叫 this.walk() 的時候就會發現出現錯誤訊息 1TypeError: Object #&lt;Object&gt; has no method &apos;walk&apos; 這是因為我們再次傳進去的匿名函式不知道關於 this 的東西，在這裏我們並沒有善用閉包來保存 Context。而對很多人可能就會把上面的範例修改為如下 123456789101112131415161718192021222324252627282930var Robot = &#123; /** private */ power: 100, walk: function () &#123; console.log('Robot walked'); this.power -= 10; &#125;, fly: function () &#123; console.log('Robot flied'); this.power -= 20; &#125;, check: function (excute) &#123; if (this.power &gt; 0) excute(); &#125;, /** public */ showoff: function () &#123; var that = this; this.check(function () &#123; that.walk(); /* 實際執行的動作。 */ that.fly(); &#125;) &#125;&#125;Robot.showoff(); 宣告成區域變數之後，閉包就會幫助我們 Keep 這個 Context，這也是相對直覺的方式，同上面說的這沒有任何不妥。不過我們知道了一件事，就是我們需要保存 Robot 這個物件參考的 Context，給 Callback 即範例中的 excute。當我們呼叫 that.walk() 的時候其實就是在使用閉包。根據 MDN 說明，其實閉包就是一個特殊的物件，它有兩個含義： 它是一個 function。 它產生了一個 Context ，概略的說就是幫你記錄上一層有宣告的變數。 這裏就不詳細說明關於閉包，不理解的推薦這篇文章和這篇 閉包的方式已經可以運作了，但是我們覺得他不夠漂亮，因此我們就來使用 Function.prototype.bind()。 讓我們來重構上面的程式範例 123456789101112131415161718192021222324252627282930var Robot = &#123; /** private */ power: 100, walk: function () &#123; console.log('Robot walked'); this.power -= 10; &#125;, fly: function () &#123; console.log('Robot flied'); this.power -= 20; &#125;, check: function (excute) &#123; if (this.power &gt; 0) excute(); &#125;, /** public */ showoff: function () &#123; // var that = this; this.check(function () &#123; this.walk(); this.fly(); &#125;.bind(this)); &#125;&#125;Robot.showoff(); 我們剛剛做了什麼？？當我們呼叫了 .bind() 的時候，其實它非常單純的建立了一個新的 function，只不過這個 function 把 this 的值綁定進去。所以我們同時把我們想要的 Context(即 Robot 物件) 給保存了下來。接著當我們的回呼函式在執行的時候 this 就是參考到 Robot 這個物件。 如果你有興趣了解 Function.prototype.bind() 內部運行機制，他看起來大概就像下面這樣 123456Function.prototype.bind = function (scope) &#123; var fn = this; return function () &#123; return fn.apply(scope); &#125;;&#125; 接著我們再來看看一個非常簡單的案例： 12345678910111213var foo = &#123; x: 3&#125;var bar = function () &#123; console.log(this.x);&#125;bar(); // undefinedvar boundFunc = bar.bind(foo);boundFunc(); // 3 這個範例是說，bind() 幫我們建立了一個新的 function ，並且當我們執行時這個 function 的 this 是指向 foo，而不是全域。如果您還是不清楚可以大略理解為：把 function 掛到某個物件底下(當然不是真的加進去)，只是這樣一來可以透過 this 取得該物件的 Context。 實務應用當我們學習某些東西時，我不只需要理解觀念，也會試著將其套用在實務上以驗證自己是否明白。來看看一些實務上的應用吧！ Click 事件處理其中一個用途是拿它來追蹤點擊次數，然後可能是要把它存在某個物件裡類似下面這樣 1234567var logger = &#123; x: 0, increment: function () &#123; this.x++; console.log(this.x); &#125;&#125; 然後指派一個按鈕的 Click 處理函式去呼叫 logger 物件 123document.querySelector('button').addEventListener('click', function () &#123; logger.increment();&#125;); 不過上面這種做法，我們已經建立了一個不必要的匿名函式，並且因為這個匿名函式使用了 logger 呼叫了 increment() 所以產生了一個閉包用以確保了 this 是正確的參考物件。不明白！？再看看下面這個最根本的寫法吧 1document.querySelector('button').addEventListener('click', logger.increment); // NaN 原本是這樣的，當你 Click 的時候執行一個 function ，不過如果你用上面這種寫法的話，意思是你只是把 function 傳進去，根據 this 的定義他其實是指的是誰(哪個物件)呼叫這個函式 this 就是指向它。而這裡呼叫的人根本不是 logger 這個物件。也因此使用了一個匿名函式，建立了一個閉包，就是為了保留住 logger 物件的狀態。 好了！講完上面這些我們來看看更乾淨的寫法： 1document.querySelector('button').addEventListener('click', logger.increment.bind(logger)); 現在，對於 bind() 應該比較不陌生了吧！本篇是在寫 React 時產生了一點疑問所研究的筆記，因為在 React 中蠻多機會的使用 bind。如官方的範例 123456789101112componentDidMount: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(this.props.url, status, err.toString()); &#125;.bind(this) &#125;);&#125;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Gulp 使用問題與記錄","slug":"gulp-real-notes","date":"2014-09-10T12:14:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/09/10/gulp-real-notes/","link":"","permalink":"//andyyou.github.io/2014/09/10/gulp-real-notes/","excerpt":"這篇文章除了記錄一下最後只是堪用的解法，如果有高手知道更好的做法煩請賜教。 話說小弟今天要來寫一些 React 的測試專案，就想說那就搭上 Gulp 吧！原本的目的很單純就只是用 Gulp compile 一些常用的 meta language，像是 Less, Jade 外加上 Jsx。也不是什麼很大的專案所以架構上其實就是在 React 的 StartKit上面再開個自己的測試目錄。","text":"這篇文章除了記錄一下最後只是堪用的解法，如果有高手知道更好的做法煩請賜教。 話說小弟今天要來寫一些 React 的測試專案，就想說那就搭上 Gulp 吧！原本的目的很單純就只是用 Gulp compile 一些常用的 meta language，像是 Less, Jade 外加上 Jsx。也不是什麼很大的專案所以架構上其實就是在 React 的 StartKit上面再開個自己的測試目錄。 一開始也都用的很開心，然後就發現：在啟動 server 支援 livereload 後，當從 src 目錄刪除檔案，dist 目錄的檔案竟然沒被刪掉！！！(好啦！我知道正確來說應該是要先輸出到 .tmp 在 copy)。說明一下我想完成的目標就是： 一個簡單的 Server 支援 watch &amp; livereload。 存檔後直接把 src 底下的檔案編譯至對應的 dist 目錄下。 接著我希望 dist 目錄下的檔案要正確的對應，意思是如果我新增/刪除一個檔案，那 dist 也要新增/刪除。 直覺反應這也不是什麼大問題，那就補上 clean 的套件就好，一開始沒注意到 gulp-clean 有非同步的小問題因為我是要刪 dist 而不是 src 所以直覺得拆成兩個 task，想說我任務都有照順序先 clean 在 compile 為什麼一下噴 Error，一下又正常，再加上一開始不想要用全部清掉這種方式。 於是就讓我 Google 到這一篇 Delete feature request ，因為下面有人提到使用 gulp-filter 的方式，接著我就將 watch 的 task 部分換成 123gulp.task('default', function () &#123; watch('css/**/*.css').pipe(gulp.dest('./dist/'));&#125;); 這種寫法，並補上 filter ，本來以為要打完收工的時候，卻發現我對 Node 很多東西觀念太薄弱，我不會替 vinyl-fs 物件綁上 event，也不知道怎麼根據 pipe() 來的檔案資訊來切換目錄，且有人提到可以用 gaze 的方式我試了半天也宣告失敗。附帶一提當你使用上面這種 watch 的寫法時其實 log 的資訊比較清楚。 最後差強人意的 gulpfile 在下面，最後如果有興趣要測的可以用 Github 測試環境在 playground 目錄下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081var gulp = require('gulp'), connect = require('gulp-connect'), less = require('gulp-less'), react = require('gulp-react'), watch = require('gulp-watch'), jade = require('gulp-jade'), clean = require('gulp-clean');/*** Compilers*/gulp.task('less', ['clean-css'], function () &#123; gulp.src('playground/src/styles/less/*.less') .pipe(less()) .pipe(gulp.dest('playground/dist/css'));&#125;);gulp.task('clean-css', function () &#123; gulp.src('playground/dist/css/*', &#123;read: false&#125;).pipe(clean(&#123;force: true&#125;));&#125;);gulp.task('jsx', ['clean-js'], function () &#123; gulp.src('playground/src/scripts/jsx/*.jsx') .pipe(react()) .pipe(gulp.dest('playground/dist/js/'));&#125;);gulp.task('clean-js', function () &#123; gulp.src('playground/dist/js/*', &#123;read: false&#125;).pipe(clean(&#123;force: true&#125;));&#125;);gulp.task('jade', ['clean-html'], function () &#123; gulp.src('playground/src/templates/**.jade') .pipe(jade()) .pipe(gulp.dest('playground'));&#125;);gulp.task('clean-html', function () &#123; gulp.src('playground/*.html', &#123;read: false&#125;).pipe(clean(&#123;force: true&#125;));&#125;);/*********************************************************//*** Web Server*/gulp.task('server', function () &#123; connect.server(&#123; root: ['playground'], livereload: true &#125;);&#125;);gulp.task('livereload', function () &#123; watch(['playground/*.html', 'playground/dist']) .pipe(connect.reload());&#125;);gulp.task('watch', function () &#123; gulp.watch('playground/src/styles/less/*.less', ['less']); gulp.watch('playground/src/scripts/jsx/*.jsx', ['jsx']); gulp.watch('playground/src/templates/**.jade', ['jade']);&#125;);/*********************************************************//*** Mixin feature of usage*/gulp.task('default', ['less', 'jsx', 'jade', 'server', 'livereload', 'watch']);","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"gulp","slug":"gulp","permalink":"//andyyou.github.io/tags/gulp/"},{"name":"task runner","slug":"task-runner","permalink":"//andyyou.github.io/tags/task-runner/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"使用 Gulp 為前端開發伺服器","slug":"using-gulp-for-front-end-development-server","date":"2014-08-26T11:59:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/08/26/using-gulp-for-front-end-development-server/","link":"","permalink":"//andyyou.github.io/2014/08/26/using-gulp-for-front-end-development-server/","excerpt":"因為 Gulp 這個任務執行工具最近越來越流行，所以想說試著用它來做些事情，其實它跟 Grunt 一樣可以拿來處理很多事情像是整合 Javascript 檔案，壓縮圖片等等。如果你之前從來沒聽過 Gulp 這裡建議您先閱讀 英文教學, Gulp 初體驗。在這篇文章中，我們將學習使用 Gulp 來完成一個簡單的小型伺服器以協助您平日的前端開發，當然這也支援 livereload。","text":"因為 Gulp 這個任務執行工具最近越來越流行，所以想說試著用它來做些事情，其實它跟 Grunt 一樣可以拿來處理很多事情像是整合 Javascript 檔案，壓縮圖片等等。如果你之前從來沒聽過 Gulp 這裡建議您先閱讀 英文教學, Gulp 初體驗。在這篇文章中，我們將學習使用 Gulp 來完成一個簡單的小型伺服器以協助您平日的前端開發，當然這也支援 livereload。 從前的方式假想一下當你想開發一個 SPA (單頁式應用程式)，這個應用程式的進入點是 index.html ，最後我們的目標是透過 localhost 來存取這個頁面。為什麼一定要用 localhost 因為一些安全機制你不能直接透過 file:/// 的檔案來執行 ajax，在過去或許你會安裝一個 Apache 或 Nginx 伺服器，學會這招！你將不再需要為了開發把自己的機器弄髒了。(當然 Grunt 也能辦到請參考) 更好的方式今時今日，Javascript 幾乎實作了所有的東西，包含一個 Web Server，其中最流行的一個叫做 Connect，我們將使用它透過一個 Gulp 的擴充套件 gulp-connect 來完成我們的目的。接下來的文章我們將會學習如何設定一個 Web Server，所以我假設你已經懂了基本的 Gulp 和 關於如何使用 gulpfile.js。 初始化設定12345$ mkdir spa-website$ cd spa-website$ npm init$ npm install --save-dev gulp$ npm i -D gulp-connect # 縮寫 現在我們可以來定義 Web Server 的任務了，我們的 gulpfile.js 看起來會像下面 12345678var gulp = require('gulp'), connect = require('gulp-connect');gulp.task('webserver', function() &#123; connect.server();&#125;);gulp.task('default', ['webserver']); 超級直覺的吧！現在你可以啟動一個 Web Server ，透過在 terminal 執行 gulp 指令，然後開啟瀏覽器輸入 localhost:8080 如果你在目錄中有 index.html 你就能看到網頁。這個小型的 Web Server 是掛載在 gulpfile.js 放置的目錄之上也就是 localhost:8080 的根目錄，換個角度說吧！通常我們會在一個目錄組織自己的 nodejs 專案，而這個 gulpfile.js 要放在專案的根目錄，因為你會需要 require node_module 裡面的 gulp，同時也方便你組織路徑。一旦你執行 gulp 指令這個 Server 就會啟動直到你使用 Ctrl + c 結束這個任務。如果你已經有經驗的話那也可以直接查閱 Github 看看範例。每一個範例包含了所有待會實作的結果，你只需要下 npm install 安裝所有相依的套件即可使用。 加入 livereload如上面所看到的使用 gulp 建立一個 Web Server 是非常簡單的。下一步讓我們繼續來加入 livereload 支援，這樣一來當我們更新頁面的內容瀏覽器就會自動更新就不用一直手動更新頁面。我們需要做兩件事讓 gulp 的 Web Server 支援 livereload ，第一件事情是設定 Web Server 就是我們的 gulp-connect 支援 livereload ，接著我們必須通知 livereload 何時要更新頁面。第一個步驟非常簡單直接設定 livereload: true 設定 server 這個任務如下 12345gulp.task('server', function () &#123; connect.server(&#123; livereload: true, &#125;);&#125;); 第二個步驟則視您的需求，在這個範例我們會設定自動編譯 LESS 檔案為 CSS 然後把更新的內容提交給瀏覽器。讓我們來看看這個範例的部分。我們需要一個偵測器，這個東西的用途是判斷 LESS 檔案是否被變更，接著這個偵測器會去觸發 LESS 編譯的任務，然後就會輸出 CSS 檔案，接下來這個檔案應該要透過 livereload 注入。 根據我們的需求我們會需要使用 gulp-less 這個外掛是用來編譯 LESS 的，同樣的你需要透過 npm install --save-dev gulp-less 去安裝這個套件。而所謂的偵測器已經附加在 gulp.js 裡面了，我們這個應用程式的架構大致上像這樣 1234567├── node_modules│ └── ...├── styles│ └── main.less├── gulpfile.js├── index.html└── package.json 剛剛我們提到了偵測器，我們這邊用的就是 gulp.watch() 這個方法，他的功用就如上面說的當觀察到某個檔案產生變化，通常就是你存檔的瞬間，它就可以去觸發你設定的任務。在這個範例中就是一個 watch 的任務，Gulp.js 會一直監聽所有在 styles 目錄中符合 *.less 的檔案(就是任意名稱且附檔名為 less 的檔案)，接著當他看到檔案改變了就要去觸發 less 任務，這邊我們編譯的就是 main.less 這個 LESS ，每一次執行完編譯的動作，其結果將自動被注入到瀏覽器。關於 gulpfile.js 看起來會像下面這樣 12345678910111213141516171819202122var gulp = require('gulp'), connect = require('gulp-connect') less = require('gulp-less');gulp.task('server', function () &#123; connect.server(&#123; livereload: true &#125;);&#125;);gulp.task('less', function () &#123; gulp.src('styles/*.less') .pipe(less()) .pipe(gulp.dest('styles')) .pipe(connect.reload());&#125;);gulp.task('watch', function () &#123; gulp.watch('styles/*.less', ['less']);&#125;);gulp.task('default', ['less', 'server', 'watch']); 完成設定之後回到 Terminal 執行 gulp 然後在瀏覽器開啟 localhost:8080。我們現在可以對 LESS 做一些修改然後存檔，在這一瞬間 gulp 已經完成編譯並且 refresh 您的瀏覽器了，注意到這邊這個方式並不需要額外安裝 livereload 的瀏覽器擴充元件。livereload 以不同的方式運作。 調整設定注意上面的 gulpfile.js 只是一個小小的示範，以讓你可以快速理解如何建立一個 gulp 搭配 gulp-connect 支援 livereload 的 Web Server。我非常建議您可以搜尋一些其他的套件將它們組合出一些其他的任務，你應該試著重組這些任務結構，並且試試非內建的 gulp-watch 套件，它可以讓你處理剛剛變更過的檔案，隨著你要處理的任務越來越多這將會非常有幫助。讓我們簡單地用實際範例說明一下吧！你會發現除了 LESS 變更會自動更新，如果你是變更 HTML 那 livereload 並不會有任何反應，為什麼？因為你並沒有觀察 html ，所以你可能會像下面這樣 12345678910111213141516171819202122232425262728var gulp = require('gulp'), connect = require('gulp-connect'), less = require('gulp-less');gulp.task('server', function () &#123; connect.server(&#123; livereload: true &#125;);&#125;);gulp.task('less', function () &#123; gulp.src('styles/main.less') .pipe(less()) .pipe(gulp.dest('styles/')) .pipe(connect.reload());&#125;);gulp.task('html', function () &#123; gulp.src('*.html') .pipe(connect.reload());&#125;);gulp.task('watch', function () &#123; gulp.watch('styles/*.less', ['less']); gulp.watch('*.html', ['html']);&#125;);gulp.task('default', ['less', 'server', 'watch']); 這個時候如果改用 gulp-watch 那麼設定檔就會像下面這樣 123456789101112131415161718192021222324252627var gulp = require('gulp'), connect = require('gulp-connect'), less = require('gulp-less'), watch = require('gulp-watch');gulp.task('server', function () &#123; connect.server(&#123; livereload: true &#125;);&#125;);gulp.task('less', function () &#123; gulp.src('styles/*.less') .pipe(watch(function (f) &#123; return f.pipe(less()) .pipe(gulp.dest('styles/')) .pipe(connect.reload()); &#125;));&#125;);gulp.task('html', function () &#123; gulp.src('*.html') .pipe(watch(function (files) &#123; files.pipe(connect.reload()); &#125;))&#125;);gulp.task('default', ['less', 'html', 'server']); 你就不需要再多一個 watch 的任務了。兩種方式您都可以使用端看您的偏好。 設定 hostname 和 port 號關於 gulp-connect 他其實有很多設定選項，在這個範例中我們將設定一個 hostname 和使用 80 port 這樣一來你就可以少打一點字 1234connect.server(&#123; post: 80, host: gulp.dev&#125;) 先別急著執行，為了讓你設定的 hostname 能夠運作你必須要先將這個網域名稱加到你的 hosts 1127.0.0.1 gulp.dev 然後執行 sudo gulp 必須要有 sudo 權限才能使用 80 port 其他進階的功能你甚至可以使用 connect 套件在同一時間產生多個 Web Server 服務，這對您的開發也是有幫助的舉例來說你可以執行一個開發用的 Server 然後同時執行整合測試。gulp-connect 也允許您使用多個目錄為根目錄，舉例來說當你使用 CoffeeScript 你會希望把一些編譯的 Javascript 檔案放在 .tmp 暫存目錄然後把這個目錄 mount 上來當根目錄用，如此你就不會把你的專案目錄弄髒了。 重構在前面的範例我們只不過小試了一下用 gulp 來編譯 LESS 然後使用 gulp-connect 搭配 livereload ，實際上我們可以做的更好。當混合多種編譯和 livereload 到同一個任務的時候有可能會有一些問題和導致整個設定越來越混亂，所以讓我們來把他們分離並且讓偵測器在檔案一變更的時候就直接做些處理，為了達到這個目的，我們會需要使用剛剛提到的 gulp-watch。 然後我們加入編譯 CoffeeScript 的任務，下面這個新的設定結構將會更加清楚。首先我們先安裝需要的套件 12$ npm i -D gulp-watch$ npm i -D gulp-coffee 安裝好之後 require 這些套件函式庫，在下面這些步驟中我假設你已經有一些 .coffee 的檔案在 scripts 目錄，如果沒有你可以到這邊下載。重構後的 gulpfile.js 如下 12345678910111213141516171819202122232425262728293031323334353637var gulp = require('gulp'), connect = require('gulp-connect'), less = require('gulp-less'), watch = require('gulp-watch'), coffee = require('gulp-coffee');gulp.task('server', function () &#123; connect.server(&#123; root: ['.', '.tmp'], livereload: true &#125;);&#125;);gulp.task('livereload', function () &#123; gulp.src(['.tmp/styles/*.css', './tmp/scripts/*.js', '*.html']) .pipe(watch()) .pipe(connect.reload());&#125;);gulp.task('less', function () &#123; gulp.src('styles/main.less') .pipe(less()) .pipe(gulp.dest('.tmp/styles'));&#125;);gulp.task('coffee', function () &#123; gulp.src('scripts/*.coffee') .pipe(coffee()) .pipe(gulp.dest('.tmp/scripts'));&#125;);gulp.task('watch', function () &#123; gulp.watch('styles/*.less', ['less']); gulp.watch('scripts/*.coffee', ['coffee']);&#125;);gulp.task('default', ['less', 'coffee', 'server', 'livereload', 'watch']); 這個版本最大的改變是我們增加了 livereload 任務，這個任務透過 gulp-watch 來觀察那些已經被編譯完成的檔案，只要他們有變動就幫忙 reload 。套件提供的 watch() 函式允許我們只重載那些變更的檔案，而內建的 gulp.watch() 將會重載所有檔案，而不是只有變更的檔案。因為這個額外的任務我們不需要在每個任務後面加上 .pipe(connect.reload()) ，所以我們達到了任務的關注點分離，比起全部混在一起這可能是比較好的做法。我們同時也注意到那些被編譯的檔案不是存在對應的原始碼目錄中，他們被放在暫存的目錄裡 .tmp 這樣的好處是這些編譯的檔案不會污染 styles, scripts 目錄，並且在實務上我們通常會排除這個 .tmp 目錄進入我們的版控。但我們又直接把它 mount 到了根目錄如此一來程式碼路徑就不用變更了。 結論你已經學會了關於 Gulp 如何設定為你的開發伺服器了。你可以結合這個技術到各種專案去，注意這個 Web Server 只適合當作本地開發機如果是產品，你還是應該使用像是 Nginx 這類的伺服器。任何剛剛做到的任務你都可以使用 Grunt 達成。只不過 Gulp 設定起來對程式設計師比較直覺。","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"gulp","slug":"gulp","permalink":"//andyyou.github.io/tags/gulp/"},{"name":"task runner","slug":"task-runner","permalink":"//andyyou.github.io/tags/task-runner/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"iOS UIScrollView 使用 Autolayout","slug":"ios-use-uiscrollview-autolayout","date":"2014-08-09T12:15:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/08/09/ios-use-uiscrollview-autolayout/","link":"","permalink":"//andyyou.github.io/2014/08/09/ios-use-uiscrollview-autolayout/","excerpt":"前言誰說你不能讓一些既有的控制項使用一些新技巧，UIScrollView 是從 iOS 一開始就存在的控制項，已經很多部落格文章, Stackflow 問題和官方文件討論如何用舊有的方式在 UIScrollView 中設定你的內容，本文將描述一些搭配 AutoLayout 的使用技巧。","text":"前言誰說你不能讓一些既有的控制項使用一些新技巧，UIScrollView 是從 iOS 一開始就存在的控制項，已經很多部落格文章, Stackflow 問題和官方文件討論如何用舊有的方式在 UIScrollView 中設定你的內容，本文將描述一些搭配 AutoLayout 的使用技巧。 自從 iOS 引入了自動佈局(Auto Layout)，也出現了一些新的方式協助你設定滾動頁面中的內容(Scrolling Content)，使用自動佈局可以大大地減少撰寫的程式碼。依照舊的方式設定 UIScrollView 其中一個最麻煩的地方就是處理 UIScrollView 中內容的尺寸(Content Size)，就是裡面的那些控制項。如果內容是一張圖片你可以相當單純的直接計算圖片的尺寸，不過如果你要放在 UIScrollView 裡面的內容是一堆 UIButton, UILabel, 和你自訂 UIView 就不是這麼容易。你就需要撰寫一大堆程式碼用來處理排列對齊以及適應各種螢幕情況。 在這篇文章中會教你如何使用 UIScrollView 搭配 AutoLayout 自適應設計，如此就不管裝置是直放或橫擺裡面的控制項就能呈現適合的大小，同時也會教你在 UIScrollView 中當虛擬鍵盤出現時控制項通常是 UITextField 如何捲動到適合的位置。 使用 IB (Interface Builder)建立一個基本的 Layout為了讓你對接下來做的事情有點感覺我們先看一下完成後的樣子 現在讓我們來建立我們的 UI ，首先建立一個 Single View Project ，接著在 Main.storyboard 中的 ViewController 拖入一個 UIScrollView 當作主要 ViewController.view 的 subview。 然後加入一些自動佈局的佈局條件(AutoLayout Constraints)讓 UIScrollView 放置到你想要的位置。在這個範例中 UIScrollView 需要佔據整個 UIView 所以這邊加了 4 個邊緣距離設定(Edge)的佈局條件，且距離 4 邊距離都是 0 ，也許你想要的設定跟這裡的不一樣，你可以照著你想要呈現的方式設定。 使用一個 UIView 包住其他的內容或控制項下一步則是在 UIScrollView 中建立一個單獨的 子 UIView 控制項，它的功能就是一個容器(Container)我們會將所有的內容和控制項放到這個 UIView 中。這麼做的原因是之後我們可以很簡單的使用佈局條件(Constraints)實現 AutoLayout，在這個範例中我將它命名為 Content View。如果你的內容是一個 UIImageView 其實你可以很單純的直接放置進 UIScrollView 就跟我們這個 Content View 一樣。 接著，我們要設定 Content View 和 UIScrollView 的佈局條件(Constraints)，官方對 UIScrollView 做了一些改變，如果要支援 Autolayout 你就必須要設定正確，下面是必須完成的兩個條件： Content View 控制項並需要有明確的尺寸大小，指的是你必須設定 width, height 或者使用 placeholder 預先配置一個尺寸接著在執行時期(Run Time)改變尺寸。從另一個角度來看，意思就是你的內容大小無法根據 UIScrollView 來取得尺寸大小，不過它可以根據 UIScrollView 外部的 View 來取得大小，我們將會使用這個技巧來讓你的佈局可以自動適應裝置直立或橫擺。如果你的內容是一張圖片，那麼 UIImageView 會根據你的圖片尺寸取得大小，不過你仍然要設定 Placeholder Constraints 不然 IB 依舊會顯示錯誤訊息給你。 即使 Content View 不能根據 UIScrollView 取得尺寸，但我們還是要設定 Content View 的 Top, Bottom, Leading, Trailing 的佈局條件，這一步是大多數人覺得困惑的地方，因為 Apple 官方已經改變了 Constraints 在這種情況下的用途，現在它可以用來指示 UIScrollView 關於 Content View 的邊界，所以可以拿來計算內容的大小。這些特殊情況的 Constraints 其行為並不像一般的佈局條件，不管你給他們什麼設定，他們不會真的改變 Content View 的尺寸。一旦它們存在 UIScrollView 就能夠計算出 Content View 的尺寸。 這麼說可能有點抽象，讓我們繼續往下走，設定你的 Content View 到 UIScrollView 四個邊界的 Constraints 吧。當你完成這些設定你會注意到 IB 顯示了一些錯誤訊息，因為 UIScrollView 還是沒辦法決定 Content View 的尺寸。 不過你可以先不要理他們。 然後在這個 Content View 放入你需要的其他控制項如 UILabel, UITextField 等照你平常設定 AutoLayout 使用。開啟模擬器會發現垂直的排列稍微正常一點，簡單的說你會發現似乎只有 Top 和 Left 可以往下推算的條件是生效的。註：這裡為了方便辨識 UIScrollView 底色為黃色，Content View 為藍底。 水平方向卻是錯的很離譜，雖然有設定左邊邊界到 UILabel ，UILabel 和 UITextField 的間距以及最後 UITextField 到 Content View 的間距，因為無法確定 UITextField 的尺寸設定，所以看起來整個縮起來，因為不知道右邊和下面的邊長值，所以就算你設定了 Right 或 Bottom 的 Edge 還是無法判斷長度或寬度。我們需要一些方式來設定 UITextField 的 width ，我們可以透過寫死的方式設定，不過這樣就沒辦法讓 UITextField 自動根據橫的或直的螢幕改變寬了。解決的辦法是直接讓佈局條件設定為依據 UIScrollView 外部 ViewController 的那個 view，不過這一個步驟無法靠 IB 完成，我們需要寫一些程式碼，此時 IB 依舊提示錯誤訊息，所以我們需要為 Content View 設定 Placeholder Width 來解掉這個錯誤，多加入一個 width 的 Constrains 然後把 Placeholder 勾起來。 使用 command + option + enter 開啟 Assistant editor 把 Content View 加入 IBOutlet，因為我們要使用程式碼來實作我們剛剛說的方式，讓 Content View 直接參考外面的 view。接著在 viewDidLoad 加入下面程式碼 123456789101112131415@interface DBKViewController ()@property (strong, nonatomic) IBOutlet UIView *contentView;@end@implementation DBKViewController- (void)viewDidLoad&#123; [super viewDidLoad]; NSLayoutConstraint *leftEdgeAlign = [NSLayoutConstraint constraintWithItem:self.contentView attribute:NSLayoutAttributeLeading relatedBy:0 toItem:self.view attribute:NSLayoutAttributeLeft multiplier:1.0 constant:0]; [self.view addConstraint:leftEdgeAlign]; NSLayoutConstraint *rightEdgeAlign = [NSLayoutConstraint constraintWithItem:self.contentView attribute:NSLayoutAttributeTrailing relatedBy:0 toItem:self.view attribute:NSLayoutAttributeTrailing multiplier:1.0 constant:0]; [self.view addConstraint:rightEdgeAlign];&#125;@end 你還是會看到 IB 出現一些警示，所以我們可以透過 IB 的功能來更新一下 storyboard 或者一口氣更新 然後我們就完成了讓控制項自適應的技巧。 把控制項移動到鍵盤上方到了這一步你可以會問有什麼是我曾經被 UIScrollView 困擾的問題，乍看之下好像都完成了，不過當你需要編輯 UITextField 的時候，就會發現你的控制項被虛擬鍵盤擋住了，這也是我們為什麼會需要用 UIScrollView 通常是因為你有太多控制項需要往下延伸，不過鍵盤擋住了我們的輸入框導致在輸入的時候看不到我們輸入了什麼。要解決這個問題，首先我們需要追蹤是哪一個 UITextField 開始進入編輯的狀態，有很多種方式，這邊我們選擇了設定 UITextField 的 delegate 到 ViewController。先在 ViewController 中加上 UITextFieldDelegate 1@interface DBKViewController () &lt;UITextFieldDelegate&gt; 然後 選擇 delegate 接著我們實作一些委派函式好讓正在編輯的 UITextField 可以捲動到鍵盤的上方，我們需要取得正在編輯的控制項參考，所以加入下面的程式碼： 12345678910111213@interface DBKViewController () &lt;UITextFieldDelegate&gt;@property (nonatomic, weak) UITextField *activeTextField;@end- (void)textFieldDidBeginEditing:(UITextField *)textField&#123; self.activeTextField = textField;&#125;- (void)textFieldDidEndEditing:(UITextField *)textField&#123; self.activeTextField = nil;&#125; 接著我們需要註冊關於鍵盤出現的通知(Notifications)。 123456789101112131415161718192021- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self registerForKeyboardNotifications];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [self deregisterFromKeyboardNotifications]; [super viewWillDisappear:animated];&#125;- (void)registerForKeyboardNotifications&#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWasShown:) name:UIKeyboardDidShowNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillBeHidden:) name:UIKeyboardWillHideNotification object:nil];&#125;- (void)deregisterFromKeyboardNotifications&#123; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardDidShowNotification object:nil]; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];&#125; 最後實作當鍵盤出現/消失的函式(selector)和替 UIScrollView 加入一個 IBOutlet 以方便當要捲動時設定，如果你覺得這些程式碼似曾相識因為他們是參考 Apple 官方文件而來的，如果你曾經搜尋過 how to scroll a text field into view 你應該也看過很多類似的程式碼。不過大部份的文章包含 Apple 的教學，當你需要轉動裝置時都會有一個 Bug 那就是他們取到了錯誤的鍵盤尺寸。相關問題可以參考這篇Stackoverflow 第一步我們透過NSNotification物件取得鍵盤的尺寸，接著使用 UIEdgeInsets 去偏移顯示區域，取得鍵盤的高度之後透過計算在呼叫 scrollRectToVisible 去捲動，程式碼如下 1234567891011121314151617181920212223- (void)keyboardWasShown:(NSNotification*)notification&#123; NSDictionary* info = [notification userInfo]; CGRect keyboardRect = [[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue]; keyboardRect = [self.view convertRect:keyboardRect fromView:nil]; UIEdgeInsets contentInsets = UIEdgeInsetsMake(0.0, 0.0, keyboardRect.size.height, 0.0); self.scrollView.contentInset = contentInsets; self.scrollView.scrollIndicatorInsets = contentInsets; CGRect screenRect = self.view.frame; screenRect.size.height -= keyboardRect.size.height; if (!CGRectContainsPoint(screenRect, self.activeTextField.frame.origin) ) &#123; [self.scrollView scrollRectToVisible:self.activeTextField.frame animated:YES]; &#125;&#125;- (void)keyboardWillBeHidden:(NSNotification*)notification&#123; UIEdgeInsets contentInsets = UIEdgeInsetsZero; self.scrollView.contentInset = contentInsets; self.scrollView.scrollIndicatorInsets = contentInsets;&#125; 完整範例 Github其他補充12scrollView.contentInset這個屬性效果等於 CSS 中的 Padding 屬性，設定時使用 UIEdgeInsetsMake(0,0,0,0) 順序為上、左、下、右。 1CGRectContainsPoint(arg1, arg2) 判斷當 arg1(CGRect) 中有 arg2(CGPoint)時回傳 YES 參考資料Using UIScrollView with Auto Layout in iOSUIScrollView 原理详解","categories":[{"name":"Mobile","slug":"Mobile","permalink":"//andyyou.github.io/categories/Mobile/"}],"tags":[{"name":"ios","slug":"ios","permalink":"//andyyou.github.io/tags/ios/"}],"keywords":[{"name":"Mobile","slug":"Mobile","permalink":"//andyyou.github.io/categories/Mobile/"}]},{"title":"關閉OSX通知時 ICON 跳跳跳的動畫","slug":"turn-off-osx-notification-icon-animation-of-jump-jump","date":"2014-08-08T01:08:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/08/08/turn-off-osx-notification-icon-animation-of-jump-jump/","link":"","permalink":"//andyyou.github.io/2014/08/08/turn-off-osx-notification-icon-animation-of-jump-jump/","excerpt":"當你在 Mac 上開啓 Line 的時候，由其實開發時常常因為 Line 收到通知導致那個在 Dock 上的 Icon 一直在那邊彈跳(Dock Bouncing) 想把它關掉必須靠指令","text":"當你在 Mac 上開啓 Line 的時候，由其實開發時常常因為 Line 收到通知導致那個在 Dock 上的 Icon 一直在那邊彈跳(Dock Bouncing) 想把它關掉必須靠指令 關閉12$ defaults write com.apple.dock no-bouncing -bool TRUE$ killall Dock 開啓12$ defaults write com.apple.dock no-bouncing -bool FALSE$ killall Dock","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"osx","slug":"osx","permalink":"//andyyou.github.io/tags/osx/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"11 種類型的程序猿","slug":"11-type-of-code-monkey","date":"2014-08-06T13:49:00.000Z","updated":"2016-10-10T12:16:12.000Z","comments":true,"path":"2014/08/06/11-type-of-code-monkey/","link":"","permalink":"//andyyou.github.io/2014/08/06/11-type-of-code-monkey/","excerpt":"","text":"甘道夫(Gandalf)這種類型的程式設計師看起來就像演員候選名單中負責飾演魔戒-甘道夫的人，他（或者『她』）有著長到快到膝蓋的鬍子，佩戴著一頂看起來有點蠢的帽子，他們可能會在冬天穿著斗篷或披風。對團隊而言幸運的是這個人就跟甘道夫會魔法一樣，他在工作時也像在變魔術一樣強大。不幸的是你們就時常要忍受甘道夫訴說關於他的經歷，像是他是如何上山下海為了把打洞卡送到電腦室。甘道夫類型的程式設計師是你團隊的重砲手，不過你應該該試著讓他們留在後勤部隊，只在必要的時候呼叫他們。 殉道者在其他職業中，『殉道者』只是單純的工作狂，但是在開發這塊領域『殉道者』已經達到另一個境界。工作狂至少還會回家洗澡睡覺。但是殉道者則以睡在桌下那些空的披薩盒堆為榮。問題是沒有人請『殉道者』做到這種境界，而且他們常常會說出類似 “OK！快下班回家吃晚餐吧！我會在今晚做完後面三週的進度” 讓團隊的其他人感到內疚。 宅宅請注意，當他或她和你注意到你時，你蠻有可能就會被迫聽一場長達三個小時的『鋼彈W vs 七龍珠Z』的講座，或者是為什麼 PS3 Xbox 360 哪一個更好之類的分析。宅宅的工作環境充滿了海報，公仔，以及其他週邊，大部分他們喜歡的東西來自日本，宅宅不光是有點難相處，他們有時實在是花太多時間在他們的愛好上包含工作時。 Vince Neil (重金屬音樂歌手)這個40多歲的傢伙就像是 1984 年代所有不良示範(或者很潮?)的集合體，一頭蓬鬆的長髮，故意弄破，皺摺刷白的牛仔褲外加一個印花領巾。Vince 工作的時候都會哼著像是邦喬飛和威豹樂隊的歌。如果Pour Some Sugar on Me不是那麼俱有傳染力的話，這點原本可能沒那麼糟。一般來說跟 Vince 一起工作還挺好玩的，通常他們經驗也很豐富，不過就是童心未泯。不過當他或她想融入搖滾樂風格的生活方式時，事情變的很麻煩。你也不想跟一個每天帶解酒液的人一起上班吧。 忍者忍者型的程式設計師通常是團隊中的 MVP，但卻沒人意識到這件事。就像那些傳說的刺客一樣，你不會知道忍者是何時執行任務的。但你總會在隔天早上開啟版控時發現證據，看到忍者在凌晨4點的時候 check in 了一份程式碼，那是你本來計劃一週完成的任務，你甚至不知道忍者怎麼知道這項任務。你看！當你還沒開完會，忍者就已經在工作了。忍者是非常神秘的，你可能甚至不知道他們的名字，但你知道有他們在每一個專案似乎都可以進行得更順利。雖然行事謹慎不過忍者是一個孤獨的戰士，千萬不要強迫他們和普通員工組隊。 理論家理論家知道一切關於程式設計的知識。他們可以花4個小時演講關於一個冷門語言的歷史或者指出你的 code 哪裡寫得不完美導致浪費了3奈秒。當他們開始寫 code 的時候，他的程式碼非常乾淨優美，導致我們這些凡人很難理解他們的程式碼，他們最愛用像是遞迴這類的技巧，微調每一個區塊的程式碼到極致。不過他們犧牲了時間和程式的可讀性。理論家也是很容易分心的，一個簡單需要1個小時的任務，他們要花3個月，因為他們覺得現有的工具不夠好所以他們必須要自己打要一套新的工具來建置新的函式庫，再用它來打造整個系統以滿足他們的高標準。理論家可能是你最好的隊員之一如果你有辦法控制他們讓他們專注專案本身，而不是浪費時間在研究終極排序演算法上。 牛仔牛仔基本上是不受控制的，他們通常是很厲害的程式設計師，通常工作速度是一般人的 2 到 3 倍，問題是有一半的時間是靠偷工減料得來的，牛仔認為把程式提交到版控很浪費時間，把設定資料存到程式外部也很浪費時間，跟其他人溝通也很浪費時間…你懂了吧。牛仔的程式碼幾乎都是『義大利麵式碼』，因為他們從來不重構。很可能會發生的是; 7 頁的核心功能的程式碼看起來似乎就像教科書教材中『不要這麼做』範例，但這些程式碼卻神奇的能運作。牛仔肯定無法跟其他牛仔一起工作，如果你把兩個牛仔放在一個專案，那這個專案註定失敗，因為他們會互相扯對方後腿。把牛仔放在一個只注重完成期限而不管其他事情的專案是最好的，因為他一定能在期限前完成。牛仔大概就是聒噪版的忍者。只是忍者精確地執行任務，牛仔則是往紅色三角形布一路狂衝的憤怒公牛。 傘兵你知道那些電影中的突擊隊員，就是指揮官帶著那些被空投之後深入敵方陣營且執行秘蜜計劃的人。這些人是軟體開發中的傘兵。傘兵是你最後的手段，為了拯救那些快死的專案，你把他們送到那些專案。傘兵缺乏耐心執行那些長期的任務，但是他們不可思議的強項是快速了解不熟悉的程式包含別人的 API 等，然後快速上手。其他程式設計師也許要數週或數個月去熟悉專案以利有效率的工作。傘兵只需要數小時或幾天。傘兵也許不夠了解核心的程式碼，不過在缺乏時間，全隊可能失敗的情況下他們可能會成功。 庸才 (Mediocre Man)堪用就是你從庸才身上拿到最好的東西，他們總是用較長的時間產生比團隊中其他人更糟的程式。穩扎穩打緩慢地完成專案可以用來形容他們。不過他們總是可以讓專案完成的剛剛好或者堪用，這也讓他們總是能有工作。當你面試這種類型的工程師時，他們可以告訴你很多關於他們曾經參與過的專案，但不是很了解他們實際參與的項目。要知道是不是庸才是相當容易的：詢問他們所做工作的具體內容，他們會突然得到失憶症。 傳教士不管你既有的系統環境是什麼，傳教士堅持他可以改善所有的狀況，但是你要放棄你現有的工具和流程，並且用其他東西取代。傳教士實際上是理論家的相反。傳教士是坦率的，直言不諱，他們知道有關軟體開發的可怕，但是執行專案的數量卻不夠多。傳教士有著一顆專案經理或者部門主管的心，不過他們缺乏經驗或知識來成為管理者。所以在傳教士變成一個單純管理的角色之前，其他人不得不一直忍耐傳教士們想要徹底改革這個工作環境的嘗試。 Googler最後一個但是不在清單中的就是 Googler，他們是那種只要不開瀏覽器搜尋就不能完成專案的類型，因為他們老是忘記基本的語法，或是根本不想記，他們看得懂這些語法主要的目的但是不能記住確切的單字拼法或語法排列。他們通常最少開三個分頁使用不同的關鍵字或排列來搜尋同一件事。舉例來說 第一個 Tab -&gt; Get value of the first array 第二個 Tab -&gt; Get value of the array[] 第三個 Tab -&gt; Array[] get first value 他們是非常機智的不過他們寫程式的速度通常相對慢了一點，因為他們主要的時間都花在搜尋。 原文","categories":[{"name":"Fun","slug":"Fun","permalink":"//andyyou.github.io/categories/Fun/"}],"tags":[],"keywords":[{"name":"Fun","slug":"Fun","permalink":"//andyyou.github.io/categories/Fun/"}]},{"title":"iOS App Store 上架憑證流程筆記","slug":"ios-app-shelves-certificate-process-notes","date":"2014-08-06T07:01:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/08/06/ios-app-shelves-certificate-process-notes/","link":"","permalink":"//andyyou.github.io/2014/08/06/ios-app-shelves-certificate-process-notes/","excerpt":"在開發幾個 App 之後對於上架簽署憑證之間的關係一直沒有搞的很清楚，所以做了一下筆記。 當 APP 開發完成之後要安裝到實機會需要在建置應用程式時(build)加上憑證，我們一般稱為應用程式憑證簽署(code signing)，白話文就是替應用程式綁上名牌以確保這個 APP 是合法的。","text":"在開發幾個 App 之後對於上架簽署憑證之間的關係一直沒有搞的很清楚，所以做了一下筆記。 當 APP 開發完成之後要安裝到實機會需要在建置應用程式時(build)加上憑證，我們一般稱為應用程式憑證簽署(code signing)，白話文就是替應用程式綁上名牌以確保這個 APP 是合法的。 總結來說要完成一個可以上架的 APP 需要完成下面這些步驟： 在Mac上產生憑證密鑰 .certSigningRequest 是拿第一步所產生的密鑰到 apple developer 網站來產生密鑰憑證檔案 .cer 將第二步的 .cer 裝到鑰匙圈中。 回到 apple developer 申請產生iOS的憑證檔 provisioning profile。 將裝置憑證檔案 provisioning profile 安裝到 xcode 。 概念說明本文不是要做流程記錄如果想學習整個流程可以參考教學這篇文章是想針對各種憑證做些概念上的筆記其實當你到 Apple Developer 的 Certificates, Identifiers &amp; Profiles 界面時你可以觀察到全部大概就是下列這些東西 Certificates Identifiers Devices Provisioning Profiles 我們先用 Development APP 建置的流程來概略說明一下關係，當你想要申請一張 Certificates 除了先購買開發者帳號外，第一步就是要先在鑰匙圈管理程式中產生Certificate Signing Request (CSR) 檔案，實際上他就是一對公私鑰。接著在製作 Certificates 的時候 Apple 會跟你要這個 CSR ，最後完成這張憑證，下載回來後點擊就可以安裝。 當你完成上敘動作，此時 Xcode 就可以把 APP 安裝到裝置上了。當你連接裝置由於你已經有憑證了，Xcode 會自動幫你產生一個通用的 App ID (Xcode iOS Wildcard App ID)，幫你把裝置的 UDID 上傳到網站上，合成一個開發用的 Provisioning Profile (iOS Team Provisioning Profile) 並在安裝到裝置上，接著 APP 就可以部署到裝置上了。 看完流程你就可以歸納出整個流程是這樣的 Apple 跟你要了一組 CSR 來識別身份順便幫你產了一組 Certificates 驗明你這個開發者。 Identifiers 就像在註冊網址一樣，替 APP 產一組唯一的識別名稱，Apple 可以透過這個 ID 授權開放一些功能給這個 APP。 Devices 就是可用的裝置清單。 最後你需要合出一個 Provisioning Profile 在你的 Build Settings 設定這張 Profile. 而這張 Profile 就是把上述的那些資訊全部整合在一起的一個檔案。最終會被打包進 ipa 中。 如果是測試用的 APP 或使用 Testflight 你會需要再把這個 Profiile 安裝到機器上。 我們可以合理的猜想第 5 步驟應該是 Apple 需要判斷這個安裝程式誰可以安裝，如果是在 App Store 上的 App 你需要登入 Apple ID 然後系統就可以註記這個 APP 現在歸屬于誰或者說誰可以安裝，這可以說明當你在一台裝置使用不同帳號安裝軟體後，當 User A 安裝了某軟體X，接著 User B 使用了自己的帳號，當某軟體X出更新的時候，彈出來的帳號預設是 User A 因為 Apple 知道這個應用程式是屬於誰的。但 Development 的 APP 並沒有，所以需要在機器本身再安裝一個 Profile 來判斷誰能夠安裝。您可以在 iPhone 的 設定 &gt; 一般 &gt; 描述檔中觀察到這些 Profile. CertificateCertificate 憑證簡單說就是一個身份的證明，證明你是一個 Apple 開發者，然後才可以把 APP 安裝到機器上，當你對 APPLE 購買了開發者之後就可以取得，共分成兩大類 Development 和 Production Development 認證可以讓你部署 APP 到裝置上(上限100台)做測試，而 Product 則是用來發佈到 App Store。 Development Certificate iOS App Development簽署測試用的APP以安裝在實機上。 Apple Push Notification service SSL (Sandbox)當你的APP需要使用到Apple Push Notification功能時需要使用此種憑證，開啟沙箱功能。 ProductionProduction 憑證又分成5種各針對不同需求的 APP App Store and Ad Hoc 使用於提交到 App Store 或特殊用途的簽證如：TestFlight。 Apple Push Notification service SSL (Production) 當提交的應用程式需要使用 Apple Push Notification 功能的時候。 Pass Type ID Certificate 當APP需要更新Passbook資料的時候 Website Push ID Certificate VOIP Services Certificate 1Ad hoc是拉丁文常用短語中的一個短語。這個短語的意思是「特設的、特定目的的（地）、即席的、臨時的、將就的、專案的」。這個短語通常用來形容一些特殊的、不能用於其它方面的的，為一個特定的問題、任務而專門設定的解決方案。這個詞彙須與a priori區分。 App IDsApp ID 就是 APP 唯一的識別名稱，App ID 應該和 Xcode 中的 Bundle ID 一樣。App ID 分成兩種 Explicit App ID：唯一的 App ID，用來針對單一 APP 命名，例如 com.apple.MyApp。 Wildcard App ID：類似使用正規式匹配符號的概念，指的是某些符合命名的 APP。例如 * 可表示所有 APP，com.apple.* 指的是開頭是 com.apple 的 APP。 App ID 可以設定相關 APP Services授權。例如，如果要使用 Apple Push Notification Services，則必須使用 Explicit App ID，以方便能識別唯一的應用程式。 Provisioning Profile簡單說 Provisioning Profile 就是包含 App ID, Certificates, Devices 列表資訊的一個檔案。其用途就是用來確認這個 APP 是否合法，首先就是我們會需要 Certificate 來證明開發者是誰，然後 App ID 用來設定該 App 的授權的其他功能並驗證 Bundle ID 是否唯一。再來就是在測試的時候確定裝置是否能安裝。所有這個 Profile 可以說是用來規範驗證這個 App 的檔案。 了解觀念之後就不需要死記簽證的流程了。","categories":[{"name":"Mobile","slug":"Mobile","permalink":"//andyyou.github.io/categories/Mobile/"}],"tags":[{"name":"ios","slug":"ios","permalink":"//andyyou.github.io/tags/ios/"}],"keywords":[{"name":"Mobile","slug":"Mobile","permalink":"//andyyou.github.io/categories/Mobile/"}]},{"title":"How to get plist?","slug":"ios-how-to-get-plist","date":"2014-08-04T01:22:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/08/04/ios-how-to-get-plist/","link":"","permalink":"//andyyou.github.io/2014/08/04/ios-how-to-get-plist/","excerpt":"","text":"12NSString *path = [[NSBundle mainBundle] pathForResource:@\"YOUR_PLIST_FILE\" ofType:@\"plist\"];NSDictionary *dictionary = [[NSDictionary alloc] initWithContentsOfFile:path];","categories":[{"name":"Mobile","slug":"Mobile","permalink":"//andyyou.github.io/categories/Mobile/"}],"tags":[{"name":"ios","slug":"ios","permalink":"//andyyou.github.io/tags/ios/"}],"keywords":[{"name":"Mobile","slug":"Mobile","permalink":"//andyyou.github.io/categories/Mobile/"}]},{"title":"React 關於 Refs ","slug":"reactjs-regarding-the-refs","date":"2014-02-19T13:56:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/19/reactjs-regarding-the-refs/","link":"","permalink":"//andyyou.github.io/2014/02/19/reactjs-regarding-the-refs/","excerpt":"關於 Refs當你透過 render() 回傳你的 UI 結構之後，你可能想要從外部調用這個元件實例的方法。通常情況下為了取得一些元件或計算後資料你可能這樣做，但其實是不必要的，因為 React 通常會確保資料是最新的 props 且透過 render() 傳遞到子元件。不過的確有些情況還是會需要從外部調用方法。想像下面這種狀況，當你想讓一個已存在的某元件的子元件 &lt;input /&gt; 在你清空欄位後馬上 focus 該 &lt;input /&gt;：","text":"關於 Refs當你透過 render() 回傳你的 UI 結構之後，你可能想要從外部調用這個元件實例的方法。通常情況下為了取得一些元件或計算後資料你可能這樣做，但其實是不必要的，因為 React 通常會確保資料是最新的 props 且透過 render() 傳遞到子元件。不過的確有些情況還是會需要從外部調用方法。想像下面這種狀況，當你想讓一個已存在的某元件的子元件 &lt;input /&gt; 在你清空欄位後馬上 focus 該 &lt;input /&gt;： 1234567891011121314151617181920212223242526272829var App = React.createClass(&#123; getInitialState: function() &#123; return &#123;userInput: ''&#125;; &#125;, handleKeyUp: function(e) &#123; this.setState(&#123;userInput: this.getDOMNode().value&#125;); // this.setState(&#123;userInput: e.target.value&#125;); # 官方範例使用 e.target.value 會導致無法正常運作。 &#125;, clearAndFocusInput: function() &#123; this.setState(&#123;userInput: ''&#125;); // Clear the input // 我們希望在這邊可以 focus &lt;input /&gt; &#125;, render: function() &#123; return ( &lt;div&gt; &lt;div onClick=&#123;this.clearAndFocusInput&#125;&gt; Click To Focus and Reset &lt;/div&gt; &lt;input ref=\"theInput\" value=&#123;this.state.userInput&#125; onKeyUp=&#123;this.handleKeyUp&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);React.renderComponent(&lt;App /&gt;, document.getElementById('example')); 請注意，在這個範例我們想要通知 &lt;input /&gt; 做些事情。這件事件沒辦法透過 props 辦到。我們想要讓 &lt;input /&gt; focus ，然而這邊遇到了一點問題，那就是 render() 回傳的不是子元素 &lt;input /&gt; 的元件，在這個時候它只是一子元件的結構描述。記得當你從 render() 回傳一個結構，它並不包含替你產生子元素的物件實例。關於在內部的標簽(內部的元件)，它們都只是結構描述。不過你可能已經想到把 &lt;input /&gt; 先存在變數裡了，注意！！你不應該把『這些事情或物件』存起來，然後期待這可能有一天會用到。如下 1234567891011// 錯誤範例: DO NOT DO THIS!render: function() &#123; var myInput = &lt;input /&gt;; // 我可能會呼叫這個物件的 Method this.rememberThisInput = myInput; // 在未來某個時間點我就可以直接呼叫他 return ( &lt;div&gt; &lt;div&gt;...&lt;/div&gt; &#123;myInput&#125; &lt;/div&gt; );&#125; 在這個錯誤範例中，&lt;input /&gt; 只是描述結構。這個描述是用來建立 &lt;input /&gt; 背後的實際物件。如果我們把這段程式完成如下並試著觀察這段程式碼的運作，事實上當你呼叫 this.rememberThisInput 是會出 ERROR 的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script src=\"http://fb.me/react-0.8.0.js\"&gt;&lt;/script&gt; &lt;script src=\"http://fb.me/JSXTransformer-0.8.0.js\"&gt;&lt;/script&gt; &lt;script src=\"http://code.jquery.com/jquery-1.10.0.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;div&gt; 原生 Javascript 範例示範 focus 所以我們可以透過 element.focus() 讓元素 focus。 &lt;div id='test-trigger'&gt;Click!&lt;/div&gt; &lt;input type='text' id='test' /&gt; &lt;/div&gt; &lt;script&gt; /* 原生 Javascript 範例示範 focus */ var HandleClick = function (e) &#123; var el = document.getElementById('test'); el.focus(); &#125;; var el = document.getElementById('test-trigger'); if (el.addEventListener) &#123; el.addEventListener('click', HandleClick, false); &#125; else &#123; el.attachEvent('onclick', HandleClick); &#125; &lt;/script&gt; &lt;script type=\"text/jsx\"&gt; /** @jsx React.DOM */ var App = React.createClass(&#123; getInitialState: function () &#123; return &#123;userInput: ''&#125; &#125;, handleKeyUp: function (e) &#123; this.setState(&#123;userInput: this.getDOMNode().value&#125;); &#125;, clearAndFocusInput: function () &#123; this.setState(&#123;userInput: ''&#125;); // console.log(this.rememberThisInput); // this.rememberThisInput.focus(); &#125;, render: function () &#123; var myInput = &lt;input value=&#123;this.state.userInput&#125; onKeyUp=&#123;this.handleKeyUp&#125; /&gt; this.rememberThisInput = myInput; return ( &lt;div&gt; &lt;div onClick=&#123;this.clearAndFocusInput&#125; &gt;Click to Focus and Reset&lt;/div&gt; &#123;myInput&#125; &lt;/div&gt; ); &#125; &#125;); React.renderComponent(&lt;App /&gt;, document.getElementById('example')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 那我們怎麼通知 &lt;input /&gt; 背後的這個物件呢？ ref 屬性(attribute)React 支援一個非常特別的屬性，你可以把它附加到任何在 render() 裡面的元件上(就是標簽 tag 上)。這個特殊的屬性可以讓你存取到對應的『背後的實際物件』，它保證可以在任何時間點存取到當下的物件。下面是一個範例： 1 在 render() 裡將回傳任意的元素設定 ref 屬性(attribute)1&lt;input ref='myInput' /&gt; 2 在程式碼(典型的範例是在處理事件或函式裡)中你就可以透過 this.refs 存取這個『背後的物件』。1this.refs.myInput 完整的範例12345678910111213141516171819202122232425262728/** @jsx React.DOM */var App = React.createClass(&#123; getInitialState: function () &#123; return &#123;userInput: ''&#125;; &#125;, handleKeyUp: function (e) &#123; this.setState(&#123;userInput: this.getDOMNode().value&#125;); console.log(e); // 官方範例使用的 e.target.value 是錯誤的！ &#125;, clearAndFocusInput: function (e) &#123; this.setState(&#123;userInput: ''&#125;); this.refs.theInput.getDOMNode().focus(); &#125;, render: function () &#123; return ( &lt;div&gt; &lt;div onClick=&#123;this.clearAndFocusInput&#125;&gt; Click To Focus and Rest &lt;/div&gt; &lt;input ref='theInput' value=&#123;this.state.userInput&#125; onKeyUp=&#123;this.handleKeyUp&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);React.renderComponent(&lt;App /&gt;, document.getElementById('example')); 在這個範例裡，render() 方法裡回傳的結構中包含了一個 &lt;input /&gt; 的結構描述，不過這次不同的是這個物件可以透過 this.refs.theInput 取得。然後在 clearAndFocusInput 函式裡使用 this.refs.theInput 。 總結比起使用 this.props 和 this.state ，this.refs是操作物件或傳送訊息給特定子元素最方便的方式，但是建議不要透過他們去操作你的資料。一般來說被動處理計算的資料應該使用 this.props 和 this.state。 Refs 的用途 可以定義任何 public 的 method 在你的元件類別裡(例如 reset 方法)，然後透過 refs 去呼叫。 在你需要呼叫 DOM 的 API 時取得該元素。this.refs.myInput.getDOMNode()。 Refs 會自動記錄，如果你的子元素被破壞這個 refs 也會被破壞。不用擔心記憶體的問題，除非你做了一些瘋狂的事情，像是把整個物件都加入參考。 注意事項 不要在 render() 方法裡面使用 this.refs 或者當任何元件的 render() 正在運行的時候。 如果你想要使用 Google Closure Compiler (Javascript minify) ，請檢查不要用任何指定屬性屬性的方式使用 refs，這意味著當你設定了一個 ref=&#39;myRefstring&#39;那麼你最好使用 this.refs[&#39;myRefString&#39;] 這種方式。 如果你是第一次用 React 開發，通常你會傾向讓 this.refs 去幫你達到你要的功能，如果遇到這種情形，請審慎思考關鍵在哪，該如何設計階層結構，該 state 管理控制哪些資料。通常把state放置在元件最高階層，控制好關於『自己』的狀態會讓程式碼變得乾淨，清晰易懂。良好的設計 state 會導致你不會一直去使用 this.refs 強迫控制元件，且會讓資料易於控制和正確。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 元件運作與生命週期","slug":"reactjs-assembly-operation-and-life-cycle","date":"2014-02-16T15:15:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/16/reactjs-assembly-operation-and-life-cycle/","link":"","permalink":"//andyyou.github.io/2014/02/16/reactjs-assembly-operation-and-life-cycle/","excerpt":"與瀏覽器之間的運作React 針對瀏覽器提供了十分強大的抽象化概念，讓你在大部份的情況下不必再直接操作 DOM ，不過有些時候或許還是需要單純的存取底層的 API(DOM API)，可能是使用第三方函式庫或者事已經寫好的程式碼。","text":"與瀏覽器之間的運作React 針對瀏覽器提供了十分強大的抽象化概念，讓你在大部份的情況下不必再直接操作 DOM ，不過有些時候或許還是需要單純的存取底層的 API(DOM API)，可能是使用第三方函式庫或者事已經寫好的程式碼。 關於虛擬 DOMReact 快速的原因是因為它從來不直接影響 DOM。React 會負責在記憶體中持續維護一份 DOM 的表現結構。render() 方法負責回傳關於 DOM 的描速，React 就能得知其和記憶體中結構的差異，接著他會計算出最快的更新方式然後交給瀏覽器去影響 DOM。此外，React 完整實作了對應的事件系統，所有物件的事件保證符合 W3C 的規範，且關於事件氣泡傳遞(bubbles)的行為在任何瀏覽器也都一致。甚至可以在 IE8 使用 HTML5 的事件。大多數的時候你的程式操作應該都會 React 所建構的”仿瀏覽器”的世界裡，因為它俱有高效能和相對容易使用。不過有些情況下，你可能會需要存取使用底層基本的 API，例如使用 jQuery 第三方套件，React 提供了一個後門允許你可以直接操作底層的 API。 Refs 和 getDOMNode()為了與瀏覽器互動，你需要使用指向 DOM 節點的參考物件。每一個 Mounted 的 React 元件都會有 getDOMNode() 的功能 ，你可以透過呼叫它取得該 DOM 的參考物件。 注意：getDOMNode() 只能在元件已經掛載完畢時使用(換句話說這表示該物件已經被渲染放置到 DOM 裡了)。如果你嘗試在元件尚未掛載完畢前呼叫這個 API 將會發生例外。 為了取得 React 元件的參考，你可以使用 this 取得目前元件或者使用 refs，使用 refs 則需要設定一個名稱，如下範例： 1234567891011121314151617181920212223242526/** @jsx React.DOM */var MyComponent = React.createClass(&#123; handleClick: function() &#123; // 透過原生 API 明確的指示 input 為 focus 狀態。 this.refs.myTextInput.getDOMNode().focus(); &#125;, render: function() &#123; // ref 屬性替元件增加一個參考然後你就可以在元件掛載完畢後使用 `this.refs` return ( &lt;div&gt; &lt;input type=\"text\" ref=\"myTextInput\" /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);React.renderComponent( &lt;MyComponent /&gt;, document.getElementById('example')); 更多關於 Refs想要了解更多關於 refs 及如何有效的使用可以參考 refs 文件 元件的生命週期元件的生命週期有三個主要的部分： Mounting：元件正準備要被寫入 DOM Updating：元件偵測到狀態的改變準備重新渲染。 Unmounting：元件正要被從 DOM 中移除。 React 根據生命週期提供了對應的方法(事件)讓你可以在對應的階段做一些處理。Will 的方法用在某些狀況準備發生之前，Did 的方法則表示該狀況已經發生後。 Mounting 掛載流程 getInitialState()：當物件被調用時此方法會在寫入 DOM 之前被觸發，通常用來管理狀態的元件可以用這個方法初始化一些資料。 componentWillMount：當元件內部的結構處理完畢準備寫入 DOM 之前觸發。 componentDidMount(DOMElement rootNode)：當元件被寫入 DOM 之後觸發。當初始化需要操作 DOM 元素就可以用這個方法。 Updating 更新流程 componentWillReceiveProps(nextProps)：已掛載的元件收到新的 props 時被觸發。在這個方法裡你通常會去比較 this.props 和 nextProps 然後再用 this.setState 去改變狀態。 shouldComponentUpdate(nextProps, nextState)：這個函式需要回傳一個布林值，當元件判斷是否需要更新 DOM 時會被觸發。你可以在這個方法裡面去比較 this.props，this.state，nextProps，nextState 來決定是否需要更新，回傳 false 則會跳過此次觸發不更新，如果你什麼都不回傳預設會當做 false 。 componentWillUpdate：例如在上面 shouldComponentUpdate 你回傳了 true ，元件確定要更新了，在準備更新前這個方法會被觸發。 componentDidupdate(prevProps, prevState, rootNode)：更新後觸發。 Unmounting 卸載流程 componentWillUnmount()：當元件準備要被移除或破壞時觸發。 掛載後才能使用的方法 getDOMNode()：使用此方法會傳回一個 DOM 元素物件，透過這個方法你可以取得一個參考物件直接操作 DOM 節點。 forceUpdate()：任何已掛載的元件，當你知道元件內部有些狀態已經改變但他不是透過 this.setState() 去修改值的時候可以呼叫這個方法強迫更新。 注意：componentDidMount() 和 componentDidUpdate() 的 rootNode 參數只是提供你一個比較方便的方式存取 DOM ，這和使用 this.getDOMNode() 是一樣的。補上一段實作各種方法的範例您可以試著把註解的地方取消看看變化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** @jsx React.DOM */var Test = React.createClass(&#123; getInitialState: function () &#123; console.log(\"&gt; getInitialState()\"); return &#123;user: 'AndyYou'&#125;; &#125;, componentWillMount: function () &#123; console.log(\"&gt; componentWillMount()\"); &#125;, componentDidMount: function (node) &#123; console.log(\"&gt; componentDidMount(node)\"); console.log(node.className); console.log(node.value); console.log(node.id); console.log(this.getDOMNode().className); console.log(this.getDOMNode().value); console.log(this.getDOMNode().id); &#125;, componentWillReceiveProps: function (nextProps) &#123; console.log(\"&gt; componentWillReceiveProps(nextProps)\"); console.log(nextProps); &#125;, handleChange: function (e) &#123; console.log(e.target.value); this.setState(&#123;user: e.target.value&#125;); &#125;, shouldComponentUpdate: function (nextProps, nextState) &#123; console.log(\"&gt; shouldComponentUpdate(nextProps, nextState)\"); console.log(\"nextProps: \"); console.log(nextProps); console.log(\"nextState: \"); console.log(nextState); return true; /* need return true/false */ &#125;, componentWillUpdate: function (nextProps, nextState) &#123; console.log(\"&gt; componentWillUpdate(nextProps, nextState)\"); &#125;, componentWillUnmount: function () &#123; console.log(\"&gt; componentWillUnmount()\"); &#125;, render: function () &#123; return ( &lt;input type='text' id='foobar' value=&#123;this.state.user&#125; className='nav' onChange=&#123;this.handleChange&#125; /&gt; ); &#125;&#125;);var test = React.renderComponent(&lt;Test title='Untitled' /&gt;, document.getElementById('example'));// test.setProps(&#123;title: 'No'&#125;);// React.unmountComponentAtNode(document.getElementById('example'));// test.setState(&#123;user:'Calvert'&#125;); 支援的瀏覽器和兼容在 Facebook 我們支援了包含 IE8 在內的舊瀏覽器，我們已經落實瀏覽器兼容很長一段時間了，這讓我們可以實作出有實用且遠見的 Javascript。這表示我們並沒有太多 Hack 特定瀏覽器產生鬆散的分支代碼，根據這些經驗我們可以確信我們的程式碼在任何瀏覽器都是可以正常運作的。舉個例子常見 +new Date() 這種寫法我們會改用 Date.now()。React Open Source 專案和 Facebook 內部使用的的是一樣的，我們已經證實並正在使用。此外我們並不試圖讓實作兼容功能變成函式庫的一部份，如果每個函式庫都重新實作這些功能，為了支援老舊瀏覽器，你會反覆載入相同功能的程式碼。如果你需要支援舊的瀏覽器，可能你已經在使用 es5-shim。 兼容es5-shim.js 可以從 kriskowal’s es5-shim 取得。下面是 React 支援老舊瀏覽器需要的東西 Array.isArray Array.prototype.forEach Array.prototype.indexOf Array.prototype.some Date.now Function.prototype.bind es5-sham.js 也可以從 kriskowal’s es5-shim 取得，React 需要： Object.create React 的非最小化建置則需要 paulmillr’s console-polyfill console.l* 跨瀏覽器的議題雖然 React 對於瀏覽器的抽象化過程處理的非常不錯，但是有些瀏覽器的限制或怪異的行為我們還是找不到解法 IE8 的 onScroll 事件IE8 的 onScroll 事件不會造成事件的氣泡傳遞而且 IE8 也沒有定義對應的處理事件。目前關於在 IE8 的這個事件已經被忽略了。 PolyfillsPolyfilling 是由 RemySharp 所提出的術語，它是用來描速關於複製缺少的 API 和 API 功能的行為。你可以使用它撰寫應用程式的程式碼而不用擔心其他瀏覽器是不是支援。事實上，polyfills 並不是新技術也不是和 HTML5 捆绑到一起的。 Polyfills 是什麼？讓我們直接來看實務 Polyfills 指的是什麼。例如使用 json2.js 就是一種 Polyfills。123if (typeof JSON.parse !=='function') &#123; // Crockford’s JavaScript implementation of JSON.parse&#125; 上面這段程式碼表示; 如果瀏覽器本身可以執行 JSON.parse，那麼 json2.js 就不會重新定義或者干擾 JSON 物件。如果沒有原生的 API 可用，json2.js 就會執行一段 JavaScript 來實現這個功能，它和原生的 JSON API 是完全兼容的。最終的結果就是你可以在網頁上使用 json2.js 而不用考慮瀏覽器執行的是哪種程式碼。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 關於表單","slug":"react-on-a-form","date":"2014-02-14T17:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/15/react-on-a-form/","link":"","permalink":"//andyyou.github.io/2014/02/15/react-on-a-form/","excerpt":"表單表單元件像是 &lt;input&gt;，&lt;textarea&gt;和&lt;option&gt;和其他元件有些不同，因為他們可以被使用者操作而產生變化。這些元件提供一個介面好讓我們以表單的形式和使用者產生互動。","text":"表單表單元件像是 &lt;input&gt;，&lt;textarea&gt;和&lt;option&gt;和其他元件有些不同，因為他們可以被使用者操作而產生變化。這些元件提供一個介面好讓我們以表單的形式和使用者產生互動。 Props 的輸入與輸出表單元件提供一些 props 會根據使用者的操作影響屬性值和呈現。 value ： &lt;input&gt; &lt;textarea&gt; 支援。 checked ： checkbox，radio 支援。 selected：&lt;option&gt; 支援。 在 HTML 裡面 &lt;textarea&gt; 的 value 是嵌在子元素就是像這樣 &lt;textarea&gt;value here&lt;/textarea&gt;，但是在 React 你可以用 value 取代。表單元件透過 onChange 設定 callback 可以達到監聽的功能，就是一旦這些值改變了就會觸發 onChange。onChange 會在使用者有以下狀況時被觸發： &lt;input&gt; 或 &lt;textarea&gt; 的 value 改變時。 checked 改變時。 selected 改變時。 就像所有的 DOM 事件，onChange 支持所有原生元件且可以監聽到因氣泡傳遞產生的觸發。 元件約束一個 &lt;input&gt; 一旦設定了 value 就是一個約束的元件。輸出後元素 &lt;input&gt; 的值將會永遠映射到 this.props.value 舉例來說 123456789/** @jsx React.DOM */var Test = React.createClass(&#123; render: function () &#123; return ( &lt;input type='text' value='Hello!' /&gt; ); &#125;&#125;);React.renderComponent(&lt;Test /&gt;, document.getElementById('example')); value 一旦設定，你會發現不能改變了，像上面範例 value 永遠等於 Hello! 。任何輸入都無法改變值，因為 React 已經定義 value 是 Hello!，如果你想要讓 &lt;input&gt; 可以被使用者操作你應該使用 onChange 事件： 123456789101112131415/** @jsx React.DOM */var Test = React.createClass(&#123; getInitialState: function () &#123; return &#123;value: 'Hello!'&#125; &#125;, handleChange: function (event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125;, render: function () &#123; // var value = this.state.value; return ( &lt;input type='text' value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; ); &#125;&#125;); 讓我們整理一下你在目前學習過程可能會產生的疑惑，就是 props 和 state 的差異，首先是 props 不應該由元件本身去操作異動，應該只能夠在使用元件的時候當作帶入的參數(雖然的確是可以使用 setProps() 去設定，不過這違反官方的設計模式)。接著的工作就是負責傳遞資料。而 this.state 可以當作參數傳遞資料也可以在元件內部去設置改變。換句話說，你應該只能在元件內部呼叫 setState() ，常見的應用都是用 this.state 處理關於使用者操作互動產生的結果。此外要注意的是如果你真的在子元件也使用了 state 那它跟主元件本身的狀態是分開獨立的。另一個問題是為什麼 props 可以用 propTypes 驗證，而 state 沒有，主要是因為關於 state 完全是由元件設計者控制的，想像一下一般的情況下你設計了一個元件，而當其他人要使用的時候他應該只需要使用 React.renderComponent(&lt;YourComponent /&gt;, document.getElementById(&#39;example&#39;)) 輸出元件即可，根據你提供的文件，它可以在屬性設定自己的參數 &lt;YourComponent name=&quot;Andy&quot; /&gt; ，而 this.state 根本沒機會外露(修改元件除外)。所以如果你真的需要驗證 state 的時候就在適合的生命週期事件中處理就好了，例如 componentWillUpdate 事件。根據上面這些說明，我們得到結論：就是一旦 &lt;input&gt; 的 value 被綁定就不會變動了，我們稱為元件約束，所以應該在 value 綁入一個變數，而這個變數按照模式的規劃應該使用 this.state 取得值是比較正確的。 123handleChange: function(event) &#123; this.setState(&#123;value: event.target.value.substr(0, 140)&#125;); &#125; 修改 handleChange() 範例就可以實作限制在 140 個字元。 不被約束的元件如果一個 &lt;input&gt; 沒有設定 value 那它就是一個不被約束的元件。此時 input 的 value 就會是使用者輸入的值。 123render: function() &#123; return &lt;input type=\"text\" /&gt;;&#125; 上面這段程式碼並沒有設定 value ，使用者輸入的任何值都會立刻反應。想要在使用者改變欄位值的同時做些處理可以使用 onChange 。如果你想在初始化的時候不要帶入空值，且可以隨著使用者操作回饋，你可以使用 defaultValue。 123render: function() &#123; return &lt;input type=\"text\" defaultValue=\"Hello!\" /&gt;;&#125; 其他類似的屬性像是&lt;input&gt; 還有 defaultChecked，&lt;select&gt; 也有 defaultValue 。 進階議題為什麼要約束元件？React 在設計像是 &lt;input&gt; 這類表單元件時面臨一個表現時的挑戰。舉例來說在 HTML 1&lt;input type=\"text\" name=\"title\" value=\"Untitled\" /&gt; 在傳統 HTML 是表示初始化值設定為 Untitled 當使用者更新欄位時，元素取得的屬性將會改變，然而如果你使用 node.getAttribute(&#39;value&#39;) 其實他還是會返回 Untitled。讓我們直接看下面這段原始碼 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script&gt; var val1, val2; function Log () &#123; console.log(this); console.log(this.getAttribute('value')); console.log(document.getElementsByName(this.name)[0].value); console.log(this.value); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type='text' name='i1' value='Untitled' onchange=\"Log.apply(this)\" /&gt; &lt;/body&gt;&lt;/html&gt; 試著輸入值觀察 console 。注意：HTML 的 onchange 行為是在你改變了值，滑鼠移出欄位之時才觸發。 React 是透過 &lt;input value=&#39; &#39;/&gt; 的 value 影響元素，但是當我們改變欄位的時候卻只能從 node.value 而不是 node.getAttribute(&#39;value&#39;) 取得使用者改變的資料，所以如果要把這個值表現在元素上就只能把這個 node.value 放到 state 變數，然後屬性就使用 this.state.value。這也就是為什麼需要約束元件。也因此當我們如下程式碼的時候 123render: function() &#123; return &lt;input type=\"text\" name=\"title\" value=\"Untitled\" /&gt;;&#125; 因為我們接不到 event.target.value 所以 React 會一直保持 Untitled。 關於 Textarea在 HTML一般設定 &lt;textarea&gt; 是用子元素去設定 1&lt;textarea name=\"description\"&gt;This is the description.&lt;/textarea&gt; 開發者可以很輕易的使用多行的內容，但因為 React 是 Javascript 所以當你想要換行的時候可以使用 \\n。 先看下面這段程式碼 123456789/** @jsx React.DOM */var Textarea = React.createClass(&#123; render: function () &#123; return ( &lt;textarea value='value' defaultValue='default'&gt;This is dog&lt;/textarea&gt; ); &#125;&#125;);React.renderComponent(&lt;Textarea /&gt;, document.getElementById('example')); 其實我們這三個設定都可以用，但是子元素會等於 defaultValue 所以當子元素和 defaultValue 都用的時候會產生錯誤 If you supplydefaultValueon a &lt;textarea&gt;, do not pass children. 而 value 會覆寫 defaultValue 。為了避免混淆我們一般建議只用 value，接下來的用法就和上面提到的一樣。 關於 Select一般我們使用 &lt;select&gt; 要指定選項是透過在 &lt;option selcted&gt;，在 React 為了讓元件方便操作我們改用下面的方式 12345678910111213/** @jsx React.DOM */var Dropdown = React.createClass(&#123; render: function () &#123; return ( &lt;select value=&#123;this.props.selected&#125;&gt; &lt;option value=\"A\"&gt;Apple&lt;/option&gt; &lt;option value=\"B\"&gt;Banana&lt;/option&gt; &lt;option value=\"C\"&gt;Cranberry&lt;/option&gt; &lt;/select&gt; ); &#125;&#125;);React.renderComponent(&lt;Dropdown selected='C' /&gt;, document.getElementById('example')); 如果要是預設值也是用 defaultValue 如下 12345678910111213/** @jsx React.DOM */var Dropdown = React.createClass(&#123; render: function () &#123; return ( &lt;select value=&#123;this.props.selected&#125; defaultValue=\"B\"&gt; &lt;option value=\"A\"&gt;Apple&lt;/option&gt; &lt;option value=\"B\"&gt;Banana&lt;/option&gt; &lt;option value=\"C\"&gt;Cranberry&lt;/option&gt; &lt;/select&gt; ); &#125;&#125;);React.renderComponent(&lt;Dropdown /&gt;, document.getElementById('example'));","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 重複利用元件","slug":"reuse-components","date":"2014-02-12T15:58:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/12/reuse-components/","link":"","permalink":"//andyyou.github.io/2014/02/12/reuse-components/","excerpt":"重複利用元件這裡的設計界面，指的是打破現有的設計元素(button, form, fields 等)組合出定義良好可重複使用的元件。這樣一來下次你需要建置一樣的界面的時候就可以少寫一些程式碼，同時也節省許多開發時間。","text":"重複利用元件這裡的設計界面，指的是打破現有的設計元素(button, form, fields 等)組合出定義良好可重複使用的元件。這樣一來下次你需要建置一樣的界面的時候就可以少寫一些程式碼，同時也節省許多開發時間。 Prop 驗證當你的應用程式不斷增加，透過設定 propTypes 有助你確保你的元件被正確的使用。。React.PropTypes 會產生一系列的驗證使得你可以確保收到的資料是正確的。當 prop 提供一個無效的資料時就會發出一個錯誤的例外。讓我們看看下面的使用範例： 1234567891011121314151617181920212223242526272829React.createClass(&#123; propTypes: &#123; // 您可以替 prop 指定 Javascript 預設的型別 // 這些都是可以選擇的 optionalArray: React.PropTypes.array, optionalBool: React.PropTypes.bool, optionalFunc: React.PropTypes.func, optionalNumber: React.PropTypes.number, optionalObject: React.PropTypes.object, optionalString: React.PropTypes.string, // 可以明確的限制 prop 為列舉型別。 optionalEnum: React.PropTypes.oneOf(['News','Photos']), // 限制某種 Class someClass: React.PropTypes.instanceOf(SomeClass), // 加上特上面說的任何一種型別加上必須的限制。 requiredFunc: React.PropTypes.func.isRequired // 加上自訂的驗證 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; throw new Error('Validation failed!') &#125; &#125; &#125;, /* ... */&#125;); 下面提供一個範例，你可以試著把 isShow 改成非 boolean 的任何值。 123456789101112/** @jsx React.DOM */var Test = React.createClass(&#123; propTypes: &#123; isShow: React.PropTypes.bool.isRequired &#125;, render: function () &#123; return ( &lt;p&gt;&#123;this.props.isShow ? \"true\" : \"false\"&#125;&lt;/p&gt; ); &#125;&#125;);React.renderComponent(&lt;Test isShow=&#123;true&#125; /&gt;, document.getElementById('example')) 出現錯誤： 我們可以再多嘗試一些範例來更明確理解: 1234567891011121314151617181920212223242526/** @jsx React.DOM */ var Car = function (wheel, brand) &#123; this.wheel = wheel; this.brand = brand; &#125;; Car.prototype.run = function () &#123; console.log('go!'); var Bike = function (wheel) &#123; this.wheel = wheel; &#125; var car = new Car(4, 'Toyota'); var bike = new Bike(2); console.log(car var Test = React.createClass(&#123; propTypes: &#123; vihicle: React.PropTypes.instanceOf(Car) &#125;, render: function () &#123; return ( &lt;p&gt;I drive &#123;this.props.vihicle.brand&#125; car and its has &#123;this.props.vihicle.wheel&#125; &lt;/p&gt; ); &#125; &#125;); React.renderComponent(&lt;Test vihicle=&#123;car&#125; /&gt;, document.getElementById('car')); // React.renderComponent(&lt;Test vihicle=&#123;bike&#125; /&gt;, document.getElementById('bike')); 預設 PropReact 可以讓你定義 props 的預設值 12345678var ComponentWithDefaultProps = React.createClass(&#123; getDefaultProps: function() &#123; return &#123; value: 'default value' &#125;; &#125; /* ... */&#125;); 執行範例： 123456789101112/** @jsx React.DOM */var ComponentWithDefault = React.createClass(&#123; getDefaultProps: function () &#123; return &#123;value: 'B'&#125; &#125;, render: function () &#123; return ( &lt;div&gt;&#123;this.props.value&#125;&lt;/div&gt; ); &#125;&#125;);React.renderComponent(&lt;ComponentWithDefault value='A' /&gt;, document.getElementById('example')); getDefaultProps 將會把預設值暫存起來，以確保 this.props.value 有值。以上面的實際範例來說如果你不帶值則值會是 B ，如果有值則預設值會被取代。這使得你可以放心使用 props ，而無需反覆撰寫脆弱的代碼來處理元件。 傳遞 Props 的捷徑常見的 React 元件是用基本 HTML 組合的延伸。通常你會想要傳遞屬性給 HTML 元素，React 提供了 transferPropsTo() 方法可以把屬性帶入讓你少打一些字。 12345678910111213141516/** @jsx React.DOM */var CheckLink = React.createClass(&#123; render: function() &#123; // transferPropsTo() will take any props passed to CheckLink // and copy them to &lt;a&gt; return this.transferPropsTo(&lt;a&gt;&#123;'√ '&#125;&#123;this.props.children&#125;&lt;/a&gt;); &#125;&#125;);React.renderComponent( &lt;CheckLink href=\"javascript:alert('Hello, world!');\"&gt; Click here! &lt;/CheckLink&gt;, document.getElementById('example')); 上面這段說明，其實我們應該先釐清一般來說我們會把 React.renderComponent(&lt;Component attribute=&#39;value&#39;/&gt;)，當作呼叫函式或實例化物件，所以這邊的工作是把參數帶進去。接著因為 React 在 render() 的時候只能有一個根元素去包含其他元素。所以當你用了 transferPropsTo() 實例化產生物件那邊的屬性(attributes)會被整合到跟元素，接著你可以用 this.props.children 拿到在帶進來的子元素。如果上面這段說明你還不是很明白，我們在比較一下沒有 transferPropsTo() 的寫法： 12345678910111213141516/** @jsx React.DOM */var CheckLink = React.createClass(&#123; render: function() &#123; // transferPropsTo() will take any props passed to CheckLink // and copy them to &lt;a&gt; return (&lt;a href=&#123;this.props.href&#125;&gt;&#123;'√ '&#125;&#123;this.props.children&#125;&lt;/a&gt;); &#125;&#125;);React.renderComponent( &lt;CheckLink href=\"javascript:alert('Hello, world!');\"&gt; Click here! &lt;/CheckLink&gt;, document.getElementById('example')); 好吧！上面這個例子你並沒有少打幾個字，但如果當屬性很多的時候就真的是了XD Mixin在 React 中元件是是幫助你重複使用程式碼最好的方式，但是有些時候不同的元件可能會同樣的功能。有時候被稱作橫切關注點。React 提個 mixin 解決這個問題。一個常見的情況是元件透過 setInterval() 更新，不過問題是當你不需要更新要取消 setInterval() 的時候。當你知道關於元件的生命週期，你就可以透過 mixin 讓有需要這個功能的元件共用。 1234567891011121314151617181920212223242526272829303132333435363738/** @jsx React.DOM */var SetIntervalMixin = &#123; componentWillMount: function() &#123; this.intervals = []; &#125;, setInterval: function() &#123; this.intervals.push(setInterval.apply(null, arguments)); &#125;, componentWillUnmount: function() &#123; this.intervals.map(clearInterval); &#125;&#125;;var TickTock = React.createClass(&#123; mixins: [SetIntervalMixin], // Use the mixin getInitialState: function() &#123; return &#123;seconds: 0&#125;; &#125;, componentDidMount: function() &#123; this.setInterval(this.tick, 1000); // Call a method on the mixin &#125;, tick: function() &#123; this.setState(&#123;seconds: this.state.seconds + 1&#125;); &#125;, render: function() &#123; return ( &lt;p&gt; React has been running for &#123;this.state.seconds&#125; seconds. &lt;/p&gt; ); &#125;&#125;);React.renderComponent( &lt;TickTock /&gt;, document.getElementById('example')); 注意當元件混入很多 mixin event 的時候，如果是生命週期的函式則保證被呼叫，但如果不是則會導致元件被破壞。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 複合式元件","slug":"reactjs-composite-components","date":"2014-02-12T15:56:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/12/reactjs-composite-components/","link":"","permalink":"//andyyou.github.io/2014/02/12/reactjs-composite-components/","excerpt":"複合式元件到目前為止我們看過了如何建立一個單一的元件去呈現資料以及回應使用者的操作。接下來讓我們來看看 React 的另一個重要的功能：可組成。","text":"複合式元件到目前為止我們看過了如何建立一個單一的元件去呈現資料以及回應使用者的操作。接下來讓我們來看看 React 的另一個重要的功能：可組成。 動機：關注點分離模組化建立可重複使用的界面元件，透過使用 function 或類別，讓我們可以在開發時得到一些益處。具體來說可以針對應用程式的功能分離不同的關注點，不過還是請你在建立新元件的時候儘量保持單純。針對應用程式自行設計元件庫，你的 UI 也比較容易和你的應用整合在一起。 在使用 jQuery 和其他第三方套件時候，我們常常會因為作者設定的 HTML 結構(樣板)打亂了我們既有的編排習慣，在 React 中我們通常只要在需要的地方放入一個 &lt;div&gt; ，接著實際產出的 HTML 和功能會透過 Javascript 直接注入。我們只要知道怎麼用元件就好，而不需要去組織樣板。 範例讓我們建立一個單純的 Avatar(頭像)元件，它使用 Facebook Graph API 來取得個人資料和大頭照然後顯示。 1234567891011121314151617181920212223242526272829303132333435/** @jsx React.DOM */var Avatar = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;ProfilePic username=&#123;this.props.username&#125; /&gt; &lt;ProfileLink username=&#123;this.props.username&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var ProfilePic = React.createClass(&#123; render: function() &#123; return ( &lt;img src=&#123;'http://graph.facebook.com/' + this.props.username + '/picture'&#125; /&gt; ); &#125;&#125;);var ProfileLink = React.createClass(&#123; render: function() &#123; return ( &lt;a href=&#123;'http://www.facebook.com/' + this.props.username&#125;&gt; &#123;this.props.username&#125; &lt;/a&gt; ); &#125;&#125;);React.renderComponent( &lt;Avatar username=\"pwh\" /&gt;, document.getElementById('example')); 在上面的範例中，Avatar 元件實例裡面俱有 ProfilePic 和 ProfileLink 兩個元件。在 React 裡面主元件就是最上層的元件應該要提供 props 所需的資料。更精准一點來說，如果有一個元件Ｘ被寫在元件Ｙ的 render() 裡面，這表示 Y 是擁有者-主元件也就是那個負責掌管狀態的元件。如同之前討論的一個元件不能更動自己的 props，而是透過上層元件去設定。通過屬性當接點我們可以保證 UI 的資料永遠是來自同一個地方以確保資料一致性。有個重要的觀念是釐清這些被擁有者的關係和主從關係。被擁有者關係是 React 所俱有的，而元素地主從關係(父元素及子元素關係)就是單純的 DOM 結構。拿上面的範例說明：Avatar 擁有 div，ProfilePic，ProfileLink 物件。div 只是父元素，但他不是ProfilePic 和 ProfileLink 的擁有者(主元件)。 從程式的概念上來理解，一個 Avatar 是透過 React.createClass() 先建立類別，然後 new (React.renderComponent(&lt;Avatar /&gt;, [domTag]))產生的實例物件來使用，每一個物件本身都有自己的 this.props 屬性。且資料通常是透過 &lt;Avatar username={data} /&gt; 傳入的。元件的資料狀態通常避免從外部影響，帶入參數之後就讓元件自己內部去處理。看看編譯過的程式碼會比較好理解 React.renderComponent(Avatar({username:&#39;pwh&#39;}), document.getElementById(&#39;example&#39;));，所以擁有者元件是 Avatar 而不是 render() 裡面的 &lt;div&gt;。當然所謂的控管資料和狀態就是 Avatar 。而 &lt;div&gt; 只不過是用來輸出 DOM 結構的父元素。 子元件當你建立了一個 React 物件，你可以包含其他的 React 元件或 Javascript 表示式。 1&lt;Parent&gt;&lt;Child /&gt;&lt;/Parent&gt; 讓我們根據上面的說明再提出一個範例 123456789101112131415161718192021222324252627282930/** @jsx React.DOM */var Avatar = React.createClass(&#123; render: function () &#123; return ( &lt;div&gt; &lt;ProfilePic username=&#123;this.props.username&#125; /&gt; &lt;ProfileLink username=&#123;this.props.username&#125; /&gt; &#123;this.props.children /* 載入子元素 */&#125; &lt;/div&gt; /* 複習一下一個元件只能有一個根節點，你不能在這邊再加入一個 &lt;div&gt; */ ); &#125;&#125;);var ProfilePic = React.createClass(&#123; render: function () &#123; return ( &lt;img src=&#123;'http://graph.facebook.com/' + this.props.username + '/picture'&#125; /&gt; ); &#125;&#125;);var ProfileLink = React.createClass(&#123; render: function () &#123; return ( &lt;a href=&#123;'http://www.facebook.com/' + this.props.username&#125;&gt; &#123;this.props.username&#125; &lt;/a&gt; ); &#125;&#125;);React.renderComponent(&lt;Avatar username='andyyu0920'&gt;&lt;ProfileLink username='phw' /&gt;&lt;/Avatar&gt;, document.getElementById('example')); 父元件可以透過 this.props.children 讀取子元件。 子元件調和(Reconciliation)調和的意思是 React 更新渲染 DOM 的處理過程。一般來說子元件會根據他們的順序重新被調整輸出。舉下面的例子來說 123456789// Render Pass 1&lt;Card&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/Card&gt;// Render Pass 2&lt;Card&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/Card&gt; 我們會直覺的認為 &lt;p&gt;Paragraph 1&lt;/p&gt; 被移除，但實際上 React 會重新調和 DOM ，他會把第一個元素的內容換掉，接著刪除最後一個元素。 1234567891011121314151617181920212223/** @jsx React.DOM */var Card = React.createClass(&#123; render: function () &#123; return ( &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;);React.renderComponent( &lt;Card&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;/Card&gt;, document.getElementById('example'));React.renderComponent( &lt;Card&gt; &lt;p&gt;Paragraph 2&lt;/p&gt; &lt;/Card&gt;, document.getElementById('example')); 為了更理解上面說的我們實作了另一個範例 1234567891011121314151617181920/** @jsx React.DOM */var Card = React.createClass(&#123; getInitialState: function () &#123; return &#123;children: [&lt;input type='text' /&gt;, &lt;p&gt;Paragraph 1&lt;/p&gt;, &lt;p&gt;&#123;(new Date().toTimeString())&#125;&lt;/p&gt;]&#125;; &#125;, render: function () &#123; return ( &lt;div&gt; &#123;this.state.children&#125; &lt;/div&gt; ); &#125;&#125;);var card = React.renderComponent( &lt;Card /&gt;, document.getElementById('example') );setInterval(function() &#123; card.setState(&#123;children: [&lt;input type='text' /&gt;, &lt;p style=&#123;&#123;display: 'none'&#125;&#125;&gt;Paragraph 1&lt;/p&gt;, &lt;p&gt;&#123;(new Date().toTimeString())&#125;&lt;/p&gt;,&lt;p&gt;Paragraph 2&lt;/p&gt;]&#125;);&#125;, 500); 直覺上我們會覺得 &lt;input&gt; 會被重新輸出，但是當我們在輸入框裡面留下資料的時候會發現他並沒有變成空白。總結來說 React 並不是單純直接把元件輸出，而是在內部經過比對處理後只更新異動的部分。 內嵌子元件狀態對大多數元件來說，上面說的這種機制通常沒有什麼問題，然而對控管 this.state 的元件來說這可能會有問題。一般情況下你可以透過隱藏元素來取代刪除他們。也就是說通常元件的結構定義完成之後我們通常不會去破壞任何一個節點。 12345678910// Render Pass 1&lt;Card&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/Card&gt;// Render Pass 2&lt;Card&gt; &lt;p style=&#123;&#123;display: 'none'&#125;&#125;&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/Card&gt; 動態的內嵌子元件當情況變得更複雜，內嵌的子元件被重新排列，例如顯示搜尋結果，或者要加入一些新的元件。在這些情況下每個元件唯一的識別子或狀態必須維持在 render() 傳遞。 12345678910render: function() &#123; var results = this.props.results; return ( &lt;ol&gt; &#123;this.results.map(function(result) &#123; return &lt;li key=&#123;result.id&#125;&gt;&#123;result.text&#125;&lt;/li&gt;; &#125;)&#125; &lt;/ol&gt; ); &#125; 當 React 調和(重新調整)這些帶有 key 的子元件時，這可以確保任何有 key 的元件都將被重新載入(而不是被破壞)或破壞(而不是重複使用)。我們來寫段範例驗證 1234567891011121314151617181920/** @jsx React.DOM */var data = [&#123;id: 1, text:'A'&#125;];var List = React.createClass(&#123; render: function () &#123; var results = this.props.results; return ( &lt;ol&gt; &#123;results.map(function (result) &#123; return &lt;input type='text' key=&#123;result.id&#125;/&gt;; &#125;)&#125; &lt;/ol&gt; ); &#125;&#125;);React.renderComponent(&lt;List results=&#123;data&#125; /&gt;, document.getElementById('example'));setInterval(function() &#123; data[0].id += 1; React.renderComponent(&lt;List results=&#123;data&#125; /&gt;, document.getElementById('example'));&#125;, 5000); 在 &lt;input&gt; 輸入值之後 5 秒後因為 key 變換了所以你的輸入的值就被清空了。 資料流在 React ，資料是從主元件透過 props 傳遞就如同之前說過的。實際上這是一個單向的資料繫結。主元件負責把資料繫結到子元件的 props ，主元件可以基於 props 或 state 進行計算，由於這個流程會發生遞迴所以資料會自動映射至使用的地方。 關於效能你也許會思考這樣的模式當 React 需要修改大量資料和節點的時候效能會不佳，好消息是 Javascript 本身是非常快速的，而且 render() 往往不會太複雜，因此大部份的應用程式速度都非常快。此外問題幾乎都在 DOM 的更動並不是 Javascript 而且 React 將會使用 batching 和 change detection 優化這些。然而有些時候你真的想要調整這些效能的問題，此時你可以覆寫 shouldComponentUpdate() 方法，透過回傳 false 。React 將會略過這段處理。詳細參閱 the React reference docs 。 注意：當 shouldComponentUpdate() 傳回 false ，此時資料被改變了，React 就不能維持 UI 同步了。只有在有明顯效能問題的時候才使用它，且請確保你知道該如何使用。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 互動式動態 UI","slug":"reactjs-ui","date":"2014-02-10T13:43:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/10/reactjs-ui/","link":"","permalink":"//andyyou.github.io/2014/02/10/reactjs-ui/","excerpt":"互動式動態 UI你已經學會如果使用 React 呈現資料了。現在讓我們的界面增加互動的功能。","text":"互動式動態 UI你已經學會如果使用 React 呈現資料了。現在讓我們的界面增加互動的功能。 範例1234567891011121314151617181920212223/** @jsx React.DOM */var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? 'like' : 'unlike'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);React.renderComponent( &lt;LikeButton /&gt;, document.getElementById('example')); 事件處理與合成事件跟你在 HTML 裡替標簽增加事件處理程序一樣，在 React 中你必須要駝峰式的命名來設定事件。例如：onClick。React 保證實做的合成事件在 IE8 以上瀏覽器裡定義的所有事件行為是一致的。也就是說不管你使用哪種瀏覽器 React 都知道如何按照 Spec 規範傳遞(Bubble)和截取事件，並傳遞給事件處理程序確保一切都和 W3C 規範的一樣。如果你想使用 React 在觸控裝置上(例如: 智慧型手機和平板)，你可以呼叫 React.initializeTouchEvents(true) 開啟他們。 表面之下的機制：自訂繫結和委派React 內部做了一些處理以確保你的程式執行的效能不會太糟和容易理解。 自動繫結：在 Javascript 中當一個 callback 函式被建立時你通常需要明確的將它跟某個物件的方法關聯在一起使得我們可以確定資料是正確的。在 React ，每一個方法都是自動跟元件綁定。React 會暫存已綁定的方法以增加 CPU 和記憶體的使用效率。 事件委派：React 實際上並沒有附加任何事件到元素本身。當 React 啟動時，它會在最上層啟動一個事件監聽器監聽所有的事件。當一個元件載入或取消載入的時候，事件處理程序會自動從內部增加或移除。一旦事件被觸發，React 會知道如何調派以及使用對應的程序，如果裡面沒有對應的事件，React 則不會執行任何動作。如果你想學習關於增加處理速度的知識可以參考David Walsh’s excellent blog post。 元件就是狀態機React 認為 UI 就是一個簡單的狀態機。從 UI 的角度思考，UI 本身俱有多種狀態，並且負責把這些狀態輸出呈現。這樣做可以輕易讓你的 UI 保持一致。在 React 中，你只要單純更新元件的狀態，接著根據狀態渲染輸出新的 UI。React 透過較有效率的方式協助你更新 DOM 。 狀態如何運作比較普遍的方式通知 React 資料已經變動了是透過呼叫 setState(data, callback) ，這個方法會把資料 data 整合進 this.state 接著重新渲染元件。當原件完成這個動作，你可以額外的加入 callback 做後續處理，當然也可以不加。大多的狀況你不會需要提供 callback 因為 React 會自動及時的更新資料。 什麼元件應該有狀態？大部分的原件都應該會從 props 取得一些資料，然後輸出。然而有些時候你還是需要回應使用者的操作，伺服器的請求，或一些隨著時間變化的資料。這個時候我們就會使用狀態 state 。試著讓大多數的元件盡可能沒有狀態。透過這種方式你可以獨立各種狀態的邏輯盡可能減少複雜的邏輯，這會使你的應用程式比較容易理解。一個比較常見的模式是先建立一些沒有狀態的元件，它們只負責輸出資料，然後在它們的上層有一個負責管理狀態的元件再把狀態資訊透過 props 傳給子元素。這個有狀態的元件內部封裝所有邏輯和方法，透過屬性宣告的方式底下的元件只要負責渲染資料。 該如何使用狀態？狀態應該負責管理資料，實務上就是元件內的事件處理程序在資料發生異動的時候被觸發然後更新 UI 。在實際的程式裡這些資料通常是很小的 JSON。當建立一個管理狀態的元件時，盡可能思考最簡化的表達方式，且資料只放在 this.state 中。在 render() 方法內部則根據這個狀態單純的計算出你需要的資訊就好。你會發現思考並以這種方式寫程式往往是最正確的。因此在狀態內部增加任何多餘的資料或計算意味著你需要去處理多餘的東西以確保資料是一致的，不要一味的依賴 React 計算處理資料。 狀態不應該這樣用？this.state 應該只存放 UI 需要呈現的資料，不應該包含： 已處理完成的資料：不用預先計算處理狀態的資料。在 render() 裡面計算資料是比較容易確保 UI 的資料是正確的。舉例來說如果有一個項目清單的陣列，你想要輸出清單數量，應該單純的在 render() 裡面使用 this.state.listItems.length + &#39; list items&#39; 而不是把值直接存在 this.state。 React 元件：在 render() 裡面根據 props state 去建置。 重複存取在 props 裡的資料：props 應該是正確資料的來源，因為 props 可能隨著時間改變。適當的把 props 存在 state 可以協助我們取得之前的資料。 補充說明：在上面的文章中我們了解到通常會使用一個主要的元件負責管理狀態，而其他子元件需要的時候則直接使用主元件的 props 和方法，下面的補充範例我們將簡單的示範一些關於使用事件的方式： 12345678910111213141516171819202122232425262728293031/** @jsx React.DOM *//* 建立一個 Clicker 元件類別 */var Clicker = React.createClass(&#123; /* 透過 render() 輸出三個超連結並使用主元件的事件。 */ render: function () &#123; var bind = this.handleBind.bind(this); return ( &lt;div&gt; &#123; /* 下面這個超連結示範了一般使用主元件的方法 */&#125; &lt;a onClick=&#123;this.handleNormal&#125;&gt;Normal&lt;/a&gt; &#123; /* 使用 bind() 的目的是為了在 function 內再使用主元件的函式 */&#125; &lt;a onClick=&#123;bind&#125;&gt;Bind&lt;/a&gt; &#123; /* 在 0.4.0 版之後為了簡化程式碼，預設就是 autoBind。 */&#125; &lt;a onClick=&#123;this.autoBindClick&#125;&gt;AutoBind&lt;/a&gt; &lt;/div&gt; ); &#125;, handleNormal: function (event) &#123; alert('Normal Event'); &#125;, handleBind: function (event) &#123; alert(this.ALERT_BIND); /* 取用主元件的函式 */ &#125;, autoBindClick: function (event) &#123; alert(this.ALERT_AUTOBIND); &#125;, ALERT_BIND: 'Bind Event', ALERT_AUTOBIND: 'Auto Bind Event' // oldAutoBindClick: React.autoBind(function () &#123;...&#125;)&#125;);React.renderComponent(&lt;Clicker /&gt;, document.getElementById('example')); 其他資訊React.autoBind() 移除Javascript bind()","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"JSX 常見的陷阱","slug":"reactjs-jsx-common-pitfalls","date":"2014-02-10T03:00:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/10/reactjs-jsx-common-pitfalls/","link":"","permalink":"//andyyou.github.io/2014/02/10/reactjs-jsx-common-pitfalls/","excerpt":"JSX 常見的陷阱JSX 看起來像 HTML 但有一些您應該知道關鍵性的差異。注意：對於和 DOM 之間的差異，例如行內式屬性設定(inline style)，請查閱這裡。","text":"JSX 常見的陷阱JSX 看起來像 HTML 但有一些您應該知道關鍵性的差異。注意：對於和 DOM 之間的差異，例如行內式屬性設定(inline style)，請查閱這裡。 DOM 的差異：React 為了跨瀏覽器和提升效能的因素，實作一套和瀏覽器本身無關的 events 以及模擬 DOM 的機制。我們可以借由這個機制處理一些關於原始 DOM 設計上一些不足的地方。 所有的 DOM 屬性 Properties 和 Attributes (包含事件)都應該使用駝峰式命名 camelCased ，這和一般的 Javascrpt 程式碼風格一致。我們故意在這邊違背 html 規格 ，因此這和 html 規格是不同的。 style 屬性透過 Javascript 物件和駝峰式的屬性來設定，而不是 CSS 字串。所以設定 CSS 的語法風格會和 DOM, Javascrit 屬性一致，外加這麼做可以防止 XSS 攻擊。 所有在事件符合 W3C 規範，且所有事件(包含 submit)傳遞都遵照 W3C 規範，查閱 Event System 取得更多資訊。 關於 onChange 事件行為就跟你所期待的一樣，當一個表單欄位改變了，事件就會被觸發，而不是在 onblur 失去焦點的時候才觸發。 我們特意違背現有的瀏覽器行為，因為原始的 onChange 事件行為跟其名稱並不符合，React 需要正確的用到這個 Event ，當使用者輸入資料的同時 React 就會及時反應。查閱Forms得知更多資訊。 表單輸入的屬性例如 value checked 更多關於一些命名，用法，等請查閱 Forms 移除空白字元JSX 不像 HTML 在渲染時如果在同一個點重複空白字元會保留一個其他自動移除，關於這點 JSX 會移除所有在 { } 之間的空白。如果你需要加入空白字元則要使用 {&#39; &#39;}。 1&lt;div&gt;&#123;this.props.name&#125; &#123;' '&#125; &#123;this.props.surname&#125;&lt;/div&gt; 如果你對這個設計有什麼想法，歡迎加入Issue #65討論。 HTML 字元實體您可以插入 HTML 字元實體在 JSX 裡： 1&lt;div&gt;First &amp;middot; Second&lt;/div&gt; 如果你想要顯示一個 HTML 字元實體在動態的內容中，你會遇到重複跳脫字元的問題。因為 React 為了防止 XSS 會把所有要呈現的文字都先跳脫(escapes)。 12// 不好的示範: 會輸出 \"First &amp;middot; Second\"&lt;div&gt;&#123;'First &amp;middot; Second'&#125;&lt;/div&gt; 這裡有一些方式可以解決這個問題。最簡單的方式就是在 Javascript 直接寫 unicode，不過你需要確定檔案被存成 UTF-8 格式。 1&lt;div&gt;&#123;'First · Second'&#125;&lt;/div&gt; 一個更安全的替代方式式找到 unicode 對應的編碼 12&lt;div&gt;&#123;'First \\u00b7 Second'&#125;&lt;/div&gt;&lt;div&gt;&#123;'First ' + String.fromCharCode(183) + ' Second'&#125;&lt;/div&gt; 也可以把字串混合進陣列裡面 1&lt;div&gt;&#123;['First ', &lt;span&gt;&amp;middot;&lt;/span&gt;, ' Second']&#125;&lt;/div&gt; 當你要插入 HTML 的時候你可以用這最後一招 1&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: 'First &amp;middot; Second'&#125;&#125; /&gt; 自定 HTML 屬性如果你傳給 HTML 元素的屬性並不在 HTML 規範中，React 並不會渲染它。如果你想要自訂一個屬性(attribute)。你應該使用前綴詞 data-。 1&lt;div data-custom-attribute=\"foo\" /&gt; 無障礙網站的話屬性使用 aria- 開頭。 1&lt;div aria-hidden=&#123;true&#125; /&gt;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Gulp 初體驗","slug":"gulp-first-experience","date":"2014-02-09T12:16:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/09/gulp-first-experience/","link":"","permalink":"//andyyou.github.io/2014/02/09/gulp-first-experience/","excerpt":"Gulp 初體驗從轉用 Grunt 以來其實我沒有遇到太多問題，加上大部份的 Framework 都把 Task 寫得好好的，對我來說用就好了。特別要客製的地方大概也都是小改一下別人的 Gruntfile 。這篇記錄沒有要特別去分析 Gulp 。介紹在這篇The streaming build system Gulp就解釋得蠻清楚的了。只不過在這不想外出的下雨天稍微用看看 Gulp。以下記錄非常單純，只是透過 Gulp 來編譯 Coffee, Jade，使用一下 watch 功能體驗一下。","text":"Gulp 初體驗從轉用 Grunt 以來其實我沒有遇到太多問題，加上大部份的 Framework 都把 Task 寫得好好的，對我來說用就好了。特別要客製的地方大概也都是小改一下別人的 Gruntfile 。這篇記錄沒有要特別去分析 Gulp 。介紹在這篇The streaming build system Gulp就解釋得蠻清楚的了。只不過在這不想外出的下雨天稍微用看看 Gulp。以下記錄非常單純，只是透過 Gulp 來編譯 Coffee, Jade，使用一下 watch 功能體驗一下。 透過實作我覺得比較容易理解： 安裝1$ npm install -g gulp 建立一個簡單的測試專案123$ mkdir gulp-test # 建立目錄$ npm init # 建立 package.json$ npm install gulp gulp-util gulp-jade gulp-coffee gulp-watch 建立 gulpfile.js這隻檔案的功能跟 Grunt 的 Gruntfile.js 功能上是一樣的就是組織任務的地方。下面這段程式碼雖然已經被驗證有瑕疵，但在這邊只是為了體驗一下概念還是先保留後面會再補上比較好的做法。 1234567891011121314151617var gulp = require('gulp');var gutil = require('gulp-util');var jade = require('gulp-jade');var watch = require('gulp-watch');var coffee = require('gulp-coffee');gulp.task('default', function () &#123; gulp.src('./*.coffee') .pipe(watch()) .pipe(coffee()) .pipe(gulp.dest('./')) , gulp.src('./*.jade') .pipe(watch()) .pipe(jade()) .pipe(gulp.dest('./'))&#125;); 建立測試用 Jade1234567doctype htmlhtml head title Hello Gulp &amp; Jade script(src='test.js') body h1 Cool, Getting Started 列出可執行的任務1$ gulp -T 執行任務1$ gulp 比較好的做法根據官方的範例，其實 watch 應該是直接使用內建的 api 就好了。下面把試用的一段程式碼提供給大家參考 1234567891011121314151617181920212223242526272829303132333435363738394041// 載入函式庫var gulp = require('gulp');var gutil = require('gulp-util');var jade = require('gulp-jade');var watch = require('gulp-watch');var coffee = require('gulp-coffee');// 定義路徑var paths = &#123; coffee: ['*.coffee'], jade: ['*.jade']&#125;;// 編譯 coffee script 任務gulp.task('coffee', function () &#123; gulp.src(paths.coffee) .pipe(coffee()) .pipe(gulp.dest('./'))&#125;);// 編譯 jade 任務gulp.task('jade', function () &#123; gulp.src(paths.jade) .pipe(jade()) .pipe(gulp.dest('./')) gutil.log('log here...ok') // 可以使用 gutil 輸出資料&#125;);var watcher = gulp.task('watch', function () &#123; // 建立完成任務後的 callback var done = function (evt) &#123; console.log('File ' + evt.path + ' was ' + evt.type + ', running tasks...'); &#125;; var coffeer = gulp.watch(paths.coffee, ['coffee'], done); // 觸發時綁定一個 event coffeer.on('change', function () &#123; gutil.log('start changing...'); &#125;); gulp.watch(paths.jade, ['jade']);&#125;);gulp.task('default', ['coffee', 'jade', 'watch']); 心得用起來其實蠻直覺的，不過小試了一下覺得第一文件有點不完整。有些小細節沒有內建功能，例如 gulp -T 對於指令竟然沒有地方可以放描述(我在文件上沒找到)。寫起來很爽，不過我覺得對專案來說除了寫 gulpfile 以外的其他開發者應該會覺得這些 task 提示的訊息怎麼這麼少。當然這些是可以加的，只不過初步用起來會覺得少蠻多東西的。XD","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"gulp","slug":"gulp","permalink":"//andyyou.github.io/tags/gulp/"},{"name":"task runner","slug":"task-runner","permalink":"//andyyou.github.io/tags/task-runner/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"為什麼使用 React ?","slug":"reactjs-why-reactjs","date":"2014-02-08T05:48:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/08/reactjs-why-reactjs/","link":"","permalink":"//andyyou.github.io/2014/02/08/reactjs-why-reactjs/","excerpt":"原文 為什麼使用 React ？React 是 Facebook 和 Instagram 用來建置使用者介面的函式庫。近來有許多人考慮使用 React 來處理 MVC 中的 V 的部分。Facebook 創造了 React 是為了解決構建一個大型且資料不斷變動的應用程式時遇到的問題。為了達到這個需求，React 採用了兩個主要的核心概念。","text":"原文 為什麼使用 React ？React 是 Facebook 和 Instagram 用來建置使用者介面的函式庫。近來有許多人考慮使用 React 來處理 MVC 中的 V 的部分。Facebook 創造了 React 是為了解決構建一個大型且資料不斷變動的應用程式時遇到的問題。為了達到這個需求，React 採用了兩個主要的核心概念。 單純性(Simple)任何一個時間點您的應用程式都應該傳達同樣的資訊，且當在背後的資料改變的時候 React 會自動管理關於界面 UI 上的更新。 定義的方式(Declarative)這個翻譯有點不是很精準，大略是說您不應該從外部去控制元件該如何更新資料，而是在元件內部定義資料是哪來的怎麼更新。當資料發生變更的時候，概念上就是 React 點擊了 refresh 按鈕，接著元件會自己知道只變更有更新的部分。 構建可組合的元件什麼是元件呢？在 React 中所有的東西都是元件。事實上，使用 React 就是在建立這些可以重複使用的元件。因此你的目標就是封裝，組件化，重複使用，關注點分離。 小弟認為最好實務上的舉例就是類似 WinForm 或 WPF 的控制項(dll)。用起來就像 XAML ，透過屬性傳遞參數，至於程式行為已經都封裝在類別裡面了。 給個 5 分鐘看看React 挑戰了很多傳統的做法，而且第一次大略看到這東西也許會覺得它瘋了嗎。給個 5 分鐘閱讀官方文件：這些概念已經建立了上千個元件且我們應用在 Facebook 和 Instagram。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 第一個實戰範例","slug":"reactjs-tutorial","date":"2014-02-07T07:36:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/07/reactjs-tutorial/","link":"","permalink":"//andyyou.github.io/2014/02/07/reactjs-tutorial/","excerpt":"學習手冊本篇教學會協助你建立一個簡單，但是實用的留言框功能，你可以放置到你的 blog 中。類似于Disqus，LiveFyre，或者 Facebook comments。留言框提供下列功能： 留言框的界面(view)。 一個表單(form)可以送出留言。 為你的後端程式提供一個 Hooks ，","text":"學習手冊本篇教學會協助你建立一個簡單，但是實用的留言框功能，你可以放置到你的 blog 中。類似于Disqus，LiveFyre，或者 Facebook comments。留言框提供下列功能： 留言框的界面(view)。 一個表單(form)可以送出留言。 為你的後端程式提供一個 Hooks ， Hooks 簡易說明：Hooks 英文翻譯為鉤子，在程式術語中所表達的是在程式特定位置埋入一段預留的程式碼，用來呼叫其他對應的程式碼。可以大略想成在某個片段先空出一個位置，這個位置可以在事後再放入動作，不放也沒關係。 同時也有下列的特點: 優化留言：留言在儲存到伺服器之前就出現在列表中，這會讓使用者有變快的感覺。 及時更新：當其他使用者留言時，我們將及時的取出他們的留言並放置到界面中，不用等使用者自己更新頁面。 Markdown 格式：使用者可以用 Markdown 格式來留言，這可使得留言的排版更多元整齊。 直接閱覽原始碼 Github 起步在這一篇教學中我們會使用預先建置好放置在 CDN 的 Javascript 檔案。開啟你最愛的文字編輯器例如：Sublime text 然後建立一個 HTML 文件如下： 1234567891011121314151617181920&lt;!-- template.html --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script src=\"http://fb.me/react-0.8.0.js\"&gt;&lt;/script&gt; &lt;script src=\"http://fb.me/JSXTransformer-0.8.0.js\"&gt;&lt;/script&gt; &lt;script src=\"http://code.jquery.com/jquery-1.10.0.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/jsx\"&gt; /** * @jsx React.DOM */ // The above declaration must remain intact at the top of the script. // 上面的宣告註解仍然得維持在 &lt;script&gt; 標簽中的頂部。 // Your code here！您的程式碼。 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 為了完成教學剩下的部分，我們開始在 &lt;script&gt; 標簽內撰寫 Javascript。 第一個元件整個 React 本身就是在模組化和設計可組成的元件，例如這個留言框的範例接下來就會遵循元件的架構。 1234- CommentBox - CommentList - Comment - CommentForm 在使用 React 開發時一開始定義好整個架構可以協助您更快速準確的開發。讓我們來建立 CommentBox 留言框這個元件，它只需要一個簡單的 &lt;div&gt;： 1234567891011121314// tutorial1.jsvar CommentBox = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; Hello, world! I am a CommentBox. &lt;/div&gt; ); &#125;&#125;);React.renderComponent( &lt;CommentBox /&gt;, document.getElementById('content')); 小提醒：在 React 中使用 JSX &lt;div&gt; 或 &lt;CommentBox /&gt; 的標簽時 / 結尾的關閉標簽一定要加，否則會造成錯誤。 JSX 語法首先就是你應該注意到那些在 Javascript 中類似 XML 的語法，這些特殊的 JSX 語法是為了讓我們更方便直覺的維護程式碼的糖衣語法，我們會需要使用預先編譯器負責去轉換這些糖衣語法為原生的 Javascript。 糖衣語法：指程式語言中添加的某種語法，這種語法對語言的功能並沒有影響，但是更方便程式設計師使用。通常來說使用語法糖能夠增加程序的可讀性，從而減少程序代碼出錯的機會。 事實上，如果不使用 JSX 你依然可以撰寫 React 。不過得改用原生的 React 物件去組織程式碼，而寫出來的程式碼和透過 JSXTransformer 轉換的語法基本上是會一樣的。如下範例： 123456789101112131415var CommentBox = React.createClass(&#123; render: function () &#123; reutrn ( React.DOM.div(&#123; className: 'commentBox', children: 'Hello, world! I am a CommentBox.' &#125;) ); &#125;&#125;);React.renderComponent( CommentBox(&#123;&#125;), document.getElementById('content')) 小提醒：開發時我們會使用 JSXTransformer 以方便開發，而當要部署 Production 的時候，建議要先行編譯轉換以提升效能。 JSX 不是一定要使用的，不過官方建議 JSX 的語法比純 Javascript 更簡潔易維護，如果你想了解更多可以閱讀 JSX Syntax。 剛剛我們做了什麼？React.createClass() 透過傳入一個 Javascript 物件包含一些方法(method)就可以建立新的 React 元件物件。在所有方法裡面最重要的就是 render() ，它會傳回一個 React 元件的樹狀結構，最後被輸出成 HTML 。在 JSX 裡面的 &lt;div&gt; 標簽並不是實際的 DOM 元素。他只是 React div 元件的實例物件(React.DOM.div)。你可以把它當成一種標記或者資料片段，他的功用只是讓 React 知道該怎麼處理這些標記，進而產生對應的 HTML。這也是 React 本身提供的一套安全機制。它並不會直接產生 HTML 字串，它是透過解析標記最後透過內部一套機制產生 DOM 物件 ，所以預設就可以防止關於 XSS 攻擊。因此你不需要撰寫一段標準完整的 HTML 語法，只要傳回一個你或其他人寫的元件結構。這就是 React 所謂『可組成』的概念，前端發展可維護性程式碼的核心概念之一。React.renderComponent() 這個方法是用來將根元件實例化，並且把 React 產生的標記注入到第二個參數指向的原始 HTML DOM 元素。以上例來說就是第一個參數是先初始化 &lt;CommentBox /&gt; 把它 new 出來後，再把 React 解析產生的 HTML (嚴格說是 DOM 元素)注入到 document.getElementById(&#39;content&#39;) 這個元素中。 組成元件讓我們來繼續建構 CommentList 和 CommentForm: 12345678910111213141516171819var CommentList = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentList\"&gt; Hello, world! I am a CommentList. &lt;/div&gt; ); &#125;&#125;);var CommentForm = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentForm\"&gt; Hello, world! I am a CommentForm. &lt;/div&gt; ); &#125;&#125;); 接著修改 CommentBox 元件，使用我們剛剛完成的 CommentList 和 CommentForm。 1234567891011var CommentBox = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;); 注意到我們在上面的範例混合了 HTML 的 &lt;h1&gt; 標簽和 &lt;CommentList&gt; 等元件，HTML 標簽是正規的 React 元件，就跟你定義的元件一樣，但這之中有一點點不同。 JSX 的編譯器會自動把 HTML 標簽轉成 React.DOM.tagName ，這是為了防止污染全域的命名空間。 補充：如果你對於不使用 JSX 的寫法比較有興趣下面列出一段大概的用法： 1234567891011var CommentBox = React.createClass(&#123;displayName: 'CommentBox', render: function () &#123; return ( React.DOM.div( &#123;className:\"commentBox\"&#125;, React.DOM.h1(null, \"Comments\"), CommentList(null ), CommentForm(null ) ) ); &#125;&#125;); 元件屬性(Component Properties)建立 Comment 元件。我們想要顯示留言者的名字和訊息，並且重複使用相同的程式碼給每一則獨立的留言。讓我們加入一些留言到 CommentList： 12345678910var CommentList = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentList\"&gt; &lt;Comment author=\"Pete Hunt\"&gt;This is one comment&lt;/Comment&gt; &lt;Comment author=\"Jordan Walke\"&gt;This is *another* comment&lt;/Comment&gt; &lt;/div&gt; ); &#125;&#125;); 現在我們使用類似 XML 的語法格式在 CommentList 放入一些子元素 Comment 和一些資料到屬性。每一個 &lt;Comment&gt; 表示一則留言訊息。在結構上資料是透過父元素傳給子元素的，要完成把資料傳給子元素有一個重要的方式叫做 props 就是 Properties 的縮寫，或者說可以透過 props 取得父元素的資料。 小筆記：邏輯上 CommentList 是整個留言列表所以資料會繫結到這個元件上，再透過迭代的方式去產生底下的 Comment 元件。上面的範例我們先使用 hardcode 的方式讓讀者理解概念。 使用 props建立 Comment 元件類別，它將會從 CommentList 讀取資料然後渲染標記。再複習一次整個 React 的架構就是分別建立各個元件，然後透過組合的方式來實現 reuse 的原則，設計上我們通常會讓父元素取得資料，這樣就可以在內部直接迭代渲染輸出 HTML 。而在取得資料的部分，通常我們會使用 React 提供的 props 來實現 。如下面範例： 123456789101112var Comment = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"comment\"&gt; &lt;h2 className=\"commentAuthor\"&gt; &#123;this.props.author&#125; &lt;/h2&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125;); 在 JSX 中透過大括號，你可以在裡面使用 Javascript 表示式（例如取得任何一個屬性或子元素）。你現在可以放入一些文字或 React 元件到這個結構中。然後我們可以透過屬性的名稱去存取資料，使用的方式是利用 this.props 或在這個巢狀結構下的任何元素 ex: this.props.children。 加入 Markdown 功能Markdown 是一種簡單的文字格式。舉個例子用 * 包圍的文字會變成斜體， HTML 中為強調語氣的語意。要增加這個功能我們可以使用第三方的函式庫 Showdown。透過這個函式庫可以把 Markdown 格式的文字轉換成 HTML。下面我們直接使用 CDN 上的檔案載入此函式庫。 1234567&lt;!-- template.html --&gt;&lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script src=\"http://fb.me/react-0.8.0.js\"&gt;&lt;/script&gt; &lt;script src=\"http://fb.me/JSXTransformer-0.8.0.js\"&gt;&lt;/script&gt; &lt;script src=\"http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 接著就可以在程式碼中使用它 12345678910111213var converter = new Showdown.converter();var Comment = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"comment\"&gt; &lt;h2 className=\"commentAuthor\"&gt; &#123;this.props.author&#125; &lt;/h2&gt; &#123;converter.makeHtml(this.props.children.toString())&#125; &lt;/div&gt; ); &#125;&#125;); 這邊我們呼叫了 Showdown 的函式庫，我們需要轉換 this.props.children ，讓他從 React 的換行文字先轉成純文字，接著 Showdown 就可以轉換。在這個過程中，我們通常會明確的呼叫 toString()。但是這邊有一個問題，我們輸出的留言看起來會變成 &lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; comment&lt;/p&gt;。我們希望這些標簽可以正確被的輸出成 HTML。這是 React 預設防止 XSS 攻擊的機制。這邊提供一種方式，但是框架會警告你不要使用它： 1234567891011121314var converter = new Showdown.converter();var Comment = React.createClass(&#123; render: function() &#123; var rawMarkup = converter.makeHtml(this.props.children.toString()); return ( &lt;div className=\"comment\"&gt; &lt;h2 className=\"commentAuthor\"&gt; &#123;this.props.author&#125; &lt;/h2&gt; &lt;span dangerouslySetInnerHTML=&#123;&#123;__html: rawMarkup&#125;&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 這是一個特殊的 API 企圖讓寫入 HTML 變得比較困難一點，但因為 Showdown 需要輸出 HTML 的關係我們必須要開一個後門。 提醒：使用這個功能你必須依賴 Showdown 本身的安全性，以及確保被轉換的資料不會有風險。 連結資料模型到目前為止，我們已經在程式碼直接寫入了一些留言，實務上我們的資料通常會從資料庫來，這邊我們用一些 JSON 格式的資料來模擬實際的狀況。 1234var data = [ &#123;author: \"Pete Hunt\", text: \"This is one comment\"&#125;, &#123;author: \"Jordan Walke\", text: \"This is *another* comment\"&#125;]; 在這邊我們會透過模組化的方式去取得資料，實務上舉例就是通常我們會取得一批資料傳給 CommentList 透過程式去一筆一筆輸出。避免使用 hardcode 的方式像上面的例子 &lt;Comment&gt;。修改 CommentBox 和 renderComponent() ，換成使用 props 取得資料後傳給 CommentList。 12345678910111213141516var CommentBox = React.createClass(&#123; render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.props.data&#125; /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;);React.renderComponent( &lt;CommentBox data=&#123;data&#125; /&gt;, document.getElementById('content')); 現在資料已經是透過 JSON 格式來取得了並且和 CommentList 繫結，接著就讓我們動態的輸出這些留言吧。 小筆記：撰寫 React 的時候概念上我們可以把 createClass 就理解成是在建立一個類別，renderComponent() 就是在實例化物件，此時該傳入的資料(參數)我們就透過標簽屬性(attributes)帶入。 123456789101112var CommentList = React.createClass(&#123; render: function() &#123; var commentNodes = this.props.data.map(function (comment) &#123; return &lt;Comment author=&#123;comment.author&#125;&gt;&#123;comment.text&#125;&lt;/Comment&gt;; &#125;); return ( &lt;div className=\"commentList\"&gt; &#123;commentNodes&#125; &lt;/div&gt; ); &#125;&#125;); 透過 map 函式去處理陣列，處理後的結果如下圖。從下面編譯過的程式碼，我們可以知道 React 會自動去迭代輸出陣列。 123456789101112var CommentList = React.createClass(&#123;displayName: 'CommentList', render: function() &#123; var commentNodes = this.props.data.map(function (comment) &#123; return Comment( &#123;author:comment.author&#125;, comment.text); &#125;); return ( React.DOM.div( &#123;className:\"commentList\"&#125;, commentNodes ) ); &#125;&#125;); 範例到此相信有經驗的開發者已經能夠掌握 React 的核心概念了。我們在從範例的角度說明到目前為止我們做了什麼：首先，我們建立了 CommentBox，在裡面部署了 CommentList 和 CommentForm 物件，CommentList 透過 this.props.data 從父元素 CommentBox 那邊取得資料。這個屬性把資料繫結到此物件上。接著在 CommentList 類別裡面我們用得到的資料組合出 Comment 的陣列，並讓 Comment 這個元件去負責每一則留言的呈現。最後我們又用了 CommentForm 元件來實踐送出留言的功能。對於一些比較少OOP經驗的開發者，模組化剛開始可能會覺得有點亂。筆者透過一張圖大略的說明整個基本的流程： 從伺服器取得資料讓我們移除寫死的資料改用一些從伺服器端來的動態資料。在這一步我們會透過 url 來取得資料。 1234React.renderComponent( &lt;CommentBox url=\"comments.json\" /&gt;, document.getElementById('content')); 這個元件將跟之前的不一樣，因為它必須要自己重新載入並輸出。一開始這個元件並沒有任何資料，直到發出的 Request 從伺服器取得資料，這個時候元件就需要重新渲染。在上面範例中我們只是單純地取得某個 JSON 檔案。 狀態回應到目前為止每一個元件都根據自身的 props 取得的資料渲染了一次，props 本身是靜態不會變動的。它們從父元素取得，而且是父元素擁有的。為了完成互動功能，需要-元件的狀態屬性 this.state 。這個屬性本身是 private ，只能透過呼叫 this.setState() 去更改。當狀態改變的時候，元件就會重新渲染輸出。render() 是用來處理關於 this.props 和 this.state 的資料。我們會把資料放在 props 和 state 裡面接著透過 render() 去處理該如何呈現。整個框架必須確保所有資料和UI上呈現的是一致的。當伺服器獲得資料，我們就需要把我們有的資料新增或修改到留言框上。接著讓我們加入一個留言資料的陣列到 CommentBox 的狀態屬性上。 1234567891011121314var CommentBox = React.createClass(&#123; getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;); getInitialState() 這個方法再整個元件的生命週期中只會執行一次，目的是用來設定初始化 this.state 的資料。按上面的例子就是你傳回了一個 {data: []} 物件給 this.state 。之後便可以使用 this.state.data 取得這個陣列。 更新狀態當元件第一次被建立的時候，我們想透過 GET 方式從伺服器取得一些 JSON 格式的資料，替 state 更新對應的最新資料。在實務上這通常是動態從資料庫，API 或其他服務取得，不過在這個例子為了簡化我們使用靜態的 JSON 檔案。在根目錄建立一個 comments.json 如下 1234[ &#123;\"author\": \"Pete Hunt\", \"text\": \"This is one comment\"&#125;, &#123;\"author\": \"Jordan Walke\", \"text\": \"This is *another* comment\"&#125;] 我們會搭配使用 jQuery 來協助我們發出非同步請求給伺服器，以取得資料。注意：因為加入 jQuery 這已經是一個 AJAX 應用程式，你會使用網頁伺服器來執行這個範例，而不是單純在瀏覽器執行檔案。最簡單的方式是在目錄下執行 python -m SimpleHTTPServer，或者熟悉 Grunt 的開發者可以使用grunt-init-simple-server。 1234567891011121314151617181920212223242526var CommentBox = React.createClass(&#123; getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentWillMount: function() &#123; $.ajax(&#123; url: 'comments.json', dataType: 'json', success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function(xhr, status, err) &#123; console.error(\"comments.json\", status, err.toString()); &#125;.bind(this) &#125;); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;); componentWillMount 方法會在元件渲染前自動被呼叫執行。在這個例子裡動態更新的關鍵是呼叫 this.setState() 。我們把本來的陣列資料移除，取代用從伺服器取得資料的方式，這裡為了保持簡單是使用 comments.json 。為了展示這種及時反應的效果，這邊加了一段程式碼達到輪詢的功能，意思是程式本身會不斷的重複去查詢 comments.json 的資料。 實務上你應該使用 secket.io 才不會造成效能很糟糕。 1234567891011121314151617181920212223242526272829303132var CommentBox = React.createClass(&#123; loadCommentsFromServer: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this) &#125;); &#125;, getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentWillMount: function() &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm /&gt; &lt;/div&gt; ); &#125;&#125;);React.renderComponent( &lt;CommentBox url=\"comments.json\" pollInterval=&#123;2000&#125; /&gt;, document.getElementById('content')); 我們把 AJAX 取得資料的片段獨立成一個方法，然後第一次載入的時候會呼叫一次，接著設定每兩秒執行一次。 新增留言是時候來建置我們的留言表單了，這個留言表單元件應該要詢問使用者他的名字和留言訊息，接著提交給伺服器儲存留言。 1234567891011var CommentForm = React.createClass(&#123; render: function() &#123; return ( &lt;form className=\"commentForm\"&gt; &lt;input type=\"text\" placeholder=\"Your name\" /&gt; &lt;input type=\"text\" placeholder=\"Say something...\" /&gt; &lt;input type=\"submit\" value=\"Post\" /&gt; &lt;/form&gt; ); &#125;&#125;); 表單運作的流程是：當使用者提交表單時，我們應該清除裡面的資料，接著發出一個 Reauest 給伺服器，最後更新留言列表。 1234567891011121314151617181920212223242526var CommentForm = React.createClass(&#123; handleSubmit: function() &#123; var author = this.refs.author.getDOMNode().value.trim(); var text = this.refs.text.getDOMNode().value.trim(); if (!text || !author) &#123; return false; &#125; // TODO: send request to the server this.refs.author.getDOMNode().value = ''; this.refs.text.getDOMNode().value = ''; return false; &#125;, render: function() &#123; return ( &lt;form className=\"commentForm\" onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" placeholder=\"Your name\" ref=\"author\" /&gt; &lt;input type=\"text\" placeholder=\"Say something...\" ref=\"text\" /&gt; &lt;input type=\"submit\" value=\"Post\" /&gt; &lt;/form&gt; ); &#125;&#125;); 事件：React 在元件上繫結事件是用 camelCase 命名規則，當表單驗證過並提交時我們使用了一個 onSubmit 事件來處理。這裡我們永遠回傳一個 false 來阻止瀏覽器預設的提交行為。（如果你比較喜歡透過 event 參數使用 e.preventDefault()，你也可以用它來取代 return false） Refs：使用 ref 屬性只設定子元素的名稱，就可以透過 this.refs 參考到該元件。我們可以呼叫 getDOMNode() 來取得原生的 DOM 元素。 透過 props 使用 callback：當使用者送出一則留言，我們將需要更新留言列表加入新的訊息， 在 CommentBox 實作這些邏輯是比較合理的，因為 CommentBox 負責掌控整個元件的狀態 this.state。所以在這個範例裡，我們需要從子元素把資料傳給父元素 CommentBox ，讓 CommentBox 去更新狀態，為了完成這個目的，我們在 props 放入一個 callback 函式，如此一來子元素便能透過呼叫這個函式把資料帶給父元素。看到這邊可能會有些混亂，沒關係讓我們先直接看 CommentBox 的程式碼: 1234567891011121314151617181920212223242526272829303132var CommentBox = React.createClass(&#123; loadCommentsFromServer: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this) &#125;); &#125;, handleCommentSubmit: function(comment) &#123; // TODO: submit to the server and refresh the list &#125;, getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentWillMount: function() &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 然後在 CommentForm 呼叫 1234567891011121314151617181920212223var CommentForm = React.createClass(&#123; handleSubmit: function() &#123; var author = this.refs.author.getDOMNode().value.trim(); var text = this.refs.text.getDOMNode().value.trim(); this.props.onCommentSubmit(&#123;author: author, text: text&#125;); this.refs.author.getDOMNode().value = ''; this.refs.text.getDOMNode().value = ''; return false; &#125;, render: function() &#123; return ( &lt;form className=\"commentForm\" onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" placeholder=\"Your name\" ref=\"author\" /&gt; &lt;input type=\"text\" placeholder=\"Say something...\" ref=\"text\" /&gt; &lt;input type=\"submit\" value=\"Post\" /&gt; &lt;/form&gt; ); &#125;&#125;); 總結上面敘述就是我們應該把處理寫入留言(提交到伺服器)的邏輯和程式碼寫在 CommentBox 元件裡面，就是 handleCommentSubmit 這個方法，接著透過 &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt; 的方式把方法傳給子元件 CommentForm ，CommentForm 有需要送出留言的時候就可以透過 this.props.onCommentSubmit() 去呼叫。資料統一都由父元素管理是比較合理的做法。到目前為止我們概略的了解關於狀態和資料還有處理的方法應該放在父元素，你可以在父元素裡面在放置其他元件，如果子元素需要動用父元素的功能或資料就透過屬性(attributes)帶入參數的方式傳進去。 現在讓我們來完成 callback 函式該執行的任務 12345678910111213141516171819202122232425262728293031323334353637383940var CommentBox = React.createClass(&#123; loadCommentsFromServer: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this) &#125;); &#125;, handleCommentSubmit: function(comment) &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', type: 'POST', data: comment, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this) &#125;); &#125;, getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentWillMount: function() &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 優化UI更新這個範例到這邊已經全部完成了(實際呼叫 AJAX 後端操作並沒有實作在範例裡)，但是感覺有點慢，因為我們必須要等待發出的 Request 完成處理留言才會出現。我們可以優化這個部分讓使用者感覺更快。 12345678910111213141516171819202122232425262728293031323334353637383940414243var CommentBox = React.createClass(&#123; loadCommentsFromServer: function() &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this) &#125;); &#125;, handleCommentSubmit: function(comment) &#123; var comments = this.state.data; var newComments = comments.concat([comment]); this.setState(&#123;data: newComments&#125;); $.ajax(&#123; url: this.props.url, dataType: 'json', type: 'POST', data: comment, success: function(data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this) &#125;); &#125;, getInitialState: function() &#123; return &#123;data: []&#125;; &#125;, componentWillMount: function() &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval); &#125;, render: function() &#123; return ( &lt;div className=\"commentBox\"&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125; /&gt; &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125; /&gt; &lt;/div&gt; ); &#125;&#125;); 上面這段程式碼的重點在加入 123var comments = this.state.data;var newComments = comments.concat([comment]);this.setState(&#123;data: newComments&#125;); 透過這段程式使用者的留言在送出時本地端就先更新了，再發出 Request 給伺服器。後續元件本身會自己在去跟伺服器讀取最新的資訊。 恭喜你已經完成建置這個留言框的功能，也初步對如何使用 React 有了認識，學習更多關於為什麼使用 React 或查閱 API 參考。 最後附上完成的範例程式碼：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;!-- template.html --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;script src=\"http://fb.me/react-0.8.0.js\"&gt;&lt;/script&gt; &lt;script src=\"http://fb.me/JSXTransformer-0.8.0.js\"&gt;&lt;/script&gt; &lt;script src=\"http://code.jquery.com/jquery-1.10.0.min.js\"&gt;&lt;/script&gt; &lt;script src=\"http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"content\"&gt;&lt;/div&gt; &lt;script type=\"text/jsx\"&gt; /** * @jsx React.DOM */ var converter = new Showdown.converter(); var data = [ &#123;author: \"Pete Hunt\", text: \"This is one comment\"&#125;, &#123;author: \"Jordan Walke\", text: \"This is *another* comment\"&#125; ]; var CommentBox = React.createClass(&#123; loadCommentsFromServer: function () &#123; $.ajax(&#123; url: this.props.url, dataType: 'json', success: function (data) &#123; this.setState(&#123;data: data&#125;); &#125;.bind(this), error: function (xhr, status, err) &#123; console.error('comments.json', status, err.toString()); &#125;.bind(this) &#125;); &#125;, handleCommentSubmit: function (comment) &#123; var comments = this.state.data; var newComments = comments.concat([comment]); this.setState(&#123;data: newComments&#125;); $.ajax(&#123; url: this.props.url, dataType: 'json', type: 'POST', data: comment, success: function (data) &#123; this.setState(&#123;data:data&#125;); &#125;.bind(this) &#125;); &#125;, getInitialState: function () &#123; return &#123;data: []&#125;; &#125;, componentWillMount: function () &#123; this.loadCommentsFromServer(); setInterval(this.loadCommentsFromServer, this.props.pollInterval) &#125;, render: function () &#123; return ( &lt;div className='commentBox'&gt; &lt;h1&gt;Comments&lt;/h1&gt; &lt;CommentList data=&#123;this.state.data&#125;/&gt; &lt;CommentForm onCommentSubmit=&#123;this.handleCommentSubmit&#125;/&gt; &lt;/div&gt; ); &#125; &#125;); /* var CommentBox = React.createClass(&#123; render: function () &#123; return ( React.DOM.div(&#123; className: 'commentBox', children: 'Hello, world! I am a CommentBox.!!!' &#125;) ); &#125; &#125;); */ var CommentList = React.createClass(&#123; render: function () &#123; var commentNodes = this.props.data.map(function (comment) &#123; return &lt;Comment author=&#123;comment.author&#125;&gt;&#123;comment.text&#125;&lt;/Comment&gt; &#125;); return ( &lt;div className='commentList'&gt; &#123;commentNodes&#125; &lt;/div&gt; ); &#125; &#125;); var CommentForm = React.createClass(&#123; handleSubmit: function () &#123; var author = this.refs.author.getDOMNode().value.trim(); var text = this.refs.text.getDOMNode().value.trim(); if (!text || !author) &#123; return false; &#125; this.props.onCommentSubmit(&#123;author: author, text: text&#125;); this.refs.author.getDOMNode().value= ''; this.refs.text.getDOMNode().value = ''; return false; &#125;, render: function () &#123; return ( &lt;form className='commentForm' onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type='text' placeholder='Your name' ref='author' /&gt; &lt;input type='text' placeholder='Say something' ref='text' /&gt; &lt;input type='submit' value=\"Post\" /&gt; &lt;/form&gt; ); &#125; &#125;); var Comment = React.createClass(&#123; render: function () &#123; var rawMarkup = converter.makeHtml(this.props.children.toString()); return ( &lt;div className='comment'&gt; &lt;h3 className='commentAuthor'&gt; &#123;this.props.author&#125; &lt;/h3&gt; &lt;span dangerouslySetInnerHTML=&#123;&#123;__html: rawMarkup&#125;&#125; /&gt; &lt;/div&gt; ); &#125; &#125;); React.renderComponent( &lt;CommentBox url='comments.json' pollInterval=&#123;2000&#125; /&gt;, document.getElementById('content') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"React 快速概覽","slug":"reactjs-getting-started","date":"2014-02-05T03:17:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/05/reactjs-getting-started/","link":"","permalink":"//andyyou.github.io/2014/02/05/reactjs-getting-started/","excerpt":"入門開始學習了解 React 的方式就是使用 JSFiddle 來觀察實作的範例： Hello Worlds。 React JSFiddle React JSFiddle without JSX","text":"入門開始學習了解 React 的方式就是使用 JSFiddle 來觀察實作的範例： Hello Worlds。 React JSFiddle React JSFiddle without JSX 下載入門套件下載入門範例與套件。 v0.8.0 解開壓縮檔後，在根目錄建立一個 helloworld.html 然後輸入下面的例子。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"build/JSXTransformer.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/jsx\"&gt; /** @jsx React.DOM */ React.renderComponent( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在 Javascript 裡面使用 XML 格式的語法叫做 JSX，這種語法是官方推薦的寫法。可以參考學習更多關於 JSX 的用法。為了使 JSX 可以正確的轉換為 Javascript 我們會使用 &lt;script type=&#39;text/jsx&#39;&gt; 標簽，以及記得要載入 JSXTransformer.js 以確保程式正確執行。在這邊我們會先提醒那些有程式開發經驗的學習者。不要忘記在一開始加入 /** @jsx React.DOM */，這不是一般註解，它是 React 用來定義要處理的 JSX 。如果你沒有加入這個片段，你的程式碼將不會被轉換。 獨立的檔案你的 React JSX 檔案可以是分開的獨立檔案。接著讓我們建立 src/helloworld.js 12345/** @jsx React.DOM */React.renderComponent( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); 然後在 helloworld.html 加入 1&lt;script type=\"text/jsx\" src=\"src/helloworld.js\"&gt;&lt;/script&gt; 即使是分開檔案功能仍然可以運行，這在大型專案中將有助于 DRY 原則，同樣功能的元件應該抽離獨立。 離線轉換 JSX安裝這個指令轉換工具（command-line）需要先安裝 npm。 1$ npm install -g react-tools 然後轉換 src/helloworld.js 檔案為原生 Javascript。 1$ jsx --watch src/ build/ 看看自動產生的 build/helloworld.js 如下，因為使用了 --watch 參數，你可以直接修改 JSX ，然後工具就會自動更新。指令的語法是 jsx --watch &lt;source directory&gt; &lt;output directory&gt; ，所以請不要指定到檔案。 12345/** @jsx React.DOM */React.renderComponent( React.DOM.h1(null, 'Hello, world!'), document.getElementById('example')); 注意註解的解析器是非常嚴格的;為了能夠提取 @jsx 修飾子，兩件事情必須遵守： @jsx 註解區塊必須要在檔案或程式碼的開頭，也必須是第一段註解。 註解的開頭必須是 /** （/* 和 // 將會不正常）。如果解析器找不到 @jsx註解區塊 輸出時就不會執行轉換。 讓我們接著更新 HTML 如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src=\"build/react.js\"&gt;&lt;/script&gt; &lt;!-- No need for JSXTransformer! --&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script src=\"build/helloworld.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意： type=&#39;text/jsx&#39; 要拿掉，否則無法運作。 使用 CommonJS如果你想要使用模組化的 React ， 請 fork 官方專案，然後執行 npm install 和 grunt，便可以產出遵循 CommonJS 規則模組化的程式碼。官方提供的 jsx 編譯工具可以整合可以簡單地整合到大部份的封裝系統。CommonJS 補充 下一步查閱官方教學和其他/examples範例目錄學習更多。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"//andyyou.github.io/tags/reactjs/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"MongoDB Quick Notes","slug":"mongodb-quick-notes","date":"2014-02-04T13:40:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/02/04/mongodb-quick-notes/","link":"","permalink":"//andyyou.github.io/2014/02/04/mongodb-quick-notes/","excerpt":"","text":"Mac123456789101112131415$ brew update # 更新 brew$ brew install mongodb # 安裝 MongoDB$ brew upgrade mongodb # 更新 MongoDB$ mongod # 啟動 MongoDB Server$ mongo # 連線到 localhost:27017/test ，不需帳密。* 27017 預設 port* 28017 Web 界面 MongoDB Server 資訊類似 PHP Admin 。&lt;!--more--&gt;$ mkdir -p /data/db # 建立資料庫儲存的目錄。$ chown `id -u` /data/db # 授權當前使用者目錄權限。$ id -u # 列出當前使用者 uid$ sudo plutil -p /var/db/dslocal/nodes/Default/users/[YourAccount].plist # OSX 底下的 /etc/shadow 。$ mongod --dbpath /data/db # 設定資料庫資料目錄。 基本對照 SQL MongoDB database database table collection row(record) documents column field(key) value value Mongo shell db 當前使用的資料庫。 show dbs 資料庫列表。 show collections 資料表清單。 use [dbname] 切換使用目標資料庫。 db.getSlibingDB(&#39;dbname&#39;) 取得資料庫參考物件。 db.dropDatabase() # 移除資料庫。 db.addUser( { user: &quot;&lt;user&gt;&quot;, pwd: &quot;&lt;password&gt;&quot;, roles: [&lt;roles&gt;] } ) # 加入使用者 db.auth(&#39;id&#39;, &#39;pwd&#39;) # 登入認證身份。 printjson(obj) 將物件以 JSON 格式輸出。 db.createCollection(name, {capped: &lt;Boolean&gt;, autoIndexId: &lt;Boolean&gt;, size: &lt;number&gt;, max &lt;number&gt;} ) # 建立集合，主要的功能是用來開固定式集合，固定式集合不能刪除 Row，但可以移除整個資料表，一旦 capped 設為 true 就要指定 size，但如果要限制則必須在指定 max 。一旦超出 max 舊的資料就會被覆寫。 db.collection.drop() # 移除資料表。 db.collection.ensureIndex({name: [1|-1]}) # 建立索引 db.collection.getIndexes() # 取得索引 db.collection.dropIndex({name: 1}) # 移除索引 其他資料snapshotPerformanceMuninIndexesB+TreeDistributed SystemAggregateSQL 到 MongoDB 對應表 Basic toturial","categories":[{"name":"Database","slug":"Database","permalink":"//andyyou.github.io/categories/Database/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"//andyyou.github.io/tags/mongodb/"}],"keywords":[{"name":"Database","slug":"Database","permalink":"//andyyou.github.io/categories/Database/"}]},{"title":"MongoDB 快速入門筆記","slug":"mongodb-notes","date":"2014-01-29T05:13:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/01/29/mongodb-notes/","link":"","permalink":"//andyyou.github.io/2014/01/29/mongodb-notes/","excerpt":"安裝12$ brew update$ brew install mongodb","text":"安裝12$ brew update$ brew install mongodb 更新12$ brew update$ brew ugrade mongodb 啟動 mongodb1234$ mkdir -p /data/db /* 建立預設 `dbpath` */$ chown `id -u` /data/db /* 修改目錄權限 */$ mongod /* 啟動 */$ mongod --dbpath &lt;some alternate directory&gt; /* 使用替代路徑啟動 */ 停止Control+C 連線資料庫123$ mongo # 預設連限制 localhost:27017$ mongo --hostname 0.0.0.0 --port 27017 # 遠端連線$ mongo [hostname]:[port]/[dbname] # 遠端連線 注意：剛建立好時，沒有帳密限制。如果你只使用 mongo 連線至資料庫時，預設會使用 test 這個資料庫。在 mongo shell 環境下使用 db 指令可以尋當前的資料庫。 常用指令 db 列出當前的資料庫名稱。 show dbs 列出資料庫清單。 use mydb 切換資料庫。 db.auth(&#39;account&#39;, &#39;password&#39;) 登入身份。 help 顯示協助訊息。 show collections 列出資料表。 mongo &lt;dbname&gt; --eval &quot;db.dropDatabase()&quot; 移除 database。或者下面這種方式： 12$ use mydb;$ db.dropDatabase(); DBQuery.shellBatchSize = x 讀取資料時迭代一次取回幾筆資料。 printjson() 將 document 以 JSON 格式輸出。 提醒一個 MongoDB 的機制，包含預設連到的 test 或建立的新資料庫，只要裡面沒有資料，MongoDB 並不會永久地保存該資料庫。 建立一個集合(collection)並插入一筆資料(document)在第一次使用 MongoDB 的時候預設會在背後自動建立一個集合(collection)或稱為隱含方式建立，collection對應傳統關聯式資料庫的說法這就是一個 table。參考這篇文章也許可以幫助你快速從關聯式資料庫轉換到 MongoDB SQL 到 MongoDB 對應表。在你插入任何一筆資料之前你是不需要自己建立集合。又因為 MongoDB 是動態式架構(schema)。所以在建立一筆資料之前你也不需要事先定義 schema。這樣說可能有 SQL 經驗的人會覺得很抽象詭異。讓我們執行下面的實作例子： 在 mongo shell 環境下，執行 db，這時他應該要傳回 mydb 。 如果你之前並沒有照著上面文章執行那請使用 use mydb 來切換資料庫。 建立兩筆資料(document) j，k 12j = &#123; name : \"mongo\" &#125;k = &#123; x : 3 &#125; 將 j, k 兩筆資料插入 testData 集合(資料表) 12db.testData.insert(j);db.testData.insert(k); 當你建立資料的此刻， mongo 會自動幫你建立集合(testData)並且把資料寫入，此外你也可以透過 db.createCollection(&quot;testData&quot;) 明確的自己建立集合，或者稱之為資料表你會比較習慣。 驗證 testData 集合是否存在，列出資料表。 1$ show collections 此時你應該會看到兩個集合 system.indexes，testData。 system.inidexs 是每個資料庫都會有的集合。 確認 testData 中是否有資料。 1db.testData.find(); 這個操作之後你應該會看到 12&#123; \"_id\" : ObjectId(\"4c2209f9f3924d31102bd84a\"), \"name\" : \"mongo\" &#125;&#123; \"_id\" : ObjectId(\"4c2209fef3924d31102bd84b\"), \"x\" : 3 &#125; 上面這個操作就等於 SQL 中的 select。mongo document或者說每一筆資料都會有 _id 他會有一個唯一的 hash 值。上面這些操作並沒有明確指定 _id 的值，所以 mongo 預設會替一個物件產生 id 。為了讓我們能夠實際的執行測試某些 mongo 指令，在官方文件提供了產生測試資料的教學 12for (var i = 1; i &lt;= 25; i++) db.testData.insert( &#123; x : i &#125; )db.testData.find() 在一般情況下我們會使用 db.tableName.insert() 然而 db 指的是目前所在的資料庫 。如果要快速在不同的資料庫，集合中建立資料，官方文件也提供 function 的方式： 1234567function insertData(dbName, colName, num) &#123; var col = db.getSiblingDB(dbName).getCollection(colName); for (i = 0; i &lt; num; i++) &#123; col.insert(&#123;x:i&#125;); &#125; print(col.count());&#125; 一般 mongo shell 中使用查詢資料，並不是一次傳回所有的資料。 MongoDB 的運作機制是他會先傳回一個指標物件，這個物件一次只會先包含 20 筆資料，如果你要檢視更多資料則輸入 it 繼續。而這個 20 筆資料是可以設定的，執行 DBQuery.shellBatchSize 可以看到目前的值，要修改的話就給他一個值 DBQuery.shellBatchSize = 25。 讓我們直接透過官方教學的步驟來體驗一下 mongo 1. 在 mongo shell 環境下執行1var c = db.testData.find(); c 會取得一個指標物件。 2. 透過迴圈列出所有的資料1while ( c.hasNext() ) printjson( c.next() ) 另外當你只輸入 c 的時候會輸出這個指標物件的內容，接著會提示如果要繼續檢視下面的內容就輸入 it 。 3. 使用陣列方式操作指標物件12var c = db.testData.find();printjson( c [ 4 ] ); 查詢指定的記錄(documents)MongoDB 本身擁有非常豐富的查詢機制讓我們可以過濾找到需要資料。如果你本身已經俱有 SQL 相關技能那可以參考這兩篇教學SQL 到彙總(Aggregation)對應表SQL 到 MongoDB 對應表。透過傳遞一個物件參數，我們可以找到 testData 中的特定筆資料。例如： 1db.testData.find(&#123; x : 18 &#125;); 從集合中取得一筆資料1db.testData.findOne(); 限制查詢數量為了程式的效能問題你可以限制每次查詢傳回的資料數量。 1db.testData.find().limit(3); 資料文件(documents)在 MongoDB 中我們稱一筆資料為 documents 類似于關聯式資料庫中的一筆 record，MongoDB 儲存資料的格式類似 JSON，使用鍵值對應。 documents 類似程式語言中的 structures 關聯一個 key 和 value。透過 key 值就可以對應找到 value，在其他程式語言中也有類似功能的東西。例如 dictonaries, hashes, maps 等等。關於這個 document 正式的名稱稱為 BSON。它是一個二進制格式的 JSON 檔案。 集合(collections)接著 MongoDB 把這些 documents 存在一個 collections 裡面。一個 collection 是一個群組用來關聯這些 documents。它們共用一個通用的索引。collections 類似于關聯式資料庫的 table。 資料庫操作查詢讓我們直接透過一個實際的範例來大概了解關於 MongoDB 查詢一筆特定資料的語法： 1db.users.find(&#123;age: &#123;$gt: 18&#125;&#125;).sort(&#123;age: 1&#125;) db 目前使用的資料庫。users 資料表。find() 查詢 = select。{age: {$gt: 18}} 條件 = age 這個欄位要 &gt; 18 。sort 排序。{age:1} 使用 age 這個欄位來排序，1 的用意是正向排序 ASC，如果要反向排序則用 -1 DESC 。 有了整體基本架構的了解之後相信就能快速上手了。 資料修改資料修改包含了 CRUD 的操作就是新增，讀取，更新，刪除。在 MongoDB 中這些操作是針對單一集合。跟 SQL 一樣更新或刪除一樣是可以指定條件。例如下面的例子建立一筆資料： 1db.users.insert(&#123;name: 'Andy', age: 18&#125;);","categories":[{"name":"Database","slug":"Database","permalink":"//andyyou.github.io/categories/Database/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"//andyyou.github.io/tags/mongodb/"}],"keywords":[{"name":"Database","slug":"Database","permalink":"//andyyou.github.io/categories/Database/"}]},{"title":"Develop environment install note","slug":"develop-environment-install","date":"2014-01-28T04:06:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/01/28/develop-environment-install/","link":"","permalink":"//andyyou.github.io/2014/01/28/develop-environment-install/","excerpt":"Solarized SublimeText 3 Document","text":"Solarized SublimeText 3 Document SublimeText 3 Tips SublimeText 3 Theme SublimeText 3 Javascript plugin iTerm2 iTerm2 Color Themes iTerm2 login with zsh oh-my-zsh 備註：會直接詢問密碼強迫更改成 default zsh ，使用 iTerm2 建議不要直接改成預設。接著在~/.zshrc修改樣板爲agnoster並在最下方補上 export DEFAULT_USER=[name]。 1$ chsh -s /bin/bash # Mofidy to default bash 1export DEFAULT_USER=\"\" 1234\"caret_style\": \"phase\",\"caret_extra_bottom\": 0,\"caret_extra_top\": 0,\"caret_extra_width\": 2, ~/.ssh/config","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"osx","slug":"osx","permalink":"//andyyou.github.io/tags/osx/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"grunt-init 使用教學與 grunt-init-simple-server","slug":"grunt-init","date":"2014-01-26T04:13:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2014/01/26/grunt-init/","link":"","permalink":"//andyyou.github.io/2014/01/26/grunt-init/","excerpt":"在開始如何製作自己的 grunt-init 樣板的教學之前，先分享grunt-init-simple-server。由於小弟玩性太重三天兩頭就喜歡換 framework 所以才寫了這個簡單的 grunt task。可以方便在學習新的前端技術的時候快速地幫專案加上一個簡易地 server。","text":"在開始如何製作自己的 grunt-init 樣板的教學之前，先分享grunt-init-simple-server。由於小弟玩性太重三天兩頭就喜歡換 framework 所以才寫了這個簡單的 grunt task。可以方便在學習新的前端技術的時候快速地幫專案加上一個簡易地 server。 Grunt-init 是一個用來自動建立專案架構的工具，它協助我們根據目前的環境以及建立過程中詢問一些設定項目來建立整個專案的架構。就像我們使用 IDE 如 Visual Studio 建立專案一樣，透過詢問你一些選項後建立該專案。 安裝1$ npm install -g grunt-init 使用方式 grunt-init --help 列出已安裝可以使用的樣板。 grunt-init [TEMPLATE] 建立指定類型的專案。 grunt-init /path/to/TEMPLATE 建立指定路徑樣板的專案。 上面所謂的樣板（template）其實就是『專案類型』，更白話文的說就是指定的『目錄架構』注意：大部份的樣板都是產生檔案或目錄到目前所在的目錄，所以在使用的時候請確認這是一個新目錄或者目錄裡的檔案不會被複寫。 安裝樣板（專案類型）一般來說樣板會安裝在你的 ~/.grunt-init 目錄裡，在 Window 中是 %USERPROFILE%\\.grunt-init\\一旦安裝完成，接著你會透過 grunt-init [TEMPLATE] 來建立專案。這邊舉個例子安裝 jquery 專案類型的話就是執行 1$ git clone https://github.com/gruntjs/grunt-init-jquery.git ~/.grunt-init/jquery 通常我們會透過 git 來安裝。整體來說 template 只不過是事先將一些樣板產生的 script 放置在~/grunt-init 目錄底下，透過 git 來安裝的話，之後可以輕鬆的更新升級。 注意：如果你想要將樣板安裝到本地，並且可以透過 grunt-init --help 來列出已安裝的樣板的話。例如：你想指定專案類型為 foobarbaz ，那你只要把樣板目錄安裝到指定目錄 ~/grunt-init/foobarbaz 即可。 下面是一些官方維護的樣板專案，您可以試著安裝並使用看看： grunt-init-commonjs 建立 CommonJS 模組，包含 Nodeunit unit test。 grunt-init-gruntfile 單純透過詢問選項建立 Gruntfile，最單純也最實用的。 grunt-init-gruntplugin 建立一個 Grunt 套件。 grunt-init-jquery 建立 jQuery 套件專案，包含 QUnit unit test。 grunt-init-node 大部份的狀況下 grunt-init 幫我們處理掉許多初始專案的東西，如果沒有你可能要使用npm init，bower init，建立 Gruntfile.js ，當然如果你是使用 framework 如：Sails那它可能都幫你處理完這些項目。 自定樣板您當然可以自己建立客製化的樣板，但是你的樣板必須遵循上述一樣的結構。舉例來說一個基本的樣板叫 my-template 就必須遵循下面的檔案結構： my-template/template.js 主要的樣板檔案，所有的選項提問，處理複製哪些檔案都在這隻程式處理。 my-template/rename.js 更改一些檔案的名稱設定，所有的命名規則在這邊設定。 my-template/root/ 所有要被複製檔案都存放在這，就是在產生專案時大部份預設檔案都是從這邊來的。 假設上面說的這些檔案和目錄都已經在 /path/to/my-template 那你就可以使用 grunt-init /path/to/my-template 來建立專案了。此外，只要你這個目錄放在 ~/.grunt-init 目錄底下，那你可以直接使用 grunt-init my-template 來建立。 複製檔案 Copying files只要樣板使用 init.filesToCopy 和 init.copyAndProcess 方法，任何在 root/ 目錄底下的檔案都會被複製到目前的目錄。 注意：所有被複製的檔案都會被當作模板來處理。例如： grunt-init-jquery 專案裡 /root/src/name.js 檔案中的第五行 123&#123;% raw %&#125; Copyright (c) &#123;%= grunt.template.today('yyyy') %&#125; &#123;%= author_name %&#125;&#123;% endraw %&#125; 除非你使用了 noProcess 設定，不然所有檔案都會經過上面的處理。 修改檔案名稱或排除檔案關於 rename.json 是用來描述來源檔案路徑和目的檔案路徑變更檔名的對應規則。來源檔案名稱必須要對應于 root 目錄。你可以參考 [grunt-init-jqueryplugin](https://github.com/gruntjs/grunt-init-gruntplugin/blob/master/rename.json) 的 rename.json。 設定預設詢問項目答案每一個 prompt 詢問你的問題都會有一個預設值，它通常是設死的或者根據環境設定取得的值。如果你要設定這些預設值你可以在 ~/.grunt-init/defaults.json 裡面去設定。下面有一個簡單的範例： 12345&#123; \"author_name\": \"\\\"Cowboy\\\" Andy You\", \"author_email\": \"none\", \"author_url\": \"http://passer.cc/\"&#125; 定義初始化的資訊exports.description這是一個簡短的樣板描述，當使用者執行 grunt-init 會顯示在列表。 1exports.description = descriptionString; 注意：任何一個樣板有錯誤的時候會導致執行 grunt-init 產生錯誤訊息。 exports.note如果啟用此設定，當開始執行項目詢問時，將會增加額外的訊息描速。這裡是你可以給使用者一些有用的訊息的地方，例如：哪些欄位是必要的選項。 1exports.notes = notesString; exports.warnOn警告功能，利用萬用字元表示式或者陣列去比對目錄中已存在的檔案，一旦符合規則發現檔案存在就會中斷專案的建立。不過一旦使用者使用 --force 參數，將會繼續執行，這可能會覆蓋掉以存在的檔案。這個功能非常實用，可以協助避免覆蓋掉一些已存在的檔案。 1exports.warnOn = wildcarPattern; 最常見的方式是使用 * 去匹配大部分名稱的檔案。舉例來說 *.js 可以匹配目錄底下所有的 js 檔案。下面是一些常用的範例： 12345678910exports.warnOn = 'Gruntfile.js'; // Warn on a Gruntfile.js file.exports.warnOn = '*.js'; // Warn on any .js file.exports.warnOn = '*'; // Warn on any non-dotfile or non-dotdir.exports.warnOn = '.*'; // Warn on any dotfile or dotdir.exports.warnOn = '&#123;.*,*&#125;'; // Warn on any file or dir (dot or non-dot).exports.warnOn = '!*/**'; // Warn on any file (ignoring dirs).exports.warnOn = '*.&#123;png,gif,jpg&#125;'; // Warn on any image file.// This is another way of writing the last example.exports.warnOn = ['*.png', '*.gif', '*.jpg']; exports.templateexports 最重要的便是爲 template 這個屬性定義一個 function ，所有實際執行的初始化動作都寫在這個 function 裡面 。有三個你可以使用的參數分別是 grunt，init，done。grunt 參數參考至 grunt。包含了所有 grunt 你能使用的函式庫，例如：grunt.file.read()。 init 參數是一個物件，主要包含關於 template 相關的屬性和方法。done 是一個 function 當樣板建立的步驟執行完成的時候便呼叫他。 初始化樣板內部接下來這些 init.method 都是在 exports.template = function (grunt, init, done) 函式中執行的使用的。如果有些 method 文件寫得不清楚的話請直接參考原始碼 init.addLicenseFiles自動產生 License 檔案。如果你的專案不是 MIT 其他授權可以參考這邊的縮寫。 1234var files = &#123;&#125;;var licenses = ['MIT'];init.addLicenseFiles(files, licenses);// files === &#123;'LICENSE-MIT': 'licenses/LICENSE-MIT'&#125; init.availableLicenses真正可用的 Licenses 可以使用這個 method 列表。 12var licenses = init.availableLicenses();// licenses === [ 'Apache-2.0', 'GPL-2.0', 'MIT', 'MPL-2.0' ] init.copy給定一個來源路徑（絕對/相對）和可選的相對目標路徑，就可以複製到目前的目錄下。至於 options 參數的用法直接參考 grunt.file.copy()。 1234567891011121314var options = &#123; // If an encoding is not specified, default to grunt.file.defaultEncoding. // If null, the `process` function will receive a Buffer instead of String. encoding: encodingName, // The source file contents and file path are passed into this function, // whose return value will be used as the destination file's contents. If // this function returns `false`, the file copy will be aborted. process: processFunction, // These optional globbing patterns will be matched against the filepath // (not the filename) using grunt.file.isMatch. If any specified globbing // pattern matches, the file won't be processed via the `process` function. // If `true` is specified, processing will be prevented. noProcess: globbingPatterns&#125;; init.copyAndProcess遍歷 files 物件然後一個一個傳遞處理，作用就是複製來源檔案到目的，並且處理內容。 1init.copyAndProcess(files, props[, options]) init.defaults使用者在 defaults.json 中設定的預設值。 init.destpath當前目錄的絕對路徑，也就是所謂目的地目錄的路徑。 init.expand用法和 grunt.file.expand 相同。傳回一個唯一的陣列，包含所有檔案，目錄的路徑，這些路徑會根據之前文章提到 grunt 處理檔案的匹配方式一樣。這個方法允許你使用 , 分隔萬用字元匹配表示式，或者使用一個陣列來存放這些匹配模式的表示式。另外如果使用 ! 會排除匹配成功的路徑。最後這些匹配模式是會照順序處理的，如果先被排除了後面就不會再被匹配到。 init.filesToCopy傳回一個包含欲複製檔案的絕對路徑和相對路徑的物件，並依照 rename.json 的規則重新命名。 1234567var files = init.filesToCopy(props);/* files === &#123; '.gitignore': 'template/root/.gitignore, 'jshintrc': 'template/root/.jshintrc', 'Gruntfile.js': 'template/root/Gruntfile.js', 'README.md': 'template/root/README.md', 'test/test_test.js': 'template/root/test/name_test.js' &#125; */ init.getFile取得一個任務檔案路徑。原始碼 init.getTemplates傳回一個包含現有可用的樣板資訊的物件。 init.initSearchDirs在初始化目錄中搜尋初始化樣板， template 指的是本機的樣板，通常包含 ~/.grunt-init 目錄和 grunt-init 中的核心初始化的任務。 init.process啟動初始化並開始輸入提示選項。 12345678910init.process(options, prompts, done);init.process(&#123;&#125;, [ //Prompt for these values init.prompt('name'), init.prompt('description'), init.prompt('version')], function(err, props)&#123; // All finished, do something with the properties&#125;); init.prompt顯示一道問答項目選擇。 1init.prompt(name[, default]) init.prompts傳回一個包含所有 prompt 提示問答值的物件。 init.readDefaults從任務檔案中讀取預設 JSON ，整合他們至 data object。 init.renamesrename.json 的物件。 init.searchDirs搜尋樣板路徑目錄的陣列。 init.srcpath根據檔案名稱搜尋初始化模板並回傳一個絕對路徑。 init.userDir傳回用戶樣板目錄的絕對路徑 12var dir = init.userDir();// dir === '/Users/shama/.grunt-init' init.writePackageJSON在目的地目錄寫入一個 package.json。 callback 函式可以用於後來在處理屬性新增/刪除/其他操作。 內建提示author_emailpackage.json 中作者的 Email，預設情況下會嘗試從用戶的 git config 中找到預設值。 author_namepackage.json 作者全名。 authro_url作者相關的網址 bin專案根目錄中 cli script 的相對路徑。 bugs追蹤專案 bug 的公開 URL description專案描速 grunt_version項目有效的 grunt 版本 homepage專案的首頁網址 jquery_version如果是 jQuery 專案的話，表示所需要的 jquery 版本。 licenses授權協議，內建的有 MIT，MPL-2.0，GPL-2.0，Apache-2.0。 main專案的 entry point name專案名稱 node_version專案所需的 node 版本 npm_test專案執行測試的命令。 repository專案的 git title專案名稱 version版本","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"grunt","slug":"grunt","permalink":"//andyyou.github.io/tags/grunt/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"KineticJS 建立範圍選取功能","slug":"kineticjs-establish-a-range-selection-function","date":"2013-11-28T06:17:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/11/28/kineticjs-establish-a-range-selection-function/","link":"","permalink":"//andyyou.github.io/2013/11/28/kineticjs-establish-a-range-selection-function/","excerpt":"KineticJS 介紹KineticJS 是一套針對 canvas 設計的函式庫，使得我們在操作使用 canvas 的時候相對簡單易懂。這篇文章將會教您如何透過 KineticJS 在螢幕上（canvas）建立一些物件，然後可以透過拖拉選取範圍。","text":"KineticJS 介紹KineticJS 是一套針對 canvas 設計的函式庫，使得我們在操作使用 canvas 的時候相對簡單易懂。這篇文章將會教您如何透過 KineticJS 在螢幕上（canvas）建立一些物件，然後可以透過拖拉選取範圍。 背景如果您還不了解 HTML5 canvas 標簽，請先閱讀HTML5 Canvas Tutorials。如果您還不知道什麼是 KineticJS 請先至官網 閱讀基本教學。這篇文章是針對 KineticJS v4.7.4。 程式碼說明在這個範例中，將會在 canvas 建立三個方塊，然後可以選取它們。首先呢，您必須在 html 中有一個 container 1&lt;div id='container'&gt;&lt;/div&gt; 接著建立 stage 和 layer ，這部分如果您不能理解請先參考基本教學。簡單的說明，透過 Kinetic 來操作 canvas我們一般會建立一個 stage 和 layer ，透過 layer 包含各種圖形物件，stage 包含 layer 分層的方式來組織 canvas 123456var stage = new Kinetic.Stage(&#123; container: 'container', width: 100, height: 100&#125;);var layer = new Kinetic.Layer(); 為了完成我們的功能，第一個技巧是在整個 layer 放入一張全滿透明的方形物件，這物件是用來判斷當使用者點擊滑鼠的時候可以開始進行拖曳以及放開的時候做些對應的處理。 123456789var rectBackground = new Kinetic.Rect(&#123; x: 0, y: 0, height: stage.attrs.height, width: stage.attrs.width, fill: 'transparent', draggable: false, name: 'rectBackground'&#125;); 現在我們可以加入上面說的方形物件。 1234567891011121314151617181920212223242526272829303132333435363738394041DrawBlocks();function DrawBlocks() &#123; var x, y, heigth; x = 90; y = 10; size = 40; CreateBlock(x, y, size, size, 'green'); x = 150; y = 80; CreateBlock(x, y, size + 20, size + 60, 'red'); x = 110; y = 170; CreateBlock(x, y, size, size, 'blue'); layer.draw();&#125;function CreateBlock(x, y, height, width, color) &#123; var grpBlk = new Kinetic.Group(&#123; x: x, y: y, height: height, width: width, name: color, draggable: true &#125;); var blk = new Kinetic.Rect(&#123; x: x, y: y, height: height, width: width, fill: color, name: color + ' block' &#125;); grpBlk.add(blk); blk.setAbsolutePosition(x, y); grpBlk.setAbsolutePosition(x, y); layer.add(grpBlk); return grpBlk;&#125; 這個範例讓我們可以透過拖拉滑鼠建立一個選取方塊，為了做到這點我們需要一些變數的協助。 123456var arSelected = new Array(); // 陣列是用來保存被選取到的 block 的名稱。var bDragging = false; // 當程式正在透過滑鼠拖拉計算方塊的大小時避免程式又從新執行。var bHaveSelBox = false; var rectSel = null; // 最終看到的選取方形var initX = 0; // 初始的 x, y 坐標。var initY = 0; 現在我們需要介紹一些處理事件，第一件要做的事情是我們需要截取當滑鼠點擊的那一瞬間。 123rectBackground.on('mousedown', function(evt) &#123; bDragging = true;&#125; 接著，當滑鼠開始移動拖拉，我們需要重新產生選取方塊。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859stage.getContent().addEventListener('mousemove', function(e) &#123; if (bDragging) &#123; SetSelRectPosition(e); &#125;&#125;);var bInHere = false; // 防止事件重新被執行。function SetSelRectPosition(e) &#123; if (bDragging &amp;&amp; !bInHere) &#123; bInHere = true; var canvas = layer.getCanvas(); var mousepos = stage.getPointerPosition(); var x = mousepos.x; var y = mousepos.y; if (!bHaveSelBox) &#123; initX = x; initY = y; rectSel = new Kinetic.Rect(&#123; x: initX, y: initY, height: 1, width: 1, fill: 'transparent', stroke: 'black', strokeWidth: 1 &#125;); layer.add(rectSel); layer.draw(); bHaveSelBox = true; &#125; else &#123; var height = 0; var width = 0; var newX = 0; var newY = 0; if (x &gt; initX) newX = initX; else newX = x; if (y &gt; initY) newY = initY; else newY = y; height = Math.abs(Math.abs(y) - Math.abs(initY)); width = Math.abs(Math.abs(x) - Math.abs(initX)); rectSel.setHeight(height); rectSel.setWidth(width); rectSel.setX(newX); rectSel.setY(newY); layer.draw() &#125; &#125; bInHere = false;&#125; 接著當使用者放掉滑鼠按鍵時，我們需要計算哪些物件被選取了然後把它們的名稱放到 arSelected 陣列。稍後我們就可以拿這個清單去做高亮等處理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263stage.getContent().addEventListener('mouseup', function(e) &#123; if (bDragging) &#123; bDragging = false; GetOverlapped(); if (rectSel != null) rectSel.remove(); rectSel = null; bHaveSelBox = false; layer.draw(); &#125;&#125;);function GetOverlapped()&#123; if (rectSel == null) &#123; return ; &#125; var iHeight = 0; var iWidth = -1000; arSelected.length = 0; initX = 10; initY = 10; var arGroups = layer.getChildren(); for (var i=0; i&lt;arGroups.length; i++) &#123; var grp = arGroups[i]; if (grp.attrs.name != rectSel.attrs.name &amp;&amp; grp.attrs.name != rectBackground.attrs.name grp.attrs.name != 'btn' &amp;&amp; grp.attrs.name != 'highlightBlock') &#123; var pos = rectSel.getAbsolutePosition(); var selRecXStart = parseInt(pos.x); var selRecXEnd = parseInt(pos.x) + parseInt(rectSel.attrs.width); var selRecYStart = parseInt(pos.y); var selRecYEnd = parseInt(pos.y) + parseInt(rectSel.attrs.height); var grpXStart = parseInt(grp.attrs.x); var grpXEnd = parseInt(grp.attrs.x) + parseInt(grp.attrs.width); var grpYStart = parseInt(grp.attrs.y); var grpYEnd = parseInt(grp.attrs.y) + parseInt(grp.attrs.height); if ((selRecXStart &lt;= grpXStart &amp;&amp; selRecXEnd &gt;= grpXEnd) &amp;&amp; (selRecYStart &lt;= grpYStart &amp;&amp; selRecYEnd &gt;= grpYEnd)) &#123; if (arSelected.indexOf(grp.getName()) &lt; 0) &#123; arSelected.push(grp.getName()); var tmpX = parseInt(grp.attrs.x); var tmpY = parseInt(grp.attrs.y); var rectHighlight = new Kinetic.Rect(&#123; x: tmpX, y: tmpY, height: grp.attrs.height, width: grp.attrs.width, fill: 'transparent', name: 'highlightBlock', stroke: '#41d6f3', strokeWidth: 3 &#125;); layer.add(rectHighlight); &#125; &#125; &#125; &#125;&#125; 最後當使用者在背景點一下要取消選取，或者選取單一方塊 1234567891011121314151617181920212223stage.getContent().addEventListener('mousedown', function(e) &#123; if(arSelected.length &gt; 0) &#123; var name = ''; if (e.shape != undefined) name = e.shape.attrs.name; if (e.targetNode != undefined) name = e.targetNode.attrs.name; if (name != 'btn') RemoveHighlights(); &#125;&#125;);function RemoveHighlights()&#123; var arHighlights = layer.get('.highlightBlock'); while (arHighlights.length &gt; 0) &#123; arHighlights[0].remove(); arHighlights = layer.get('.highlightBlock'); &#125; arSelected.length = 0;&#125; 在這個範例中我們會在增加一個按鈕可以用來取得關於被選取物件的資料 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758x = 85;y = 250;var grpGetSelectedButton = CreateButton(x, y, \"Get Selected\");grpGetSelectedButton.on(\"click\", function (evt) &#123; ShowSelected(); &#125;);function CreateButton(x, y, text)&#123; var grpButton = new Kinetic.Group(&#123; x: x, y: y, height: 30, width: 135, name: 'btn', draggable: true &#125;); var blkButton = new Kinetic.Rect(&#123; x: x, y: y, height: 30, width: 135, fill: 'Violet', name: 'btn' &#125;); var txtButton = new Kinetic.Text(&#123; x: x + 2, y: y + 2, fontFamily: 'Calibri', fontSize: 22, text: text, fill: 'black', name: 'btn' &#125;); grpButton.add(blkButton); grpButton.add(txtButton); grpButton.setAbsolutePosition(x, y); blkButton.setAbsolutePosition(x, y); txtButton.setAbsolutePosition(x + 2, y + 2); layer.add(grpButton); return grpButton;&#125;function ShowSelected()&#123; var str = \"\"; for (var i = 0; i &lt; arSelected.length; i++) &#123; str += arSelected[i] + \", \"; &#125; if (str != \"\") str = str.substring(0, str.length - 2); alert(str);&#125;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"PHP 環境 OSX 10.9","slug":"osx-php-environment-109","date":"2013-10-29T12:04:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/10/29/osx-php-environment-109/","link":"","permalink":"//andyyou.github.io/2013/10/29/osx-php-environment-109/","excerpt":"更新 Mavericks 小牛之後會發現 httpd.conf 被取代了。不過舊的檔案放在 /private/etc/apache2/httpd.conf.pre-update","text":"更新 Mavericks 小牛之後會發現 httpd.conf 被取代了。不過舊的檔案放在 /private/etc/apache2/httpd.conf.pre-update ApacheOSX 內建有 Apache 不過以前可以在 系統偏好設定-&gt;共享 開啟。但是在新版 10.9 這個部分被移除了。所以要開啟 Apache 必須要使用指令 123456789101112131415161718192021$ sudo apachectl start // 啓動$ sudo apachectl stop // 停止$ sudo apachectl restart // 重啟$ sudo apachectl -t // 測試 conf 是否正確&#123;% endhighlight %&#125;# 自定 Apache 設定預設的網站目錄在 `/Library/WebServer/Documents/`。在開啟 Apache 之後您可能會需要一些設定。* 建立一個 `/www` 目錄* 將測試網站檔案放在該目錄底下* 替工作區加入虛擬目錄* 設定一個本地端的測試網址首先建立一個 `/www` 目錄~~~bash$ cd /$ mkdir www // 這邊可能需要 sudo 權限 接著建立一個工作目錄 1$ mkdir local.example.com 設定 http.conf 這個檔案完整路徑 /private/etc/apache2/http.conf 是用來設定關於 Apache 的組態。這邊您可以使用 vi 或其他編輯器，我使用 Sublime Text 。 1$ subl /private/etc/apache2/http.conf 開啟檔案後有幾個地方要修改如下： 170 行將 DocumentRoot 修改為 1DocumentRoot \"/www\" 197 行修改目錄路徑 1&lt;Directory \"/www\"&gt; 217 行修改 AllowOverride 為 All 1AllowOverride All 429 行將匯入 http-vhosts.conf 註解移除 1Include /private/etc/apache2/extra/httpd-vhosts.conf 我們接著加入關於虛擬目錄的設定，設定檔的路徑在 /private/etc/apache2/extra/httpd-vhosts.conf 當你開啟這個檔案的時候會發現裡面已經有一些範例資料。下面是一個設定的範例，實際需求請自行修正。 123456&lt;VirtualHost *:80&gt; DocumentRoot \"/www/local.example.com\" ServerName local.example.com ErrorLog \"/private/var/log/apache2/local.example.com-error_log\" CustomLog \"/private/var/log/apache2/local.example.com-access_log\" common&lt;/VirtualHost&gt; 當你做完這些修正您可以使用 sudo apachectl -t 檢查一下是否有錯誤。最後我們修改 /private/etc/hosts 增加一個本地用的網址 127.0.0.1 local.example.com PHPPHP 也是已經內建在 OSX 10.9 只要修改 httpd.conf 就可以開啟功能。 1$ subl /private/etc/apache2/http.conf 118 行 解開載入模組的註解 1LoadModule php5_module libexec/apache2/libphp5.so 231 行 加入預設 index.php 1DirectoryIndex index.html index.php 最後呢，我們需要讓 Apache 知道要處理 .php , .phps 檔案格式。一樣打開 http.conf 在最下面加上程式碼片段 12345#PHP Settings&lt;IfModule php5_module&gt; AddType application/x-httpd-php .php AddType application/x-httpd-php-source .phps&lt;/IfModule&gt; 別忘記每當你變更 http.conf 都要重啟 Apache 才會生效。接著可以在剛建立的目錄底下建立一個 test.php 1&lt;?php phpinfo(); ?&gt; 測試環境是否成功。 MySQL安裝123456789$ brew install mysql$ unset TMPDIR$ mysql_install_db --verbose --user=`root` --basedir=\"$(brew --prefix mysql)\"$ mysql.server start$ mysqladmin -u root password 'newpassword'$ mkdir -p ~/Library/LaunchAgents$ cp /usr/local/Cellar/mysql/5.5.20/com.mysql.mysqld.plist ~/Library/LaunchAgents/$ launchctl load -w ~/Library/LaunchAgents/com.mysql.mysqld.plist 升級也許會覆蓋掉您原本 php.ini 的設定，為了取得 MySQL 的一些工作狀態，我們需要修改一些設定 478 行 開啟錯誤 1display_errors = On 986 行 加入 MySQL socket 路徑 1pdo_mysql.default_socket=/tmp/mysql.sock 參考連結Start mySQL server from command line on Mac OS LionGet Apache, MySQL, PHP and phpMyAdmin working on OSX 10.9 MavericksInstalling phpMyAdmin on Mac OSX 10.8 Mountain Lion &amp; 10.7, 10.6OS X Mavericks and Apache","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"osx","slug":"osx","permalink":"//andyyou.github.io/tags/osx/"},{"name":"php","slug":"php","permalink":"//andyyou.github.io/tags/php/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]},{"title":"Grunt 系列(3) 範例實作","slug":"grunt-series-3-example-implementations","date":"2013-10-01T11:13:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/10/01/grunt-series-3-example-implementations/","link":"","permalink":"//andyyou.github.io/2013/10/01/grunt-series-3-example-implementations/","excerpt":"下面我們將透過一個使用了 5 個常用套件的 Gruntfile 來實作練習並討論關於 Gruntfile。","text":"下面我們將透過一個使用了 5 個常用套件的 Gruntfile 來實作練習並討論關於 Gruntfile。 grunt-contrib-uglify : 壓縮檔案 grunt-contrib-qunit : 單元測試 grunt-contrib-concat : 檔案合併 grunt-contrib-jshint : 檢查 Javascript 語法 grunt-contrib-watch : 觀察檔案變更 整個完整的 Gruntfile 在頁面的最下方，不過如果你按順序閱讀，這篇文章會一步一步的說明。 備註：通常在使用套件前，比較方便的方式是透過下面指令來安裝，這樣一來也順便會更新 package.json 。一般來說執行 grunt 都是在開發階段所以參數會使用 –save-dev 就是設定在 package.json 的 devDependencies 中。 1$ npm install grunt-contrib-uglify --save-dev 首先要說明的是關於 wrapper 函式，簡單的來說所有關於 grunt 該執行的任務和相關設定都會被封裝在這個 function中。如下程式碼 123module.exports = function(grunt) &#123; // 所有任務設定都會在這。&#125; 接著我們通常會在這個 function 中開始初始化我們的設定檔物件，就會透過 grunt.initConfig 把資料放到物件{}中，如下： 12345&#123;% raw %&#125;grunt.initConfig(&#123; // 屬性: \"資料\"&#125;);&#123;% endraw %&#125; 為了能夠使用一些關於專案的資料，我們可以讀取 package.json 的資料到 pkg 屬性，於是我們就可以透過 pkg 來取得專案的資料，例如： pkg.name 就是我們在 package.json 設定的專案名稱。設定的方式如下 1pkg: grunt.file.readJSON('package.json'); 到目前為止的設定就會如下： 12345module.exports = function(grunt)&#123; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'); &#125;);&#125; 現在，我們就可以針對每一個任務來作設定，在設定檔物件中，也就是在 grunt.initConfig(\\{\\}) 的 {} 中所有存在的任務通常會對應一個屬性，它是透過相同的名稱來對應的。所以例如 concat 任務的設定就會在 concat 屬性中設定。下面就是關於 concat 任務的設定： 123456789101112concat: &#123; options:&#123; // 合併不同檔案時會在檔案和檔案之間加入 ; separator: ';' &#125;, dist:&#123; // 要合併的檔案 src: ['src/**/*.js'], // 產生的檔案路徑 dest: 'dist/&lt;%= pkg.name %&gt;.js' &#125;&#125; 注意到這邊我們引用了專案名稱 name 屬性，透過 grunt.file.readJSON 我們把 package.json 讀入成為一個物件，並且賦予 pkg ，如此一來我們就可以很輕鬆地存取關於 package.josn 中的設定。 Grunt 內建一個簡單的樣板引擎，讓我們在設定檔中能夠輕鬆的內嵌變數，通常是屬性的值（例如 pkg.name）。上面任務的意思就是取得 src/ 目錄底下所有 .js 結尾的檔案，然後合併成一個 dist/[專案名稱].js 。 接著讓我們來看看 uglify 任務，它是用來壓縮 Javascript 的套件。 dist = Distribution 1234567891011121314uglify: &#123; options: &#123; // 產生一段 banner 文字並加入到將產生檔案的一開始 banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"dd-mm-yyyy\") %&gt; */\\n' &#125;, // 這邊的 dist 是任務底下的一個目標（target） // 一般情況下執行 grunt uglify 所有的目標都會被執行。 dist: &#123; files: &#123; // 回憶一下上一篇 dist:src 前面是目的路徑，後面是來源路徑，注意來源是 concat 的屬性 'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;'] &#125; &#125;&#125; 上面 uglify 任務取得 concat 合併後的檔案，並壓縮到 dist 目錄。讓我們復習一下上面 files 是使用檔案物件格式，檔案的設定方式有三種。 qunit 的設定則非常單純，只要把運行測試頁的位置設定即可。 123qunit: &#123; files: ['test/**/*.html']&#125; JSHint 的設定也很簡單如下 1234567891011121314&#123;% raw %&#125;jshint: &#123; // 檢查的檔案 files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'], // 設定 JSHint 屬性查詢文件(http://www.jshint.com/docs/options/) options: &#123; globals: &#123; jQuery: true, console: true, module: true &#125; &#125;&#125;&#123;% endraw %&#125; JSHint 就是根據 files 的設定去檢查檔案，而 options 可以用來改寫預設的規則。如果你要使用預設值則不用設定。 最後我們還有一個 watch 任務 123456&#123;% raw %&#125;watch: &#123; files: ['&lt;%= jshint.files %&gt;'], tasks: ['jshint', 'qunit']&#125;&#123;% endraw %&#125; 當你使用 grunt watch 命令時，它就會去觀察 jshint.files 的檔案列表。就是 [&#39;gruntfile.js&#39;, &#39;src/**/*.js&#39;, &#39;test/**/*.js&#39;] 。當它偵測到指定的這些檔案有變更，他就會去執行任務 tasks 。在這邊我們設定了執行 hshint 和 qunit 兩個任務。 讓我們再次提醒，上面都是透過 grunt.initConfig 設定的組態，因此我們還是要載入這些套件。載入之前請先記得安裝。 12345grunt.loadNpmTasks('grunt-contrib-uglify');grunt.loadNpmTasks('grunt-contrib-jshint');grunt.loadNpmTasks('grunt-contrib-qunit');grunt.loadNpmTasks('grunt-contrib-watch');grunt.loadNpmTasks('grunt-contrib-concat'); 最後我們需要把常用的任務設定為 default 這樣一來我們以後只要下 grunt 指令就好，就不用在特別下 grunt uglify 之類的。 12345// 註冊 test 任務之後只要執行 \"grunt test\" 就會跑 jshint 和 qunitgrunt.registerTask('test', ['jshint', 'qunit']);// 註冊預設任務之後只要執行 \"grunt\" 就會跑下面陣列中的任務。grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']); 下面就是完整的 Gruntfile ，通常我們使用 .js 或 .coffee 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051module.exports = function(grunt)&#123; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), concat: &#123; options: &#123; separator: ';' &#125;, dist: &#123; src: ['src/**/*.js'], dest: 'dist/&lt;%= pkg.name %&gt;.js' &#125; &#125;, uglify: &#123; options: &#123; banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"dd-mm-yyyy\") %&gt; */\\n' &#125;, dist: &#123; files: &#123; 'dist/&lt;%= pkg.name %&gt;.min.js': ['&lt;%= concat.dist.dest %&gt;'] &#125; &#125; &#125;, qunit: &#123; files: ['test/**/*.html'] &#125;, jshint: &#123; files: ['gruntfile.js', 'src/**/*.js', 'test/**/*.js'], options: &#123; globals: &#123; jQuery: true, console: true, module: true, document: true &#125; &#125; &#125;, watch: &#123; files: ['&lt;%= jshint.files %&gt;'], tasks: ['jshint', 'qunit'] &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-contrib-qunit'); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.registerTask('test', ['jshint', 'qunit']); grunt.registerTask('default', ['jshint', 'qunit', 'concat', 'uglify']);&#125;;","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"package manager","slug":"package-manager","permalink":"//andyyou.github.io/tags/package-manager/"},{"name":"grunt","slug":"grunt","permalink":"//andyyou.github.io/tags/grunt/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"Grunt 系列(2) 設定","slug":"grunt-set-2","date":"2013-09-29T04:19:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/09/29/grunt-set-2/","link":"","permalink":"//andyyou.github.io/2013/09/29/grunt-set-2/","excerpt":"這篇教學將會解釋如何使用 Gruntfile 為你的專案設定任務。如果你還不知道什麼是 Gruntfile 請回到上一篇 Grunt 入門 閱讀。","text":"這篇教學將會解釋如何使用 Gruntfile 為你的專案設定任務。如果你還不知道什麼是 Gruntfile 請回到上一篇 Grunt 入門 閱讀。 Grunt 設定關於任務，你可以把任務當作就是一連串需要被執行的動作，通常這些設定都在 Gruntfile 這個檔案的 grunt.initConfig 這個方法中。接著各個任務的設定都會在屬性名稱底下，換個說法， initConfig 需要你傳遞一個物件{}參數進去如下： grunt.initConfig({property:{ // task configuration here. }}); 之後這個物件的每一個屬性通常就對應著一個任務，這只是大部份的狀況，它有可能是任意的資料。只要屬性不衝突即可，一旦衝突就會被忽略。接著讓我們來看看一個比較完整的範例： grunt.initConfig({ concat: { // concat task configuration goes here. // 整合檔案的任務 }, uglify: { // uglify task configuration goes here. // 壓縮檔案的任務 }, // Arbitrary non-task-specific properties. // 任意的資料 my_property: &apos;whatever&apos;, my_src_files: [&apos;foo/*.js&apos;, &apos;bar/*.js&apos;], }); 任務設定和目標(Targets)當任務開始執行， Grunt 會去尋找設定檔裡面的同名屬性，不同的任務配合不同的屬性，屬性可以設定不同的任務目標。我們用下面的範例來說明： concat 任務有 foo, bar 兩個目標，uglify 任務有 bar 一個目標。 grunt.initConfig({ concat: { foo: { // concat task &quot;foo&quot; target options and files go here. }, bar: { // concat task &quot;bar&quot; target options and files go here. }, }, uglify: { bar: { // uglify task &quot;bar&quot; target options and files go here. }, }, }); 上一篇我們說過可以透過 grunt uglify 來執行任務，那當我們有不同的目標時就可以透過 grunt concat:foo 來執行該目標。不過在這邊要再次提醒上面範例只是設定，並無法拿來直接執行。如果直接下 grunt concat 則會把所有目標都執行一遍。這邊還有另一點要注意的是如果使用 grunt.renameTask 修改了任務的名稱，那 grunt 就會自動根據新名稱去找設定。 Options在每一項任務設定中options屬性也許是用來覆寫內建的預設規則，此外每個target目標也可能會有一個 options 屬性。目標的 options 屬性會覆蓋任務的 options ，最後就是關於 options 這個屬性是可以省略的，他不是必須的。讓我們來看看範例： grunt.initConfig({ concat: { options: { // Task-level options may go here, overriding task defaults. // 任務等級的 options }, foo: { options: { // &quot;foo&quot; target options may go here, overriding task-level options. // 『目標』等級的 options 如果設定有重複，它會覆寫任務等級的設定。 }, }, bar: { // No options specified; this target will use task-level options. }, }, }); 檔案因為大部份的任務都涉及操作檔案， Grunt 對於檔案的定義宣告與操作有非常強及高度的抽象化。它提供了一些方法定義 src-dest (來源-目的地)如何對應 ，就是取得來源檔案，然後處理後產生至目的地目錄。提供了不同程度的操作，任何任務都會針對某種格式的檔案來做操作，編譯等等。你可以選擇你需要的格式。 所有的檔案格式都支援 src 和 dest 兩種屬性設定，不過簡潔格式和檔案陣列有一些額外的屬性可用。下面會說明什麼是簡潔格式和檔案陣列。額外支援的屬性如下： filter 任何一個 fs.States 的方法名稱如：stats.isFile()你可以用‘isFile’，或者任何一個 function 輸入src` 路徑後可以判斷回傳 true/false ，都可以拿來設定，用來過濾。 nonull 當一個比對沒有被找到的時候，就會回傳一個包含其 pattern 的列表，否則就會回傳一個空的列表。搭配 --verbose 可以用在關於檔案路徑的除錯。 dot 允許檔案名稱的匹配模式用 . 開始 ，即使設定沒有在開頭使用 . matchBase 一旦設定這種匹配模式就不會比對 / 舉例來說會變成 *.js 等於 **/*.js 簡單來說就是只比對最後檔名的部分。例如，a?b 會匹配 /xyz/123/acb 但不匹配 /xyz/acb/123。 expand 處理動態的 src 和 dest 檔案對應。 其他屬性都會傳入底層當作匹配的參數 簡潔格式這種格式允許每一個『目標』設定單一屬性的對應，比較常用在讀取檔案，例如 grunt-contrib-jshint 只需要 src ，而不需要 dest 。看下面範例會更清楚。 grunt.initConfig({ jshint: { foo: { src: [&apos;src/aa.js&apos;, &apos;src/aaa.js&apos;] }, }, concat: { bar: { src: [&apos;src/bb.js&apos;, &apos;src/bbb.js&apos;], dest: &apos;dest/b.js&apos;, }, }, }); 檔案物件格式這種格式允許每個目標對應多個檔案，前面的屬性名稱會是目的地的檔案名稱。然後來源檔案可以是多個。可以用這種方式設定多組檔案的對應。一旦採用這種設定方式就不能再加入其他屬性了。看看下列程式碼： grunt.initConfig({ concat: { foo: { files: { &apos;dest/a.js&apos;: [&apos;src/aa.js&apos;, &apos;src/aaa.js&apos;], &apos;dest/a1.js&apos;: [&apos;src/aa1.js&apos;, &apos;src/aaa1.js&apos;], }, }, bar: { files: { &apos;dest/b.js&apos;: [&apos;src/bb.js&apos;, &apos;src/bbb.js&apos;], &apos;dest/b1.js&apos;: [&apos;src/bb1.js&apos;, &apos;src/bbb1.js&apos;], }, }, }, }); 檔案陣列格式這種方式一樣支援多組 src-dest 對應，但可以多加入其他屬性。就跟一開始說的一樣 簡潔格式 和 檔案陣列 格式可以增加其他的屬性。直接看範例比較清楚。 grunt.initConfig({ concat: { foo: { files: [ {src: [&apos;src/aa.js&apos;, &apos;src/aaa.js&apos;], dest: &apos;dest/a.js&apos;}, {src: [&apos;src/aa1.js&apos;, &apos;src/aaa1.js&apos;], dest: &apos;dest/a1.js&apos;}, ], }, bar: { files: [ {src: [&apos;src/bb.js&apos;, &apos;src/bbb.js&apos;], dest: &apos;dest/b/&apos;, nonull: true}, {src: [&apos;src/bb1.js&apos;, &apos;src/bbb1.js&apos;], dest: &apos;dest/b1/&apos;, filter: &apos;isFile&apos;}, ], }, }, }); 舊版的格式直接在任務底下，就是沒有 files 屬性是舊版本在執行多檔案操作的一種過渡期的方式。直接讓最後目的地的路徑等於目標(target) 名稱，很不幸的因為目標名稱就是路徑，所以當你要執行 grunt task:target 的時候就顯得很糟糕。而且你也不能在設定 目標等級 的 options 或加入其他屬性。因此請儘量避免使用這種格式設定。 grunt.initConfig({ concat: { &apos;dest/a.js&apos;: [&apos;src/aa.js&apos;, &apos;src/aaa.js&apos;], &apos;dest/b.js&apos;: [&apos;src/bb.js&apos;, &apos;src/bbb.js&apos;], }, }); 自訂過濾 Functionfilter 這個屬性可以讓你針對檔案設定更多細節，最簡單的方式就是使用 fs.States｀ 的 method 名稱來設定，例如下面的程式碼我們就可以輕鬆的確認是否為一個實體檔案，然後把tmp` 暫存的檔案都清光。 grunt.initConfig({ clean: { foo: { src: [&apos;tmp/**/*&apos;], filter: &apos;isFile&apos;, }, }, }); 或者是你只要建立一個 function 回傳 true/false 就可以了 grunt.initConfig({ clean: { foo: { src: [&apos;tmp/**/*&apos;], filter: function(filepath) { return (grunt.file.isDir(filepath) &amp;&amp; require(&apos;fs&apos;).readdirSync(filepath).length === 0); }, }, }, }); 模式匹配與符號說明(Global Pattern)一般來說一個路徑一個路徑設定在實務上來說是不切實際的，非常麻煩。所以 Grunt 支援透過內建的函式庫來做檔名路徑的匹配，或者說透過設定 Pattern 規則來選取檔案。這並不是專門的模式匹配的教學，我們只需要學習常用的符號即可。 * 任意數量的字元，但不包含 /。 ? 單一字元，不包含 /。 ** 任何數量的字元，包含 / 只要是路徑的一部分就可以。 {} 用 , 分隔列出清單，只要其中一個符合即可(OR)。 ! 用在開頭，排除的意思。 大部份的人都知道 /foo/*.js 會選取到所有在 /foo 目錄底下的 js 檔案。但是 foo/**/*.js 則會包含任何在 /foo 目錄底下子目錄的 js 檔案。要注意 /foo/*.js 只有一層，就是在 /foo 底下，至於其它如 /foo/subfolider 就沒有。此外，為了簡化複雜的匹配， Grunt 也允許你使用檔案陣列的方式如 [&#39;a.js&#39;, &#39;/foo/b.js&#39;] ，模式匹配是按照順序的，! 會排除匹配的檔案，其結果是唯一的。 // 指定單一檔案 {src: &apos;foo/this.js&apos;, dest: …} // 使用檔案陣列指定多個檔案 {src: [&apos;foo/this.js&apos;, &apos;foo/that.js&apos;, &apos;foo/the-other.js&apos;], dest: …} // 使用模式匹配來選取檔案 {src: &apos;foo/th*.js&apos;, dest: …} // node-glob 模式，對應 foo 目錄底下 a 或 b 開頭的 js {src: &apos;foo/{a,b}*.js&apos;, dest: …} // 上面的例子也可以這樣寫。 {src: [&apos;foo/a*.js&apos;, &apos;foo/b*.js&apos;], dest: …} // foo 目錄下所有的 .js ，但不包含子目錄下的 {src: [&apos;foo/*.js&apos;], dest: …} {src: [&apos;foo/bar.js&apos;, &apos;foo/*.js&apos;], dest: …} // 除了 bar.js 以外所有的 .js ，會按照字母排列。 {src: [&apos;foo/*.js&apos;, &apos;!foo/bar.js&apos;], dest: …} // 所有的 .js 檔案， bar.js 先被排除後，又被加入了 {src: [&apos;foo/*.js&apos;, &apos;!foo/bar.js&apos;, &apos;foo/bar.js&apos;], dest: …} // 模版也可以用在檔案路徑或模式匹配中。 {src: [&apos;src/&lt;%= basename %&gt;.js&apos;], dest: &apos;build/&lt;%= basename %&gt;.min.js&apos;} // 也可以使用其他設定檔中配置的屬性值。 {src: [&apos;foo/*.js&apos;, &apos;&lt;%= jshint.all.src %&gt;&apos;], dest: …} 動態建立檔案物件當你需要處理很多個別的檔案的時候，有些額外的屬性可以協助你動態的建立檔案清單。這些屬性都可以用在簡潔格式和檔案陣列格式中。 expand 設成 true 用來啓用後面的屬性設定。 cwd (Current Working Directory) 設定一個目標路徑，注意這個不是檔案路徑或者 Pattern。 src 在根據上面的 cwd 做 Pattern 或檔案的選取。 dest 目的地目錄 ext 在 dest 目錄設定新的附檔名取代原始附檔名。 flatten 移除 dest 設定的路徑，設定值為 true/false rename 對每個符合規則的 src 檔案調用這個 function （在執行完 ext 和 flatten 之後）。接著傳遞 dest 和 src 的值給 function 最後回傳一個新的 dest 路徑。 对每个匹配的src文件调用这个函数(在执行ext和flatten之后)。传递dest和匹配的src路径给它，这个函数应该返回一个新的dest值。 如果相同的dest返回不止一次，每个使用它的src来源都将被添加到一个数组中。如果傳回的 dest 重複則會被加入 sources 的陣列。 下面是關於 minify 的例子，我們會看到 static_mappings 和 dynamic_mappings 目標雖然設定不同，卻處理了相同的檔案列表， static_mappings 是一條一條設定，而 dynamic_mappings 則是動態，先切換到一個路徑底下，再根據同樣的規則去執行。 grunt.initConfig({ minify: { static_mappings: { // 由於 src-dest 檔案路徑是寫死的, 每次新增或刪除，Gruntfile 都要更新。 files: [ {src: &apos;lib/a.js&apos;, dest: &apos;build/a.min.js&apos;}, {src: &apos;lib/b.js&apos;, dest: &apos;build/b.min.js&apos;}, {src: &apos;lib/subdir/c.js&apos;, dest: &apos;build/subdir/c.min.js&apos;}, {src: &apos;lib/subdir/d.js&apos;, dest: &apos;build/subdir/d.min.js&apos;} ] }, dynamic_mappings: { // 執行任務時 Grunt 會自動在當下的工作目錄 &quot;lib/&quot; 下搜尋 Pettern &quot;**/*.js&quot;, 接著建立 src-dest 檔案對應，因此你就不需要在新增或刪除檔案時更新 Gruntfile。 files: [ { expand: true, // 啓用動態對應 cwd: &apos;lib/&apos;, // 匹配切換成當前的工作目錄 lib src: &apos;**/*.js&apos;, // 根據上面的目錄限制，套用 Pettern dest: &apos;build/&apos;, // 檔案產生目的地目錄 ext: &apos;.min.js&apos; // 取代原本的附檔名 } ] } } }); 樣板（Templates）直接翻譯為樣板可能不太恰當，主要的用法是可以透過 &lt;% %&gt; 嵌入變數，而這些變數可以是來自讀取設定檔的資料。模板本身會不斷遞回讀取變數直到裡面不再存在任何模板。整個設定物件中由外到內的屬性都會被解析，此外 grunt 的方法或屬性都可以被嵌入樣板中。例如 &lt;%= grunt.template.today(&#39;yyyy-mm-dd&#39;) %&gt; &lt;%= prop.subprop %&gt; 取得 prop.subprop 設定屬性的值。只要正規的型別他都能使用，不僅是字串，陣列貨，物件也可以。這樣說明你可能會有點模糊，讓我們看下列的範例。 module.exports = function(grunt){ grunt.initConfig({ prop: {subprop:&quot;tmp/lib/&quot;}, clean: { src: &quot;&lt;%= prop.subprop %&gt;*.js&quot; } }); } &lt;% %&gt; 在分隔符號中您可以使用 Javascript。對於做一些基本的邏輯判斷是非常有用的。 讓我們來一些範例觀察，下面使用了 concat 任務來整合檔案，執行 grunt concat:sample ，透過 banner 會在檔案加入 /* abcde */ ，而這隻檔案是由 foo/*.js, bar/*.js, baz/*.js 這三個規則搜尋來的檔案組合而成，最後結合的檔案則生成 build/abcde.js 。 grunt.initConfig({ concat: { sample: { options: { banner: &apos;/* &lt;%= baz %&gt; */\\n&apos; // &apos;/* abcde */\\n&apos; }, src: [&apos;&lt;%= qux %&gt;&apos;, &apos;baz/*.js&apos;], // [[&apos;foo/*js&apos;, &apos;bar/*.js&apos;], &apos;baz/*.js&apos;] dest: &apos;build/&lt;%= baz %&gt;.js&apos; } }, // 同樣在 initConfig 中可以直接存取屬性。 foo: &apos;c&apos;, bar: &apos;b&lt;%= foo %&gt;d&apos;, //&apos;bcd&apos; baz: &apos;a&lt;%= bar %&gt;e&apos;, //&apos;abcde&apos; qux: [&apos;foo/*.js&apos;, &apos;bar/*.js&apos;] }); 匯入外部資料在下面的 Gruntfile 中，專案本身的 metadata 可以透過 package.json 匯入到設定物件中。接著 uglify 任務就可以透過 pkg.name 取得該專案名稱的js。 src/pkg.name.js ，然後產生到 dest 中並加上 .min.js。 grunt.initConfig({ pkg: grunt.file.readJSON(&apos;package.json&apos;), uglify: { options: { banner: &apos;/* &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&apos; }, dist: { src: &apos;src/&lt;%= pkg.name %&gt;.js&apos;, dest: &apos;dist/&lt;%= pkg.name %&gt;.min.js&apos; } } }); 實做練習最後讓我們在透過一個簡單的清除檔案練習，加深對整個 Grunt 運作的觀念吧！ $ mkdir grunt-test $ cd grunt-test $ npm init $ npm install grunt grunt-contrib-clean --save $ vi Gruntfile.js Gruntfile 設定 module.exports = function(grunt){ // 設定關於 clean 的設定，清除 tmp/ 底下的 js 檔案 grunt.initConfig({ clean: { files:[ {src: &apos;tmp/*.js&apos;} ], dynamic:{ files:[ { expand: true, cwd: &apos;&lt;%= prop.andy %&gt;&apos;, src: [&apos;**/*.js&apos;] } ] } } }); // 載入套件 grunt.loadNpmTasks(&apos;grunt-contrib-clean&apos;); // 註冊預設的任務 grunt.registerTask(&apos;default&apos;, [&apos;clean&apos;]); } 接著執行 $ grunt --help // 查詢可用的指令 $ grunt clean // 執行指令清除 $ grunt clean:dynamic // 執行任務中的 dynamic 目標 參考資料官方文件官方手冊簡體翻譯Wiki其他教學","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"package manager","slug":"package-manager","permalink":"//andyyou.github.io/tags/package-manager/"},{"name":"grunt","slug":"grunt","permalink":"//andyyou.github.io/tags/grunt/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"Sails 實作筆記","slug":"sails-real-1","date":"2013-09-29T02:14:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/09/29/sails-real-1/","link":"","permalink":"//andyyou.github.io/2013/09/29/sails-real-1/","excerpt":"何謂 sails.jssails 其實就跟 Rails ，ASP.NET MVC 類似，是一個 MVC 的 Web 框架。目標是協助您快速的用 nodejs 開發出企業等級的網站（註：由於開發團隊仍在開發中，所以要採用前請先審慎評估XDD）。所以就跟其他框架一樣，他讓我們不用再重新造輪子，整合一般網站開發常用的功能，並且重點是支援許多 nodejs 特有的強項，特別是在開發聊天室這類的應用程式更顯得出效能。本篇文章僅僅透過實作一些基礎，讓我們快速的感受一下 sails 。","text":"何謂 sails.jssails 其實就跟 Rails ，ASP.NET MVC 類似，是一個 MVC 的 Web 框架。目標是協助您快速的用 nodejs 開發出企業等級的網站（註：由於開發團隊仍在開發中，所以要採用前請先審慎評估XDD）。所以就跟其他框架一樣，他讓我們不用再重新造輪子，整合一般網站開發常用的功能，並且重點是支援許多 nodejs 特有的強項，特別是在開發聊天室這類的應用程式更顯得出效能。本篇文章僅僅透過實作一些基礎，讓我們快速的感受一下 sails 。 安裝 sails.js $ npm -g install sails // -g：安裝到系統路徑 建立專案 $ sails new [project_name] $ sails new [project_name] --linker // 使用 linker 用來整和壓縮 css 和 js 的套件 $ sails new [project_name] --template=jade // 預設樣板引擎是 `ejs` 可以換成 `jade` 安裝相依套件 $ cd [project_name] $ npm install $ npm install jade --save // 安裝 jade 並且更新 package.json 啓動測試網站 $ sails lift 依照指示說明在瀏覽器輸入 http://localhost:1337 就可以看到預設畫面。 初識路由和目錄結構路由設定在 config/routes.js ，打開該檔案我們會看到如下程式碼： module.exports.routes = { &apos;/&apos; : { view: &apos;home/index&apos; } } 嘗試編輯將 view: &#39;home/index&#39; 改成 view: &#39;static/index&#39; 。然後我們在 views 目錄底下建立一個 static 目錄，接著在裡面再建立一個 index.ejs 或 index.jade 。隨便輸入一些資料，例如 h2 Hello, This is our page using Jade 或者 &lt;h2&gt;Hello, This is our page using EJS&lt;/h2&gt; 注意：這邊我們先不做太多解釋與設定，純粹先實作讓大家感受一下 Sails 這個框架。如果使用 jade 請記得整個 view 應該是這樣： extends ../layout block body h2 Hello, This is our page using Jade 接著我們使用 sails lift 指令來觀看我們的修改。 加入 bootstrap到目前為止我們只有使用到 view ，我們來嘗試組織一下專案加入 bootstrap。到 bootstrap3 官網下載 zip 並且把 bootstrap.css 放到 assets/styles/ 目錄底下。 編輯 views/static/index.jade 或 views/static/index.ejs 加入 extends ../layout block body div.container div.jumbotron h1 activityOverlord h2 ...tracking app activity better than the NSA since 1899. a(href=&apos;/user/new&apos;, class=&apos;btn btn-lg btn-success&apos;) Sign up now! 或者 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;activityOverlord&lt;/h1&gt; &lt;h2&gt;...tracking app activity better than the NSA since 1899.&lt;/h2&gt; &lt;a href=&quot;/user/new&quot; class=&quot;btn btn-lg btn-success&quot;&gt;Sign up now!&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; 修改 Layout在 Sails 裡面跟其他 MVC 框架一樣預設都幫您提出一個 layout 樣板，而每個 view 則會嵌入到 layout 的 body 中。例如 jade 是 block body ， ejs 是 &lt;%- body %&gt; 。如此一來相同的部分我們就可以放入 layout 之後如果需要修改，就只要修改一次。 layout.jade 如下 !!! html head title= title // Viewport mobile tag for sensible mobile support meta(name=&quot;viewport&quot;,content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;) link(rel=&quot;stylesheet&quot;,href=&quot;/styles/bootstrap.css&quot;) link(rel=&quot;stylesheet&quot;,href=&quot;/styles/custom.css&quot;) block styles body div.navbar.navbar-inverse.navbar-fixed-top div.container a.navbar-brand(href=&quot;/&quot;) Activity Overload block body div.container hr footer.footer.pull-right div a(href=&quot;http://sailsjs.com/&quot;) Sails.js div tutorial by irl nathan, with a bunch of help from cody, gabe, heather, mike, scott and zoli // A few key dependencies, linked in order // Bring in the socket.io client script(type=&quot;text/javascript&quot;, src=&quot;/js/socket.io.js&quot;) // then beef it up with some convenience logic for talking to Sails.js&apos; script(type=&quot;text/javascript&quot;, src=&quot;/js/sails.io.js&quot;) // listen on socket.io for incoming messages script(type=&quot;text/javascript&quot;, src=&quot;/js/app.js&quot;) 其他 ejs 範例可以透過 ActivityOverloadd範例 下載原文影片教學在此 連結，這篇文章讓我們先感受一下使用 Sails.js 這個 nodejs 框架使用起來的感覺。後續會補上教學。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"framework","slug":"framework","permalink":"//andyyou.github.io/tags/framework/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Grunt 系列(1) 基礎教學","slug":"grunt","date":"2013-09-27T00:50:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/09/27/grunt/","link":"","permalink":"//andyyou.github.io/2013/09/27/grunt/","excerpt":"Grunt 入門Grunt 和 Grunt 擴充套件 都是透過 npm 來安裝和管理。Grunt 這個工具大概就等於 Ruby 中的 rake ，它可以透過一些設定讓你輕鬆完成一些例行性的任務，例如壓縮檔案，編譯 coffee less，搬移到目標目錄，單元測試等等。之後就可以透過一個指令，就把所有的事情做好。 安裝為了能夠使用 Grunt 你必須安裝 grunt-cli 就是 Grunt 的 Command Line Interface 到您的系統。安裝過程可能會需要 sudo 或這在 windows 底下使用管理者身份執行。","text":"Grunt 入門Grunt 和 Grunt 擴充套件 都是透過 npm 來安裝和管理。Grunt 這個工具大概就等於 Ruby 中的 rake ，它可以透過一些設定讓你輕鬆完成一些例行性的任務，例如壓縮檔案，編譯 coffee less，搬移到目標目錄，單元測試等等。之後就可以透過一個指令，就把所有的事情做好。 安裝為了能夠使用 Grunt 你必須安裝 grunt-cli 就是 Grunt 的 Command Line Interface 到您的系統。安裝過程可能會需要 sudo 或這在 windows 底下使用管理者身份執行。 1$ npm install -g grunt-cli 在 npm 使用 -g 就會把該套件裝至系統路徑，這樣您就可以在任何目錄使用 grunt-cli注意：安裝了 grunt-cli 並不是安裝 Grunt task runner。 grunt-cli 本身的任務非常單純，他就只是使用你已經安裝的 Grunt 版本去執行 Gruntfile.js。這樣你就可以在同一台機器，運行不同版本的 grunt 了。 CLI如何運作每一次執行 grunt，他會用require()去引入本地的 grunt，注意不是 cli。也因次你可以在不同專案目錄底下運行不同版本的 grunt。一旦 grunt 被載入了，接著就會載入 Gruntfile 然後根據裡面的設定去運行任務。如果你想理解原理可以閱讀程式碼 https://github.com/gruntjs/grunt-cli/blob/master/bin/grunt 如何使用已經存在的 Grunt 專案假如您的 cli 已經安裝了，並且有一個專案也已經設定好 package.json 和 Gruntfile.js。那你可以非常輕鬆地就開始使用 grunt 切換到專案的根目錄 使用 npm install 安裝相依的套件。 執行 grunt 就可以開始跑了。 如果你想瞭解更多關於 grunt 的命令，你可以使用 grunt --help 會列出例如：clean, coffee。這些都是靠 Grunfile 定義的。預設是空的沒有任何任務Sails 建立的 Gruntfile 建立一個新的 Grunt 專案要建立一個 Grunt 專案涉及到最重要的兩個檔案的建立 package.json 和 Gruntfile.js。 package.json : 這是 npm 用來儲存 matadata 的檔案，簡單說就是 npm 對於這個專案相關的設定擋。包含相依的套件，一旦在這邊設定，您就可以透過 npm install 來安裝相依的套件。一般在使用時，我們也會用 npm install --save 在安裝後順便把設定加到 package.json。你也會在這個檔案設定 grunt 和 grunt 套件相依的一些函式庫或元件。通常會像下面程式碼片段，指的是開發階段使用的套件。 &quot;devDependencies&quot;: { &quot;mocha&quot;: &quot;*&quot;, &quot;request&quot;: &quot;*&quot;, &quot;wrench&quot;: &quot;~1.5.1&quot; } Gruntfile : 這個檔案通常會是 Gruntfile.js 或者 Gruntfile.coffee 他被用來設定任務，載入外掛。 package.jsonpackage.json 通常和 Gruntfile 都在專案的根目錄。而且必須和你的專案一起被送交。在根目錄下 npm install 就會根據 package.json 去安裝相依的套件。而且還能指定版本。下面提供一些簡單的方式快速建立 package.json 大部份的 grunt-init 模版都會自動建立 package.json。而 grunt-init 這個指令是需要在安裝的。 npm init 直接執行 npm init 就會一步一步詢問你相關的參數，協助您建立 package.json 手動建立 { &quot;name&quot;: &quot;my-project-name&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~0.4.1&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.6.3&quot;, &quot;grunt-contrib-nodeunit&quot;: &quot;~0.2.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.2.2&quot; } } 安裝 Grunt 和 Grunt 套件安裝 Grunt 和 Grunt 套件並且加入 package.json 最簡單的方式就是執行 npm install &lt;module&gt; --save-dev它不只會安裝該套件模組還會新增或更新 package.json 。範例： npm install grunt –save-dev/ 測試透過 npm 安裝同一個套件，不同版本/npm install jquery@1.7.2 –save-devnpm install jquery@1.8.3 –save-dev GruntfileGruntfile.js 或 Gruntfile.coffee 都必須是合法正確的 javascript 或 coffee 。他們通常放在專案的根目錄下。跟 package.json 同一層，也一樣必須要被提交。一個 Gruntfile 包含下面這幾個部分： 把所有動作包起來的 function 專案和任務的設定 載入的 Grunt 套件和任務(別人已經寫好的) 自訂的任務 Gruntfile 範例在下面的範例中，關於 project 的 metadata 等資料是透過讀取 package.json 取得，並在 grunt 中使用。使用 grunt-contrib-uglify 套件的uglify任務是用來設定壓縮檔案並根據專案的 metadata 產生一些註解。當 grunt 開始執行，預設就會執行 uglify 任務 module.exports = function(grunt) { // Project configuration. grunt.initConfig({ pkg: grunt.file.readJSON(&apos;package.json&apos;), uglify: { options: { banner: &apos;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&apos; }, build: { src: &apos;src/&lt;%= pkg.name %&gt;.js&apos;, dest: &apos;build/&lt;%= pkg.name %&gt;.min.js&apos; } } }); // Load the plugin that provides the &quot;uglify&quot; task. grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); // Default task(s). grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]); }; 整個 Gruntfile 大致上就如上面這樣，後續我們將一步一步介紹每個組成部份。 The “wrapper” function (把所有動作包起來的 function)每一個 Gruntfile 或者 Grunt 套件都使用這個基本的定義格式，而你所有要讓 Grunt 執行的程式碼都必須被包在這個 function 中。 module.exports = function(grunt){ // Do grunt-related things in here } 專案和任務設定絕大多數的 Grunt 任務都透過定義一個包含所有設定資料的物件，然後把物件傳給 grunt.initConfig 方法來設定的。在上面的範例中，grunt.file.readJSON(&#39;package.json&#39;) 匯入了一個 JSON 格式的檔案，JSON 讀取至 javascript 中便是一個 object。接著在 Gruntfile 中可以使用 &lt;% %&gt; 這樣的語法，中間可以帶入其他設定的屬性，例如檔案路徑。你可能會隨便存一些資料到設定裡面，只要屬性不要衝突即可，否則會被忽略。這其實也是因為在 Javascript 中，你不能去限制 JSON 就像大部份的任務，grunt-contrib-uglify 的 uglify 任務預計會在同名的屬性中取得設定，在下面的範例中，我們在 options 設定了 banner，然後設定了 build 裡面指定了 src 和 dest 。整段範例的意思就是取得 package.json 中的 name ，接著去 src 目錄中取得 name.js 檔案並且把它壓縮成 name.min.js 。到這邊為止的 code 都只是設定而已。 // Project configuration. grunt.initConfig({ pkg: grunt.file.readJSON(&apos;package.json&apos;), uglify: { options: { banner: &apos;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&apos; }, build: { src: &apos;src/&lt;%= pkg.name %&gt;.js&apos;, dest: &apos;build/&lt;%= pkg.name %&gt;.min.js&apos; } } }); 載入 Grunt 和 Grunt 套件大部份的任務例如串聯檔案，壓縮，都已經有現成的套件可以使用了，只要在 package.json 中設定並安裝，就可以使用。安裝完之後，就是在 Gruntfile 中載入 // Load the plugin that provides the &quot;uglify&quot; task. grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;); 載入之後透過 grunt --help 就可以列出目前可以執行的任務，注意：initConfig 是在 grunt 初始化時針對任務做一些設定。於是真正在執行的時候就會去套用設定，例如上面我們載入了 grunt-contrib-uglify，之後我們就可以下達指令：grunt uglify。就會照著我們設定的把一支跟專案名稱一樣的 .js 壓縮成 .min.js。 自訂任務您可以在預設就讓 grunt 執行多個任務，只要透過 default 設定，接著我們執行 grunt 的時候就會照著預設任務去執行。如下範例，我們把 uglify 註冊到 default 。這樣我們就不用特別單獨執行 grunt uglify ，只要執行 grunt 或者 grunt default 就會執行下面壓縮檔案的這個任務。需要指定的任務可以加入下面程式碼 [‘uglify’] 中的這個陣列。它可以執行多個任務。 // Default task(s). grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]); 不過如果你想要執行的任務或需求並沒有任何 Grunt 套件，您也可以自訂在 Gruntfile 裡面 module.exports = function(grunt) { // A very basic default task. grunt.registerTask(&apos;default&apos;, &apos;Log some stuff.&apos;, function() { grunt.log.write(&apos;Logging some stuff...&apos;).ok(); }); }; 以上我們就完成了 Grunt 入門的使用了","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"package manager","slug":"package-manager","permalink":"//andyyou.github.io/tags/package-manager/"},{"name":"grunt","slug":"grunt","permalink":"//andyyou.github.io/tags/grunt/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"HTML Tag","slug":"html-tag","date":"2013-09-18T01:34:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/09/18/html-tag/","link":"","permalink":"//andyyou.github.io/2013/09/18/html-tag/","excerpt":"&lt;h1&gt; - &lt;h6&gt; 標題 &lt;p&gt; 文字段落，注意在裡面的空白，無論連續幾個都會被當做一個。此時可以使用 &amp;nbsp;","text":"&lt;h1&gt; - &lt;h6&gt; 標題 &lt;p&gt; 文字段落，注意在裡面的空白，無論連續幾個都會被當做一個。此時可以使用 &amp;nbsp; &lt;b&gt; 粗體 &lt;i&gt; 斜體 &lt;sup&gt; 文字一半，並往上半部移動 ex 數學 2 的平方 &lt;sub&gt; 文字一半，往下移動 ex 化學符號 &lt;br&gt; 換行 &lt;hr&gt; 加入橫線 &lt;strong&gt; 語意表示重要強調，視覺會變粗體。 &lt;em&gt; 強調，表示語氣轉變。視覺會變斜體。 &lt;blockquote&gt; 引用一整段文字。 &lt;q&gt; 短句或單字引用，視覺會出現 “ “ ，但是 IE 不會。 &lt;abbr title=&#39;description&#39;&gt;Desc&lt;/abbr&gt; 縮寫，title 可以放入完整單字。 &lt;cite&gt; 引用，出處。視覺會變斜體。 &lt;dfn&gt; 定義專業術語。 &lt;address&gt; 作者資訊，可搭配 hCards 格式內容。範例如下： &lt;div id=&quot;hcard-Joe-Monkey&quot; class=&quot;vcard&quot;&gt; &lt;span class=&quot;fn&quot;&gt;Joe Monkey&lt;/span&gt; &lt;div class=&quot;org&quot;&gt;ACME Banana&lt;/div&gt; &lt;div class=&quot;adr&quot;&gt; &lt;span class=&quot;type&quot;&gt;Work&lt;/span&gt;: &lt;div class=&quot;street-address&quot;&gt;314 Monkey Avenue&lt;/div&gt; &lt;span class=&quot;locality&quot;&gt;Monkey Island&lt;/span&gt;, &lt;abbr class=&quot;region&quot; title=&quot;California&quot;&gt;CA&lt;/abbr&gt; &lt;span class=&quot;postal-code&quot;&gt;94301&lt;/span&gt; &lt;div class=&quot;country-name&quot;&gt;USA&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tel&quot;&gt; &lt;span class=&quot;type&quot;&gt;Work&lt;/span&gt; +1-555-555-5555 &lt;/div&gt; &lt;div class=&quot;tel&quot;&gt; &lt;span class=&quot;type&quot;&gt;Fax&lt;/span&gt; +1-555-555-5555 &lt;/div&gt; &lt;div&gt;Email: &lt;span class=&quot;email&quot;&gt;joe@acmebanana.com&lt;/span&gt; &lt;/div&gt; &lt;a class=&quot;url&quot; href=&quot;aim:goim?screenname=monkeybites&quot;&gt;AIM&lt;/a&gt; &lt;/div&gt; &lt;ins&gt; 插入文字，會有底線。 &lt;del&gt; 刪除文字，中間會有橫線杠掉。 &lt;s&gt; 表示資料不再精確，跟 del 一樣會橫線杠掉，但這不代表刪除的語義。 &lt;a&gt; 有三種用法 一般網頁連結, 錨點, Email &lt;img&gt; &lt;figure&gt; &lt;figcaption&gt; &lt;table&gt; &lt;thead&gt; &lt;tbody&gt; &lt;tfooter&gt; &lt;tr&gt; &lt;td&gt; &lt;th&gt; &lt;ol&gt; &lt;ul&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt; &lt;form&gt; &lt;input&gt; &lt;select&gt; &lt;textarea&gt;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"html","slug":"html","permalink":"//andyyou.github.io/tags/html/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Compass 整理筆記","slug":"compass","date":"2013-08-30T08:15:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/08/30/compass/","link":"","permalink":"//andyyou.github.io/2013/08/30/compass/","excerpt":"使用 Compass 之前需要先安裝 ruby，這裡我們可以透過官方的教學來安裝，建議使用 rvm 的方式來管理各種版本的 ruby。","text":"使用 Compass 之前需要先安裝 ruby，這裡我們可以透過官方的教學來安裝，建議使用 rvm 的方式來管理各種版本的 ruby。 rvm 安裝方式1$ \\curl -L https://get.rvm.io | bash -s stable --ruby 設定 ruby 環境123$ gem update --system$ gem install compass$ compass -v // 確認版本與安裝完成 建立專案12$ compass create Project1 // 單純使用 css$ compass create Project2 --syntax sass // 使用 sass 建立之後 compass 會提示訊息告訴你， Congratulations! Your compass project has been created.意思是恭喜，你的專案已經建立了。然後呢如果你是用 sass，你現在應該在 sass 的目錄底下開始新增和編輯你的 sass 檔案例如： style.sass注意：底線開頭的 sass 檔案叫做 partials 可以稱之為局部文件如 _member.sass，他們不會被編譯成單檔而是匯入其他 sass 檔案中使用。關於 sass 的設定都在 config.rb 裡面。當你做了任何修改，你都需要重新編譯。 編譯指令1$ compass compile [專案路徑] // 到目錄為止 開始編寫 sass在這之前呢， compass 會好心的提醒你需要把下面這段代碼引入到你的 html 中 1234567&lt;head&gt; &lt;link href=\"/stylesheets/screen.css\" media=\"screen, projection\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;link href=\"/stylesheets/print.css\" media=\"print\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;!--[if IE]&gt; &lt;link href=\"/stylesheets/ie.css\" media=\"screen, projection\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;![endif]--&gt;&lt;/head&gt; 如果你跟我一樣是使用 jade 的話則如下 123456link(rel=&apos;stylesheet&apos;, href=&apos;/stylesheets/screen.css&apos;, media=&apos;screen, projection&apos;, type=&quot;text/css&quot;)link(rel=&apos;stylesheet&apos;, href=&apos;/stylesheets/print.css&apos;, media=&apos;print&apos;, type=&quot;text/css&quot;)//[if IE] link(rel=&apos;stylesheet&apos;, href=&apos;/path/project&apos;) &lt;![endif] 然後我們就可以試著在 sass 目錄加入自己的 style.sass並且輸入如下 12h2 color: red; 最後 compile 之後就可以看看了。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"sass","slug":"sass","permalink":"//andyyou.github.io/tags/sass/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Bower 簡介","slug":"bower-profile","date":"2013-08-29T06:09:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/08/29/bower-profile/","link":"","permalink":"//andyyou.github.io/2013/08/29/bower-profile/","excerpt":"Bower 是一套管理網頁套件的工具，他提供了一種通用且不受限制的方案來解決管理前端相關的套件如：jquery。支援的系統非常廣泛，並沒有太多相依性的東西。開發者也可以透過他管理套件的相依性和升級等等的問題。有了它，就不用到處去下載套件檔案(jquery, bootstrap)。","text":"Bower 是一套管理網頁套件的工具，他提供了一種通用且不受限制的方案來解決管理前端相關的套件如：jquery。支援的系統非常廣泛，並沒有太多相依性的東西。開發者也可以透過他管理套件的相依性和升級等等的問題。有了它，就不用到處去下載套件檔案(jquery, bootstrap)。 安裝Bower 相依於 Node 和 npm 安裝指令如下 1$ npm install -g bower 使用方法大部份的資訊，都可以在 bower help 提供的說明中找到，一旦安裝完成就可以開始使用了。Bower 是一組指令集，他們不需要使用 root 權限。如果你真的要限制權限則使用 --allow-root 安裝套件透過 bower.json 來安裝管理，bower.json 就像一組清單用來幫你記錄管理想要安裝的套件和版本，先把清單些完之後執行下面的指令就能一口氣安裝完畢。 1$ bower install 安裝在本地專案 12$ bower install &lt;package&gt;# ex: bower install jquery 指定版本 1$ bower install &lt;package&gt;#&lt;version&gt; 可以是下面任何一種值 套件名稱 ex: jquery。可以透過 bower search jquery 來尋找相關的套件名稱。 git 路徑 git://github.com/someone/some-package.git。 本地的 git 檔案庫。 縮寫的路徑 someone/some-package 預設是(github 上面的專案)。 網址指向一個 zip 或者 tar 檔案。 查詢已經安裝的套件1$ bower list 搜尋1$ boewr search [keyword] 安裝完後使用套件最簡單的方式就是直接使用預設路徑 1&lt;script src=\"/bower_components/jquery/index.js\"&gt;&lt;/script&gt; 對於更複雜的情況，你可能會需要使用腳本，或者使用一個載入模組。Bower 只是一個管理工具，此時可以使用其他的工具 - 如 RequireJS - 這將幫助你做到這一點。 移除1$ bower uninstall &lt;package-name&gt;","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"//andyyou.github.io/tags/javascript/"},{"name":"package manager","slug":"package-manager","permalink":"//andyyou.github.io/tags/package-manager/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"Box 屬性意義","slug":"meaning-box-properties","date":"2013-08-29T02:29:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/08/29/meaning-box-properties/","link":"","permalink":"//andyyou.github.io/2013/08/29/meaning-box-properties/","excerpt":"display: block : 前後會插入換行，寬會填滿父元素，高則是配合內容。可以用 width, height 設定。預設: h1, p, div display: inline : 不會換行，會連成一行。寬高都是依照內容，且不能使用 width, height。預設: span, a, em display: inline-block : 跟 inline 一樣，但能夠使用 width, height 設定寬高。 display: list-item : 變成 marker + block。 display: run-in : 如下圖 h2 被指定 run-in 它就會變成 inline 後續的元素如果是 block 就會如圖一樣合體。但是後續的元素如果是 inline 或者套用了 float, position ，那麼 h2 就會是 block。 註: Firefox 和 IE7 目前都不支援 run-in","text":"display: block : 前後會插入換行，寬會填滿父元素，高則是配合內容。可以用 width, height 設定。預設: h1, p, div display: inline : 不會換行，會連成一行。寬高都是依照內容，且不能使用 width, height。預設: span, a, em display: inline-block : 跟 inline 一樣，但能夠使用 width, height 設定寬高。 display: list-item : 變成 marker + block。 display: run-in : 如下圖 h2 被指定 run-in 它就會變成 inline 後續的元素如果是 block 就會如圖一樣合體。但是後續的元素如果是 inline 或者套用了 float, position ，那麼 h2 就會是 block。 註: Firefox 和 IE7 目前都不支援 run-in display: none : 隱藏 display: table : 表格 &lt;style type=&quot;text/css&quot;&gt; #container { overflow: hidden; display:table; width: 100%; } .row {display:table-row;} .row div {display: table-cell;} .a {background:#00ff00;} .b {background:#ff00ff;} .c {background:#0000ff;} &lt;/style&gt; &lt;div id=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;a&quot;&gt; test&lt;br /&gt;test&lt;br /&gt;test&lt;br /&gt;test&lt;br /&gt;test&lt;br /&gt;test&lt;br /&gt;test &lt;/div&gt; &lt;div class=&quot;b&quot;&gt; test &lt;/div&gt; &lt;div class=&quot;c&quot;&gt; test &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; display: compact : 可以插入在後續 block 的 margin 區域。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"viewport 與 media query","slug":"viewport-with-media-query","date":"2013-08-28T06:11:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/08/28/viewport-with-media-query/","link":"","permalink":"//andyyou.github.io/2013/08/28/viewport-with-media-query/","excerpt":"簡易觀念整個 Responsive Web Design 最主要的就是靠 css 中的 media query 搭配 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 這兩個部分來達成。 簡言之就是透過","text":"簡易觀念整個 Responsive Web Design 最主要的就是靠 css 中的 media query 搭配 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 這兩個部分來達成。 簡言之就是透過 1234567891011121314151617181920212223@media screen and (max-width:420px)&#123; // css here &#125;~~~ 來針對各種 size 的 width 做對應的設計，而裝置瀏覽器的解析度又可以使用 meta 來設定，就可以使用百分比來處理設計。原理的概念大致就如上敘述。隨著智慧型手機上網越來越多的情況下 apple 率先在 safari 定義了一個 meta `viewport` 用來設定瀏覽器的解析度。預設來說，如果都不設定的情況 safari 會用 width = `980px` 去解析網頁，Android 2.x 是 `800px` ，Android 3.0+ 為 `980px`。# 注意螢幕解析度不一定等於 `device-width`，Nexus One 是螢幕解析度(800)不等於device-width(320)的典型例子，iPhone4也是 – 螢幕解析度(960)，但 `device-width` 傳回值為(320)。# 原理這邊讓我們先回到影像處理的基本單位 pixel，一張 `800*600` pixel 的數位影像 可以想成是 `800*600` 個\"單色格子\"組出這張圖片，這就是單純圖片像素的定義。接著螢幕的呈像：例如設定 `800*600` 解析度，表示在你的螢幕上總共要顯示只要顯示這麼多格子，所以如果你螢幕很大。但是解析度設的很小（`640*480`） 就會看到影像變大了，因為一個\"物理格子\"變大了。換句話說 長跟寬各由 1024 及 768 個像素組合而成的長方形，面積共786432像素（長x寬）的顯像螢幕；此時，若有一個1024x768的圖檔，則它剛好可以填滿整個螢幕。# 關於 viewport~~~html &lt;meta name=\"viewport\" content=\"initial-scale=1.0, width:device-width\" /&gt; viewport 的作用是告訴瀏覽器，讀取這個 html 時可視區域有多大，於是瀏覽器就會根據 viewport 的設定去調整。其中最重要的是 width＝device-width 等於是告訴瀏覽器，寬有幾個 pixel 他會覆寫本來預設是 980px 的預設值 所以會發現網站的圖片變大了。例如：本來設計的手機版網頁寬是 590px 就可以在 viewport 設定 width=590。如此一來整個網頁就會完整呈現，但視覺上會變小。延伸自適應網站設計的用法則是讓 width=device-width，再透過 CSS 去設計各種手機尺寸的版型 如 320 * 480。 屬性和值 width:[數字] 或 device-width height:[數字] 或 device-height initial-scale:最小0.25，最大5 minimum-scale:最小0.25，最大5 maximum-scale:最小0.25，最大5 user-scalable:1 或 0 (yes 或 no)","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"CSS 選擇器筆記","slug":"css-selector-notes","date":"2013-08-28T02:25:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/08/28/css-selector-notes/","link":"","permalink":"//andyyou.github.io/2013/08/28/css-selector-notes/","excerpt":"* 通用選擇器 -&gt; 套用所有元素 1* &#123;color: yellow;&#125;","text":"* 通用選擇器 -&gt; 套用所有元素 1* &#123;color: yellow;&#125; 類型選擇器 1h1 &#123;color: red;&#125; id 1#container &#123;color: skyblue;&#125; class 1.span2 &#123; color: hotpink;&#125; 屬性 過濾對應標籤元素中的屬性 &lt;a rel=&quot;friend&quot; href=&quot;http://www.w3c.com/&quot;&gt;w3c&lt;/a&gt; a[rel='friend'] {color: blue;} a[attr=’value’] 全部都要符合。 a[attr*=’value’] 只要有包含 value 都會被選中。 a[attr^=’value’] 只要開頭有都會被選中。 a[attr$=’value’] 只要結尾有 value 都會中。 a[attr~=’value’] 以空格隔開的字串清單中，符合的就會中。 a[attr|=’value’] 以 - 隔開的字串清單中，如果開頭包含字串 value 。需要注意的是下圖 f 沒有被選中。 div p div 裡面的 p 都會被選中。 div &gt; p 只有 div 內第一階的子元素會被選中。 div + ul 跟 div 同階層並緊跟著 div 後面的 ul 才會被影響。 div ~ p div 同階層後面所有的 p。 a, em 套用同一個設定。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"CSS 覆寫規則","slug":"css-write-rules","date":"2013-08-27T03:55:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/08/27/css-write-rules/","link":"","permalink":"//andyyou.github.io/2013/08/27/css-write-rules/","excerpt":"你是否曾經遇過這種情形，當您試著要套用某個 CSS 規則到元素的時候，它就是不產生變化。網頁看起來就是忽略了您的 CSS ，然後根本搞不清楚到底是為什麼。也許您使用了 !important 作為您最後的手段，這裡就有一個很好的機會來理解 CSS 選擇器的優先順序。","text":"你是否曾經遇過這種情形，當您試著要套用某個 CSS 規則到元素的時候，它就是不產生變化。網頁看起來就是忽略了您的 CSS ，然後根本搞不清楚到底是為什麼。也許您使用了 !important 作為您最後的手段，這裡就有一個很好的機會來理解 CSS 選擇器的優先順序。 深入理解 CSS 優先順序可以幫助你減少 CSS 挫折，讓你的程式碼更加簡潔，更有組織，所以讓我們來看看三個控制 CSS 的規則。 選擇器的權重計算(Specificity) 繼承 CSS 規則的累加 精通這些規則將會帶領你進入 CSS 開發的下一個層次 選擇器的權重計算舉例來說您有一個 p 標籤包含著一段文字，設定如下 123456&lt;style&gt;p &#123;font-size: 12px;&#125;p.bio&#123;font-size: 36px;&#125;&lt;/style&gt;&lt;p class='bio'&gt;text here&lt;/p&gt; 您會猜測上面這個範例文字應該是 36px，第二句的選擇器 p.bio 更明確的指向該元素。 然而有些時候選擇器並不是那麼單純好分辨。 12345678&lt;div id='sidebar'&gt; &lt;p class='bio'&gt;text here&lt;/p&gt;&lt;/div&gt;&lt;style&gt;div p.bio &#123;font-size: 14px;&#125;#sidebar p &#123;font-size: 12px;&#125;&lt;/style&gt; 乍看之下第一句 CSS 看起來更明確的指定元素，但實際上顯示的樣式是第二行。 為什麼？ 要回答這個問題，我們需要考慮 CSS 的選擇器的權重計算。 關於 CSS 選擇器權重計算，是透過計算每個樣式的組成然後產生一組表達式(a,b,c,d) 元素，構造虛擬類別元素(a:root) =&gt; d = 1 // (0,0,0,1) class, 虛擬類別(a:hover), 屬性 =&gt; c = 1 // (0,0,1,0) Id =&gt; b = 1 // (0,1,0,0) Inline Style =&gt; a = 1 // (1,0,0,0) 你可以透過上述的規則開始計算選擇器的權重，算法就是每使用到一種就在該欄位(a,b,c,d) 加 1。注意：(0,0,1,0) 的明確性大於 (0,0,0,15) 範例如下： p: 1 element – (0,0,0,1) div: 1 element – (0,0,0,1) #sidebar: 1 id – (0,1,0,0) div#sidebar: 1 element, 1 id – (0,1,0,1) div#sidebar p: 2 elements, 1 id – (0,1,0,2) div#sidebar p.bio: 2 elements, 1 class, 1 id – (0,1,1,2) 所以上面 sidebar 的範例就會是如下 123div p.bio&#123;font-size: 14px;&#125; //(0,0,1,2)#sidebar p&#123;font-size: 12px;&#125; //(0,1,0,1) 最後在我們繼續往下之前要先瞭解。!important 勝過 Specificity。 12div p.bio &#123;font-size: 14px !important&#125;#sidebar p &#123;font-size: 12px&#125; 事實上，如果你能明確知道規則的優先順序你應該是不需要使用 !important。 繼承繼承背後的想法是比較容易理解的。元素繼承父容器的樣式。如果你設置 body 標籤，color: red; 然後 body 內的所有元素的文本字體也將是紅色的，除非另外有其他設定。 但是並非所有的 CSS 屬性都是可繼承的。例如 margin 和 padding 是非繼承的屬性。如果您對一個 div 設置了 margin 和 padding 。你會發現 div 裡面的段落沒有繼承你的 div 設置 margin 和padding。該段將使用預設的瀏覽器margin 和 padding，直到有另外的設定。 你可以使用明確宣告設定屬性的繼承，從它的父容器繼承樣式： 1p &#123;margin: inherit; padding: inherit&#125; 然後 p 就會繼承包復他的父元素。 CSS 規則的累加CSS 規則的累加與優先順序的工作原理如下。 1. 找到所有的 css 宣告和對應的元素。2. 根據原始碼和優先權排序。3. !important 優先4. 頁面設定為優先12345678&lt;style&gt;p &#123;font-size: 12px&#125;&lt;/style&gt;~~~ #### 5. 外部載入~~~html&lt;link rel='stylesheet' href='style.css' /&gt; 6. 選擇器的權重計算(Specificity)7. 如果兩個規則相等則宣告的最後宣告的規則會覆寫。","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"css","slug":"css","permalink":"//andyyou.github.io/tags/css/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Model Binding Validation 資料模型的驗證機制","slug":"model-binding-validation","date":"2013-03-12T21:10:00.000Z","updated":"2016-10-10T12:08:44.000Z","comments":true,"path":"2013/03/13/model-binding-validation/","link":"","permalink":"//andyyou.github.io/2013/03/13/model-binding-validation/","excerpt":"資料模型的驗證機制在物件導向的世界裡有很多種方式可以驗證資料模型(Model Class) 。大部分的情況下我們可以在 Property的 setter 裡面作資料的確認。就是如下程式碼","text":"資料模型的驗證機制在物件導向的世界裡有很多種方式可以驗證資料模型(Model Class) 。大部分的情況下我們可以在 Property的 setter 裡面作資料的確認。就是如下程式碼 123456789101112public class Car&#123; private int _id; public int Id &#123; get&#123;return _id;&#125; set&#123; // validate here _id = value; &#125; &#125;&#125; 主要的原因是後續使用這個物件的時候不會遇到不符合規則的資料導致物件出例外。第二個理由是當我們要控制這個屬性的時候比較單純。任何資料要設定到物件的屬性上都是透過 setter 而且可以確保資料是正確符合規範的。事實上在 MVVM 架構下透過 setter 來處理例外和商業邏輯仍然是最簡單的選擇。但假如有一個 Car 類別包含 Color 屬性且資料是根據另一個 Type 類別提供的，然後您就會發現每當您使用 ORM 直接載入物件的時，如果想設定 Color 之前必須先設定 Type 的資料，因為驗證規則寫在 Type 的 setter。 在 ASP.NET MVC 架構下建議您不要直接在 setter 驗證。而是使用 ASP.NET MVC 內建的 ModelState ，它可以透過在 Model 屬性宣告規則或實作 IValidatableObject 然後當資料從 Form 表單透過 Http Request 傳入的時 Model Binding 機制會在繫結時幫您確認資料是否有正確。例如下面 Action， 1public ActionResult Edit(Car car)&#123; ... ModelState 讓您可以在 Controller 的 Action 中判斷資料，在資料儲存之前可以判斷是否有錯誤，然後處理。 123456789101112[HttpPost]public ActionResult Edit(Car car)&#123; if(ModelState.IsValid) &#123; // Update code to be placed here return RedirectToAction(\"CarList\"); &#125;else &#123; return View(\"CarEdit\", car); &#125;&#125; 上面的程式碼描述了關於編輯 Car 物件，程式碼的第一行 ModelState.IsValid 屬性會回傳 true/false 代表本次的驗證是否通過。如果如果模型繫結發生錯誤，或者有商業邏輯上的錯誤， ASP.NET MVC 會告知您或者也可以使用 IValidatable 這個介面實作 Validate Method 在這個 Method 裡面您需要自己實作商業邏輯。每當一個錯誤發生，你就要把錯誤訊息加入錯誤資訊集合然後回傳。下面是一個範例 1234567891011121314151617181920212223public class Car: IValidatableObject&#123; public int Id&#123;get;set;&#125; public string Name&#123;get;set;&#125; public string Type&#123;get;set;&#125; public string Color&#123;get;set;&#125; public IEnumerable&lt;ValidationResult&gt; Validate(ValidationContext validationContext) &#123; if(string.IsNullOrEmpty(Name)) &#123; yield return new ValidationResult(\"Name is mandatory\", new[] &#123;\"Name\"&#125;); &#125; if(string.IsNullOrEmpty(Type)) &#123; yield return new ValidationResult(\"Type is mandatory\", new[]&#123;\"Type\"&#125;); &#125; if(string.IsNullOrEmpyt(Color)) &#123; yield return new ValidationResult(\"Color is mandatory\", new[] &#123;\"Color\"&#125;); &#125; &#125;&#125; 上面我們看到有三種屬性的驗證規則如果錯誤會透過 yield 敘述式將資訊回傳到集合中。這個錯誤資訊集合是一個泛型，資料型別是 ValidationResult 這個類別讓您可以加入錯誤訊息。 123456789101112131415161718192021222324public class Car: IValidatableObject&#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public string Type &#123; get; set; &#125; public string Color &#123; get; set; &#125; public IEnumerable&lt;ValidationResult&gt; Validate(ValidationContext validationContext) &#123; if(string.IsNullOrEmpty(Name)) &#123; yield return new ValidationResult(\"Name is mandatory\", new[] &#123;\"Name\"&#125;); &#125; if (string.IsNullOrEmpty(Type)) &#123; yield return new ValidationResult(\"Type is mandatory\", new[] &#123; \"Type\" &#125;); &#125; if (string.IsNullOrEmpty(Color)) &#123; yield return new ValidationResult(\"*\", new[] &#123; \"Color\" &#125;); yield return new ValidationResult(\"Color is mandatory\"&#125;); &#125; &#125;&#125; 又或者您也可以使用 Data Annotation 的方式定義驗證規則 12345678910public class Car&#123; public int Id &#123; get; set; &#125; [Required] public string Name &#123; get; set; &#125; [Required] public string Type &#123; get; set; &#125; [Required] public string Color &#123; get; set; &#125;&#125; 現在我們已經可以在執行資料模型繫結順便幫 Model 類別驗證，然後我們就在 Controller 的 Action 中控制整個流程。而且關於資料驗證的規則我們依然把它寫在 Model 裡面。 我們當然不希望任何人可以編輯一個不能用的資料。這時我們就可以在 Action 先做處理。如果該資料不存在或不能用了我們就使用 ModelState.AddModelError 追加錯誤訊息。 12345678910111213141516171819[HttpPost]public ActionResult Edit(Car car)&#123; if(IsCarAvailable()) &#123; ModelState.AddModelError(string.Empty,\"Car cannot be edited because not available anymore\"); &#125; if(ModelState.IsValid) &#123; //Update code to be placed here return RedirectToAction(\"CarList\"); &#125; else &#123; return View(\"CarEdit\",car); &#125;&#125; 檢索所有的錯誤訊息； 1var allErrors = ModelState.Values.SelectMany(e =&gt; e.Errors).Select(gh =&gt; gh.ErrorMessage); 另外如果在 ASP.NET MVC 中我們也可以透過 Action 和 View 搭配檢查或實驗錯誤。我們先建立一個 Action 如下 123456public ActionResult EditCar(Car car)&#123; // var errors = ModelState.Values.SelectMany(e =&gt; e.Errors).Select(gh =&gt; gh.ErrorMessage); ViewBag.Validation = ModelState.IsValid; return View();&#125; 然後再對應的 View 使用 123456@ViewBag.Validation@foreach (ModelState modelState in ViewData.ModelState.Values) &#123; foreach (ModelError error in modelState.Errors) &#123; &lt;li&gt;@error.ErrorMessage&lt;/li&gt; &#125;&#125;","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":".net mvc","slug":"net-mvc","permalink":"//andyyou.github.io/tags/net-mvc/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Entity Framework Code First Migration","slug":"asp-net-mvc-migrations","date":"2013-03-11T23:04:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2013/03/12/asp-net-mvc-migrations/","link":"","permalink":"//andyyou.github.io/2013/03/12/asp-net-mvc-migrations/","excerpt":"大綱本練習將介紹 Entity Framework Code First Migration 整個使用的概觀:主題包含: 啟動 Migrations. 建立與執行 Migrations. 自訂 Migrations. 資料遷移和使用SQL指令. 遷移指定的版本. 建立 SQL Script. 程式啟動時自動更新資料結構.","text":"大綱本練習將介紹 Entity Framework Code First Migration 整個使用的概觀:主題包含: 啟動 Migrations. 建立與執行 Migrations. 自訂 Migrations. 資料遷移和使用SQL指令. 遷移指定的版本. 建立 SQL Script. 程式啟動時自動更新資料結構. 建置初始化Model和資料庫在我們開始介紹如何使用資料庫遷移(Migrations)之前我們需要一個專案和 Model。在這個練習中我們將模擬一個 Blog 建立 Blog 和 Post 的 Model。 新增主控台應用程式 (Console Project) 並命名為 MigrationsDemo。 透過 Nuget 安裝最新版的 EntityFramewrok。2-1. 工具 -&gt; 程式庫套件管理員 -&gt; 套件管理員主控台。2-2. 執行 Install-Package EntityFramework 指令。2-3. 加入一個 Model.cs 類別程式碼如下: 12345678910111213141516using System.Data.Entity;using System.Collections.Generic;using System.ComponentModel.DataAnnotations;using System.Data.Entity.Infrastructure;namespace MigrationsDemo&#123; public class BlogContext:DbContext &#123; public DbSet&lt;Blog&gt; Blogs &#123; get; set; &#125; &#125; public class Blog &#123; public int BlogId &#123; get; set; &#125; public string Name &#123; get; set; &#125; &#125;&#125; 上面的程式碼定義了 Blog 類別和一個 BlogContext 類別 (BlogContext 類別繼承了 DbContext，而 DbContext，而 類別是簡化過的 Context 類別官方建議在Code first 模式下使用。)現在我們有了 Model 可以用它來執行資料存取，接著更新 Program.cs 程式碼如下: 12345678910111213141516171819202122232425262728using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace MigrationsDemo&#123; class Program &#123; static void Main(string[] args) &#123; using (var db = new BlogContext()) &#123; db.Blogs.Add(new Blog &#123; Name=\"Another Blog\"&#125;); db.SaveChanges(); foreach (var blog in db.Blogs) &#123; Console.WriteLine(blog.Name); &#125; Console.WriteLine(\"Press any key to exit...\"); Console.ReadKey(); &#125; &#125; &#125;&#125; 執行應用程式您將會看到 MigrationsDemo.BlogContext 被建立了。您可能會疑惑此時我們完全沒有設定任何相關的連線字串也沒有指定任何資料庫。如果您練習的電腦有安裝 SQL Express 則預設 Code First 機制會先搜尋本機的 .\\SQLEXPRESS。如果您沒有安裝 SQL Express 則 Code First 會嘗試使用(LocalDb)\\v11.0 來建立資料庫。一般來說 Visual Studio 2010 預設安裝會包含 SQL Express。而 Visual Studio 2012 則預設安裝包含 LocalDb。注意如果您兩個都有安裝的話 SQL Express 會優先使用。 啟動 Migrations在 Code First 模式下 Migrations 資料庫遷移指的是一種機制讓我們可以修改資料庫，資料表結構。 接著編輯 Model，在 Blog類別中加入一個 Url 的屬性(Property)。 1public string Url&#123; get; set; &#125; 完成之後讓我們直接運行程式(F5)。這個時候您會得到一個 InvalidOperationException 例外。意思是 Model 已經變更了，因此無法跟已存在的資料庫對應。 此時例外的提示資訊會建議我們啟動 Code First Migrations 接著我們就在【套件管理員主控台】執行: 1Enable-Migrations 這個指令會加入一個 Migrations 目錄。裡面會新增兩個檔案: 設定類別 (Configuration.cs)這個類別可以讓您自訂一些資料庫遷移時的行為，意思就是當我們要變更資料結構時可以追加一些設定。例如: 使用 Seed() 在建立資料表時幫您補上預設的資料，或者幫欄位設定預設值。 資料遷移檔 ([時間戳記]_InitialCreate.cs)主要的資料遷移檔案是一個關於建立資料表，修改資料結構的 Script 。因為我們已經利用 Code First 幫我們建立了一個資料庫，所以這個遷移檔就會根據目前的資料庫結構產生一個對應的遷移檔。在我們這個範例中您會看到: 12345678CreateTable( \"dbo.Blogs\", c =&gt; new &#123; BlogId = c.Int(nullable: false, identity: true), Name = c.String(), &#125;) .PrimaryKey(t =&gt; t.BlogId); 很明顯的我們看到程式建立了一張資料表 Blog 只包含 BlogId 和 Name 欄位。如果此時我們都沒有建立資料庫，這個遷移檔就不會被建立，直到我們第一次呼叫 Add-Migration 指令才會產生。另外當我們要做一次結構變更時就是使用: 1Add-Migration [name] 建立與執行 MigrationsCode First 的 Migrations 機制主要有兩個指令。這兩個指令很重要必須要熟悉它們。 Add-Migration會基於您這次對 Model 做得變更產生出新的資料遷移檔 (Migration) Update-Database就會把關於 Migration 和 Configuration 檔的內容對資料庫產生實際的變動。 現在我們需要對我們已經變更的 Model 產生一個 Migration 檔 1. 執行下面的指令1Add-Migration AddBlogUrl 2. 在 Migraions 目錄底下我們看到了一個新增的遷移檔。看看內容1234public override void Up()&#123; AddColumn(\"dbo.Blogs\", \"Url\", c =&gt; c.String());&#125; 大概就可以知道資料遷移檔幫我們對 Table 新增了欄位。接著就可以執行: 1Update-Database Code First Migrations 機制就會幫我們去比對每一個資料庫遷移檔然後對資料庫做修改。 自訂 Migrations目前為止，我們建立並執行了 Migration 但我們並沒有改變任何關於遷移檔的設定。讓我們來看看如何修改預設產生的遷移檔。 1. 對 Model 修改，增加一個 Rating 屬性:1public int Rating &#123; get; set; &#125; 2. 接著再新增一個 Post 類別:12345678910public class Post &#123; public int PostId &#123; get; set; &#125; [MaxLength(200)] public string Title &#123; get; set; &#125; public string Content &#123; get; set; &#125; public int BlogId &#123; get; set; &#125; public Blog Blog &#123; get; set; &#125; &#125; 3. 建立完成後我們再對 Blog 類別增加:1public virtual List&lt;Post&gt; Posts &#123; get; set; &#125; 再次使用 Add-Migration 來替我們產生遷移檔執行 1Add-Migration AddPostClass Code Fist Migrations 機制很盡責地幫我們對應結構產生了 Migration 檔，但在這邊我們想要作一些改變。 1. Posts.Title 欄位不得重複(unique)1.Index(p =&gt; p.Title, unique: true); 2. 不得為 null我們也增加了一個不得為 null 的 Blogs.Rating 欄位。如果有任何資料已存在資料表中將會得到 CLR 資料型別的預設值，例如 Rating 是 int 如果 Blog 資料表已經有資料那這欄位就會得到 0 。在這邊我們也透過修改遷移檔把預設值變成 3 。完成的範例如下: 123456789101112131415161718192021222324252627282930313233343536namespace MigrationsDemo.Migrations&#123; using System; using System.Data.Entity.Migrations; public partial class AddPostClass : DbMigration &#123; public override void Up() &#123; CreateTable( \"dbo.Posts\", c =&gt; new &#123; PostId = c.Int(nullable: false, identity: true), Title = c.String(maxLength: 200), Content = c.String(), BlogId = c.Int(nullable: false), &#125;) .PrimaryKey(t =&gt; t.PostId) .ForeignKey(\"dbo.Blogs\", t =&gt; t.BlogId, cascadeDelete: true) .Index(t =&gt; t.BlogId) .Index(p =&gt; p.Title, unique: true); AddColumn(\"dbo.Blogs\", \"Rating\", c =&gt; c.Int(nullable: false, defaultValue: 3)); &#125; public override void Down() &#123; DropIndex(\"Posts\", new[] &#123; \"Title\" &#125;); DropIndex(\"dbo.Posts\", new[] &#123; \"BlogId\" &#125;); DropForeignKey(\"dbo.Posts\", \"BlogId\", \"dbo.Blogs\"); DropColumn(\"dbo.Blogs\", \"Rating\"); DropTable(\"dbo.Posts\"); &#125; &#125;&#125; 當我們完成所有的編輯就可以使用 Update-Database 去修改資料庫實際的表格結構，這一次我們使用 -Verbose 參數來看看實際執行Migration時的詳細資料: 1Update-Database -Verbose 當我們使用這個指令時就會看到: 1234567891011121314151617181920PM&gt; Update-database -verboseUsing StartUp project 'MigrationsDemo'.Using NuGet project 'MigrationsDemo'.Specify the '-Verbose' flag to view the SQL statements being applied to the target database.Target database is: 'MigrationsDemo.BlogContext' (DataSource: (localdb)\\v11.0, Provider: System.Data.SqlClient, Origin: Convention).Applying code-based migrations: [201303100605244_AddPostClass].Applying code-based migration: 201303100605244_AddPostClass.CREATE TABLE [dbo].[Posts] ( [PostId] [int] NOT NULL IDENTITY, [Title] [nvarchar](200), [Content] [nvarchar](max), [BlogId] [int] NOT NULL, CONSTRAINT [PK_dbo.Posts] PRIMARY KEY ([PostId]))CREATE INDEX [IX_BlogId] ON [dbo].[Posts]([BlogId])CREATE UNIQUE INDEX [IX_Title] ON [dbo].[Posts]([Title])ALTER TABLE [dbo].[Blogs] ADD [Rating] [int] NOT NULL DEFAULT 3ALTER TABLE [dbo].[Posts] ADD CONSTRAINT [FK_dbo.Posts_dbo.Blogs_BlogId] FOREIGN KEY ([BlogId]) REFERENCES [dbo].[Blogs] ([BlogId]) ON DELETE CASCADE[Inserting migration history record]Running Seed method. 資料遷移和使用SQL目前為止我們看過了關於資料遷移的操作，但我們並沒有改變或搬移任何資料，讓我們複習一下目前為止重要的指令: 123Enable-MigrationsAdd-Migration [name]Update-Database -Verbose 有些情況下我們需要搬移資料。目前 Migration 機制還沒有支援資料搬移，但我們可以透過使用 SQL 指令來完成這個任務。新增一個 Post.Abstract 1public string Abstract &#123; get; set; &#125; 然後我們想要預先為已存在的 Post 資料列填入 Abstract(摘要) 而且這些內容要從 Content 取得。編輯Model之後執行: 1Add-Migration AddPostAbstract 執行完 Add-Migration 之後遷移檔中就幫我們設定了關於資料表結構變更的程式但是我們想要預先將 Content 欄位中的前 100 個字元填入 Abstract接著讓我們修改遷移檔 12345678910111213141516171819namespace MigrationsDemo.Migrations&#123; using System; using System.Data.Entity.Migrations; public partial class AddPostAbstract : DbMigration &#123; public override void Up() &#123; AddColumn(\"dbo.Posts\", \"Abstract\", c =&gt; c.String()); Sql(\"UPDATE Posts SET Abstract = LEFT(Content, 100) WHERE Abstract IS NULL\"); &#125; public override void Down() &#123; DropColumn(\"dbo.Posts\", \"Abstract\"); &#125; &#125;&#125; 編輯完成之後讓我們再度執行 Update-Database 遷移指定的版本(包含降版)到這一小節我們都是升級最新的 Migration 檔，但有可能有些時候你想要升級/降級到特定的遷移檔。假設我們想要改變資料庫到 AddBlogUrl 這個遷移檔我們可以使用 TargetMigration 切換到降版 執行 1Update-Database –TargetMigration: AddBlogUrl 這個指令會執行程式中 Down() 的 Script 一路從 AddBlogAbstract 一直往下降版本，所以這邊要注意的是每一版和上一版之間的 Down() 如果有自訂的設定也要有對應的還原。 建立 SQL Script如果其他的開發者想要在他們的機器執行這些改變，他們只需要在版本控制系統取得每一次的改變(資料庫遷移檔)。每當我們更新他們就可以透過 Migration 檔案和 Update-Database 指令切換資料庫的結構。然而如果我們想要傳遞這些變更到測試伺服器並且模擬實際產品環境我們可能想要 SQL Script 如此我們就可以把工作交給DBA。 執行 Update-Database 不過這次我們帶入參數 -Script 1Update-Database -Script 接著就會產生 SQL Script 而且沒有變更資料庫，我們也可以指定一個 source 和一個 target 來產生特定條件的 SQL。 我們想要產生從空白資料庫到最新版的 Script 時 1Update-Database -Script -SourceMigration: $InitialDatabase -TargetMigration: AddPostAbstract 註: 如果你不指定 target Migration 將會使用最新的遷移檔。如果你不指定 source Migration會使用目前資料庫的狀態。 於程式啟動時自動更新資料結構如果你想要發佈的應用程式，當程式執行時自動更新資料庫您可以透過註冊 MigrateDatabaseToLatestVersion 初始化物件來辦到。一個資料庫初始化物件 (Database initializer) 只是用來確認資料庫目前是否設定正確。這些邏輯在第一次 Context 類別被使用的時候執行。當我們更新 Programs.cs 如下: 註: 注意您需要加入 System.Data.Entity 因為要使用 Database.SetInitializer()。當我們建立了一個初始化物件時我們需要指定 context type (BlogContext) 和 migration 的設定檔(Configuration)。Configuration 類別會在我們使用 Enable-Migrations 時一起被加入 Migrations 目錄程式碼如下: 123456789101112131415161718192021222324252627282930using System;using System.Collections.Generic;using System.Data.Entity;using System.Linq;using System.Text;using System.Threading.Tasks;namespace MigrationsDemo&#123; class Program &#123; static void Main(string[] args) &#123; Database.SetInitializer(new MigrateDatabaseToLatestVersion&lt;BlogContext, Migrations.Configuration&gt;); using (var db = new BlogContext()) &#123; db.Blogs.Add(new Blog &#123; Name=\"Another Blog\"&#125;); db.SaveChanges(); foreach (var blog in db.Blogs) &#123; Console.WriteLine(blog.Name); &#125; Console.WriteLine(\"Press any key to exit...\"); Console.ReadKey(); &#125; &#125; &#125;&#125; 現在每當您的應用程式執行的時候就會先確認資料庫如果有變動就會自動 Migration 。 在這個練習你看到了如何設定結構，修改和使用程式來變更您的資料庫。您也學習到如何取得SQL Script和如何使用遷移檔。以及最後如何自動化變更資料庫。","categories":[{"name":"Database","slug":"Database","permalink":"//andyyou.github.io/categories/Database/"}],"tags":[{"name":"entity framework","slug":"entity-framework","permalink":"//andyyou.github.io/tags/entity-framework/"}],"keywords":[{"name":"Database","slug":"Database","permalink":"//andyyou.github.io/categories/Database/"}]},{"title":"Ec2 Note","slug":"ec2-note","date":"2012-03-01T15:56:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2012/03/01/ec2-note/","link":"","permalink":"//andyyou.github.io/2012/03/01/ec2-note/","excerpt":"登入 Login1$ ssh -i /path/key/filename.pem ec2-user@xxx.xxx.xxx.xxx # OR DNS Pub Url 注意：/path/key/filename.pem的權限須為600。","text":"登入 Login1$ ssh -i /path/key/filename.pem ec2-user@xxx.xxx.xxx.xxx # OR DNS Pub Url 注意：/path/key/filename.pem的權限須為600。 變更登入不使用憑證1234#Edit /etc/ssh/sshd_config#Edit PasswordAuthentication no to yes$ sudo /sbin/service sshd restart #Restart sshd$ passwd ec2-user #Setting ec2-user password 快速安裝LAMP12$ yum groupinstall \"Web Server\"$ yum groupinstall \"MySQL Database\" 參考資源阿正老師教你免費玩Amazon EC2雲端主機(上)阿正老師教你免費玩Amazon EC2雲端主機(下)How to create an Amazon EC2 instance with Apache, PHP and MySQL (LAMP)快速安裝 Amazon EC2 LAMP 環境 (EC2 Console)","categories":[{"name":"Cloud","slug":"Cloud","permalink":"//andyyou.github.io/categories/Cloud/"}],"tags":[{"name":"aws","slug":"aws","permalink":"//andyyou.github.io/tags/aws/"}],"keywords":[{"name":"Cloud","slug":"Cloud","permalink":"//andyyou.github.io/categories/Cloud/"}]},{"title":"Sublime Text 2 小技巧：開啓Browser","slug":"sublime-text-2-tip","date":"2012-01-14T21:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2012/01/15/sublime-text-2-tip/","link":"","permalink":"//andyyou.github.io/2012/01/15/sublime-text-2-tip/","excerpt":"Open In Browser 設定Step 1開啓Preferences -&gt; Browse Packages…","text":"Open In Browser 設定Step 1開啓Preferences -&gt; Browse Packages… Step 2在HTML目錄底下建立OpenBrowserCommand.py檔案 程式碼貼入 1234567import sublime, sublime_pluginimport webbrowserclass OpenBrowserCommand(sublime_plugin.TextCommand): def run(self,edit): url = self.view.file_name() webbrowser.open_new(self.view.file_name()) Step 3在編輯HTML檔案時，Ctrl + P 開啓指令列輸入 1view.run_command('open_browser') 其他這邊小小記錄一下相關的小技巧，另外其實這個技巧可以找到其他文章是FOR開啓PHP等但因為小弟沒有這個需求，單純因為測試HTML每次都要打開Broswer點兩下感到不舒服＝ ＝","categories":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}],"tags":[{"name":"osx","slug":"osx","permalink":"//andyyou.github.io/tags/osx/"}],"keywords":[{"name":"Tools","slug":"Tools","permalink":"//andyyou.github.io/categories/Tools/"}]},{"title":"處理 Rack Server Error","slug":"rack-server-error","date":"2011-11-25T20:05:00.000Z","updated":"2016-10-10T13:21:35.000Z","comments":true,"path":"2011/11/26/rack-server-error/","link":"","permalink":"//andyyou.github.io/2011/11/26/rack-server-error/","excerpt":"錯誤訊息：1initialize: Address already in use","text":"錯誤訊息：1initialize: Address already in use 解決方式：查詢程序ID 12$ lsof -iTCP:3000$ lsof |grep 3000 刪除卡住程序 1$ kill -9 00000 # 0000 = ID","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"RoR","slug":"RoR","permalink":"//andyyou.github.io/tags/RoR/"},{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"},{"name":"rack server","slug":"rack-server","permalink":"//andyyou.github.io/tags/rack-server/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Get gem path","slug":"find-gem-path","date":"2011-11-16T15:20:00.000Z","updated":"2016-10-10T13:17:03.000Z","comments":true,"path":"2011/11/16/find-gem-path/","link":"","permalink":"//andyyou.github.io/2011/11/16/find-gem-path/","excerpt":"取得Gem環境資訊1$ gem env","text":"取得Gem環境資訊1$ gem env 取得正在引入gem資訊1234require 'rubygems'require 'cucumber'gem_root = Gem.loaded_specs['cucumber'].full_gem_pathgem_lib = File.join(gem_root, 'lib')","categories":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}],"tags":[{"name":"ruby","slug":"ruby","permalink":"//andyyou.github.io/tags/ruby/"}],"keywords":[{"name":"Program","slug":"Program","permalink":"//andyyou.github.io/categories/Program/"}]},{"title":"Linux/Windows RSA Key 常用指令","slug":"authentication-agent","date":"2011-11-15T21:30:00.000Z","updated":"2016-10-10T13:22:24.000Z","comments":true,"path":"2011/11/16/authentication-agent/","link":"","permalink":"//andyyou.github.io/2011/11/16/authentication-agent/","excerpt":"123$ ssh-keygen -t rsa -C \"youraccount@com.tw\" #建立金鑰$ ssh-add ~/.ssh/id_rsa #加入金鑰$ ssh-add -l #列出金鑰清單","text":"123$ ssh-keygen -t rsa -C \"youraccount@com.tw\" #建立金鑰$ ssh-add ~/.ssh/id_rsa #加入金鑰$ ssh-add -l #列出金鑰清單 Error狀況: Could not open a connection to your authentication agent 12$ ssh-agent bash$ ssh-add Permissions 0644 for ‘/c/Users/HelloWorld/.ssh/id_rsa’ are too open. 12$ cd ~/.ssh$ chmod 700 id_rsa","categories":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}],"tags":[{"name":"linux","slug":"linux","permalink":"//andyyou.github.io/tags/linux/"}],"keywords":[{"name":"System","slug":"System","permalink":"//andyyou.github.io/categories/System/"}]}]}